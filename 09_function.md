# 9: 일을 나누는 방법: 함수(Function)

우리는 지금까지

- `int`로 값을 만들고 계산하기
- `if`로 갈림길을 만들기
- `for`로 같은 일을 여러번 반복하기
- 배열로 많은 값을 한꺼번에 다루기

을 해봤다. 

그런데 여기까지 오면, 필연적으로 이런 상황을 만나게 된다. 

- `main` 함수에 코드가 많아져서 읽기 어려워진다.
- 비슷한 코드를 복사해서 붙여넣다 보니, 코드에 문제가 있어서 고쳤을 때 비슷한 다른 코드를 모두 찾아서 고쳐야 한다.
- 여러개의 `for`문이 각각 어떤 일을 하는지 해석하는데 오랜 시간이 걸린다.

여기서 필요한 프로그래밍 핵심 도구가 **함수(Function)** 이다. 

**함수란?**

특정한 작업을 수행하는 코드 덩어리에 이름을 붙인 것. 입력(매개변수)를 넣으면, 내부에서 처리를 해서 결과(반환값)을 뱉어내는 작은 공장과 같다. 

> 이 장의 목표
>
> **기본기**: 함수의 정의(만들기), 호출(쓰기), 선언(미리 알리기)의 3단계를 익힌다.
> **흐름 제어**: `return`이 값을 돌려주는 것뿐만 아니라, **함수의 즉시 종료**를 의미함을 이해한다.
> **데이터 전달**: `int` 같은 변수는 **복사본**이 전달되어 원본이 안전하다는 것을 확인한다.
> **배열 전달**: 반대로 배열을 함수로 보낼 때는 원본이 변경될 수 있음을 경험한다.
> **유효 범위(Scope)**: main의 변수 x와 함수 안의 변수 x는 서로 남남임을 이해한다.
> **C89의 규율**: 컴파일러에게 "이런 함수가 있을 거야"라고 미리 알려주는 함수 원형(Prototype)이 왜 필수적인지 배운다.

## 9.1 왜 함수가 필요한가

배열을 배웠으니, 이제 이런 코드를 쓸 수 있다.

```c
int main()
{
    int i;
    int a[5] = { 10, 20, 30, 40, 50 };
    int sum = 0;

    /* 배열 a의 합계 구하기 */
    for (i = 0; i < 5; i = i + 1) {
        sum = sum + a[i];
    }

    return 0;
}
```

문제는 이 다음이다. 프로그램이 커져서 **배열 `b`의 합계도 필요해진 상황**을 생각해보자. 

초보자는 보통 이렇게 해결한다.

```c
/* (나쁜 흐름) 같은 코드 복사 + 붙여넣기 */

/* a의 합계 */
for (i = 0; i < 5; i = i + 1) {
    sum_a = sum_a + a[i];
}

/* b의 합계 (복사해서 변수명만 바꿈) */
for (i = 0; i < 5; i = i + 1) {
    sum_b = sum_b + b[i];
}
```

이렇게 복사해서 코드를 늘리면 세 가지 문제가 발생한다.

1. 유지보수 지옥: `for`문 안에 버그가 있어서 고치려면, 복사한 곳을 전부 찾아다니며 고쳐야 한다. 
2. 실수 유발: `b`의 합계를 구하는 코드인데, 실수로 `sum_a`를 더하는 오타를 내기 쉽다.
3. 가독성 저하: 코드가 길어질수록 "어디부터 어디까지가 합계를 구하는 부분인지" 한눈에 파악하기 어렵다.

**해결책: 함수**

**함수**는 이 복잡한 과정을 블랙박스 안에 숨기는 도구다. 

우리는 복잡한 계산 과정(`for`, `i`, `+`)는 상자 안에 넣어두고, 겉에서는 **배열을 줄테니, 합계를 다오**라고 요청만 하면 된다.

코드는 이렇게 바뀐다. 

```c
/* (좋은 흐름) 함수 호출 */
sum_a = sum_array(a, 5);
sum_b = sum_array(b, 5);
```

이제 합계 계산 로직은 단 한 곳(`sum_array`)에만 존재한다.
- 고칠 일이 생겨도 한 곳만 고치면 되고,
- 이름(`sum_array`)만 봐도 무엇을 하는 코드인지 명확하다.

**`main`함수의 역할 변화: 실무자에서 관리자로**

함수를 쓰기 시작하면 `main` 함수의 역할이 완전히 달라진다.

- 지금까지의 `main` (실무자): 직접 덧셈하고, 반복문 돌리고, 결과 저장까지 혼자 다 했다.
- 앞으로의 `main` (관리자): `sum_array` 같은 함수에게 "일(데이터)를 던져주고, 결과만 받아서" 전체 흐름을 지휘한다.

즉, 함수는 중복을 없애고 실수를 줄일 뿐만 아니라, 프로그래머가 '큰 그림'을 보게 해주는 가장 강력한 도구다. 

그럼 이제, 이 편리한 `sum_array`라는 도구를 직접 정의해서 만들어보자. 

## 9.2 함수란 무엇인가

함수를 가장 간단히 말하면 "작업 하나를 수행하는 작은 기계"다.

우리가 일상에서 보는 자판기나 계산기 같은 기계를 생각해 보자. 기계에는 보통 세 가지 요소가 있다.

- 넣는 것 (입력): 동전이나 재료
- 내부 동작 (처리): 기계 안에서 지지고 볶는 일
- 나오는 것 (결과): 음료수나 결과물

C언어의 함수도 이 구조와 똑같다.

프로그래밍에서는 다음과 같은 용어로 부른다.

- 넣는 것 (매개변수, Parameter): 함수가 일을 하기 위해서 필요한 재료.
- 내부 동작 (함수 본문, Body): `{ }` 중괄호 안에서 실제로 수행되는 코드.
- 나오는 것 (반환값, Return Value): 일이 끝나고 `return`문으로 돌려주는 최종 결과.

그리고 중요한 사실 하나.

`main`도 이름 뒤에 `( )`가 붙은 함수다.

지금까지 무심코 썼던 `main`을 '기계 모델'로 다시 뜯어보면 이렇다. 

```c
int main()
{
    /* ... 코드들 ... */
    return 0;
}
```

- 반환 타입 (`int`): 이 기계는 일이 끝나면 정수(`int`)를 뱉어낸다.
- 매개변수 (` `): 이 기계는 작동할 때 아무 재료도 필요 없다.
- 반환값 (`return 0`): 운영체제에게 `0`(성공)이라는 결과를 돌려주고 끝낸다.

우리는 이미 함수를 만들고 쓰고 있었다. 단지 지금까지는 `main`이라는 '사장님 함수' 하나만 썼을 뿐이다.

다음으로, `main`이 혼자 다 하던 일을 쪼개서, 직원 함수들을 직접 만들어 볼 차례다. 

## 9.3 함수의 기본 모양: 정의(Definition)

가장 작은 예제로 시작해 보자. 

예제: 두 수를 더하는 함수
```c
/*
 * add 함수는 두 정수를 더한다.
 *
 * 매개변수:
 *   a: 더할 정수
 *   b: 더할 또다른 정수
 *
 * 반환값: a + b
 */
int add(int a, int b)
{
    int r;

    r = a + b;
    return r;
}
```
코드를 해부해 보면 다음과 같다. 
1. 반환 타입 (`int`): 이 기계는 최종적으로 정수(`int`) 하나를 뱉어낸다는 약속
2. 함수 이름 (`add`): 우리가 붙인 이름. 이 이름으로 함수를 불러다 쓴다.
3. 매개변수 (`int a, int b`): "이 작업을 하려면 정수 두 개가 필요하다"는 입력 조건.
4. 함수 본문 (`{ ... }`): 실제로 수행할 작업 내용.
5. 반환 (`return r;`): 함수를 즉시 종료하고, 계산된 값 `r`을 호출한 곳으로 돌려준다.

## 9.4 함수는 어떻게 사용될까: 호출(Call)

함수 정의는 **기계를 설계하고 조립해두는 것**이고, 함수 호출은 **그 기계의 버튼을 눌러 실제로 작동시키는 것**이다. 

예제: add를 호출해서 결과 받기
```c
int main()
{
    int x;

    /* 함수 호출: 3과 5를 던져주고 결과를 받는다 */
    x = add(3, 5);

    /* 이제 x에는 8이 들어있다 */
    return 0;
}
```

여기서 가장 중요한 점은 `add(3, 5)`가 단순한 명령어 한 줄이 아니라는 것이다. `add(3, 5)`는 계산하면 값 하나로 변하는 식(Expression)이다. 

6장에서 `a > b`도 계산하면 `0` 또는 `1`로 변하는 식이라고 배웠던 것을 기억하는가? 함수 호출도 똑같다. 
컴퓨터 안에서 다음과 같은 과정이 일어나서 `add(3, 5)`가 값으로 변한다. 

1. `add(3, 5)`를 실행하기 위해 `3`과 `5`를 들고 `add` 함수 본문으로 이동한다.
2. 계산 결과(반환값)인 `8`을 들고 돌아온다.
3. 원래 자리에 있던 `add(3, 5)`는 사라지고, 그 자리를 **`8`**이 대체한다.

### 9.4.1 호출식의 우선순위는?

함수 호출은 값을 만들어내는 식이기 때문에, 다른 연산자와 섞어 쓸 수도 있다.

```c
int result;
result = 2 * add(3, 5) + 10;
```

이 코드는 어떻게 계산될까?

1. `2 * 3`을 먼저 해서 `add(6, 5)`가 될까? (X)
2. `add(3, 5)`가 먼저 실행될까? (O)

정답은 **함수 호출이 덧셈, 곱셈보다 먼저**다. 수학에서 괄호 `( )`가 가장 먼저 계산되는 것처럼, C언어에서도 함수 호출 연산자 `( )`의 우선순위가 산술 연산자 (`*`, `+`)보다 높다.

컴퓨터가 이 식을 처리하는 순서는 다음과 같다. 

1. 함수 호출: `add(3, 5)`를 가장 먼저 실행한다. (결과: `8`)
2. 곱셈: `2 * 8`을 계산한다. (결과: `16`)
3. 덧셈: `16 + 10`을 계산한다. (결과: `26`)
4. 대입: 변수 `result`에 `26`이 저장된다.

**핵심 원칙**
식 안에 함수가 섞여 있다면, "함수라는 기계가 다 돌아가서 숫자로 변한 뒤에야" 더하기나 곱하기를 할 수 있다. 

## 9.5 `return`: 함수의 종료와 결과 전달

함수에서 `return`은 두 가지 일을 동시에 한다.

1. **함수를 즉시 끝낸다** (종료)
2. **값을 호출한 쪽으로 돌려준다** (반환)

### 9.5.1 `return`은 "즉시 탈출"이다

`return`문을 만나는 순간, 뒤에 코드가 백만 줄이 있어도 함수는 그 자리에서 셔터를 내리고 종료한다.

```c
/*
 * 절대값을 구하는 함수
 *
 * 매개변수
 * x: 절대값을 구할 값
 *
 * 반환값: x의 절대값
 */
int abs_int(int x)
{
    if (x < 0) {
        return -x;    /* 여기서 함수 종료! */
    }

    return x;         /* x가 양수일 때만 여기까지 온다 */
}
```

- `x`가 음수면 첫 번째 `return -x;`에서 함수가 끝나고 호출한 곳으로 돌아간다.
- 그 아래 줄은 실행되지 않는다.

즉, `return`은 함수 안에서 가장 강력한 "비상 탈출구"다.

### 9.5.2 `return` 값은 식이어도 된다

굳이 변수에 담았다가 `return`할 필요는 없다. 계산식 자체를 써도 된다. 

```c
/*
 * 합을 구하는 함수
 *
 * 매개변수
 * a: 더할 값
 * b: 더할 값
 *
 * 반환값: a와 b의 합계
 */
int add(int a, int b)
{
    return a + b;    /* 계산 먼저 하고, 그 결과를 반환 */
}
```

컴퓨터는 `a + b`를 먼저 계산해서 숫자로 만든 뒤, 그 값을 들고 돌아간다.

### 9.5.3 `return`을 빼먹으면 어떻게 될까? (주의!)

`int`처럼 반환 타입을 약속해 놓고 `return` 없이 끝까지 내려가면 어떻게 될까?

```c
/*
 * 알 수 없는 결과를 내는 함수
 *
 * 매개변수: 없음
 *
 * 반환값: int 타입이라고 했지만 정하지 않았음
 */
int dangerous_func()
{
    int a = 10;
    /* return이 없다! */
}
```

C언어 문법상 "결과 값이 보장되지 않는다(Undefined Behavior)". 
운이 좋으면 0이 나올 수도 있지만, 운이 나쁘면 알 수 없는 값이 튀어나와 프로그램 전체를 망가뜨린다.

규칙: 반환 타입이 있는 함수는 반드시 모든 경우의 수에서 return을 만나야 한다.

## 9.6 매개변수: 함수가 받는 입력값 상자

함수 괄호 안에 있는 `int a, int b` 같은 것들은 함수 안에서만 쓰이는 변수다.

```c
int add(int a, int b)
{
    /* a와 b는 add 안에서만 존재하는 상자 */
    return a + b;
}
```

### 9.6.1 이름은 같지만 다른 상자들

다음 코드를 보자. 많은 초보자가 헷갈려 하는 부분이다. 

```c
int add(int x, int y)
{
    return x + y;
}

int main()
{
    int x = 10;
    int y = 20;
    int r;

    r = add(x, y);

    return 0;
}
```

여기에는 `x`가 두 개 있다.

- `main`이 가지고 있는 `x`
- `add`가 가지고 있는 `x` (매개변수)

이 둘은 **이름만 같을 뿐**, 메모리상에서 완전히 다른 공간에 존재하는 남남이다. 마치 서울에 사는 '김철수'와 부산에 사는 '김철수'가 다른 사람인 것과 같다.

중괄호 `{ }`가 다르면(다른 블록이면) 그 안에서 만든 이름은 서로 다른 공간에 존재한다.
(2장에서 배운 “중괄호 범위” 규칙이 그대로 적용된다.)

### 9.6.2 값은 복사해서 전달된다 (Call by Value)

그렇다면 `main`의 `10`은 어떻게 `add`로 전달될까? 상자(`x`) 자체를 건네주는 것이 아니라, 상자 안에 들어있는 값(`10`)을 종이에 베껴 써서 건네준다.

이것을 **값에 의한 전달(Call by Value)** 라고 한다.

다음 코드로 확인해볼 수 있다.

```c
void try_change(int x)
{
    x = 999; /* 매개변수 x를 바꿔보자 */
}

int main(void)
{
    int x = 10;

    try_change(x);

    /* main의 x는 여전히 10이다 */
    return 0;
}
```

- `main`이 `try_change`를 호출할 때, `x`의 값인 `10`을 복사해서 보냈다.

- `try_change`는 **자기 구역에 있는 복사본 `x`**를 999로 바꿨다.

- 원본인 `main`의 `x`에는 아무런 영향이 없다.

**핵심 정리:** 함수로 `int` 값을 보낼 때는 복사본이 넘어간다. 그래서 함수 안에서 지지고 볶아도, 원본 변수는 절대 변하지 않는다.

### 9.6.3 (실전 팁) "그럼 바깥 변수를 바꾸려면?" 1단계 해법: 반환값 다시 대입하기

"함수는 복사본이라 원본을 못 바꾼다"고 하면, 당장 이런 의문이 든다. *"아니, 게임에서 레벨업을 하면 `level` 변수를 바꿔야 하잖아요. 함수로 그걸 못 하면 어떡해요?"*

더 고급 기술을 배우기 전까지, 바깥 값을 바꾸는 가장 쉬운 1단계 해법은 이것이다.

  **"변경된 값을 `return`으로 돌려받고, 그걸 원래 변수에 다시 대입(덮어쓰기)한다."**

```c
int level_up(int lv)
{
    lv = lv + 1;
    return lv; /* 1. 바뀐 값을 돌려준다 */
}

int main(void)
{
    int my_level = 10;

    /* 2. 돌려받은 값을 다시 my_level에 덮어쓴다 */
    my_level = level_up(my_level); 

    /* 이제 my_level은 11이다 */
    return 0;
}
```

원본 상자 안으로 손을 뻗어서 고치는 게 아니다. 새 값을 받아와서, 원래 상자의 내용을 싹 지우고 새로 채워 넣는(Overwrite) 방식이다.

## 9.7 배열을 함수로 넘기기

배열은 조금 특별하다.

우리가 8장에서 배웠던 것처럼, 배열의 이름(`arr`)은 "배열 전체(값들의 덩어리)"가 아니라 **배열이 시작되는 위치를 가리키는 간판(주소 같은 것)** 에 가깝다.

그래서 배열을 함수로 넘길 때는, 배열을 통째로 복사하는 게 아니라 (너무 무거우니까), "그 배열이 어디 있는지"를 알려주는 정보(위치)만 넘어간다.

이 말은 세 가지 중요한 결과를 만든다.

1. 가볍다 (속도)
배열이 100만 개(`int` 100만 개면 약 4MB)여도, 함수로 넘어가는 것은 딱 하나, "배열의 시작 위치(주소)" 뿐이다.
집을 통째로 옮기는 게 아니라, 집 열쇠만 건네주는 것과 같다. 그래서 아무리 큰 배열이라도 함수 호출 속도는 순식간이다.

2. 강력하다 (위험성)
열쇠를 건네줬으니, 받은 사람이 문을 열고 들어가서 가구를 맘대로 바꿀 수 있다. 함수 안에서 `a[0] = 999;`라고 고치면, 호출한 쪽(`main`)의 진짜 배열 값이 바뀐다.

- 장점: 메모리를 아끼고 데이터를 공유하기 좋다.
- 단점: 함수가 실수로 원본을 망가뜨릴 위험이 있다.

3. 배열 크기를 따로 알려줘야 한다 (필수)
열쇠(시작 위치)만 받으면 함수는 이 집이 몇 평인지(배열이 몇 칸인지) 알 방법이 없다.
함수에서 배열을 쓸 수 있으려면 반드시 "배열의 크기"도 인자로 같이 보내야 한다.

예제를 통해 더 자세히 알아본다.

### 9.7.1 배열 합계 함수 (길이 전달의 중요성)

```c
/*
 * 합을 구하는 함수
 *
 * 매개변수
 * a: 더할 값들의 배열
 * n: 배열 a의 크기
 *
 * 반환값: a에 속한 모든 값의 합계
 */
int sum_array(int a[], int n)
{
    int i;
    int sum;

    sum = 0;

    for (i = 0; i < n; i = i + 1) {
        sum = sum + a[i];
    }

    return sum;
}
```

여기서 핵심은 **배열 `a[]`와 길이 `n`을 반드시 세트로 받는다**는 점이다.

함수 입장에서 `a[]`만 가지고는 배열의 시작 위치만 알 뿐, 어디까지가 배열인지를 알 방법이 전혀 없다.

### 9.7.2 최대값 함수 (배열 스캔)

```c
/*
 * 최대값을 구하는 함수
 *
 * 매개변수
 * a: 정수값들의 배열 (이 중에서 최대값을 찾는다)
 * n: 배열 a의 크기, 반드시 1 이상이어야 한다
 *
 * 반환값: a에 속한 모든 값들 중 최대값
 */
int max_array(int a[], int n)
{
    int i;
    int m;

    /* 전제: n은 1 이상이어야 한다 (빈 배열은 최대값이 없다) */
    m = a[0]; /* 일단 0번이 왕이라고 가정 */

    for (i = 1; i < n; i = i + 1) { /* 1번부터 도전자 등장 */
        if (a[i] > m) {
            m = a[i]; /* 더 센 놈이 나타나면 왕좌 교체 */
        }
    }

    return m;
}
```

- 0번 칸을 기준값으로 잡고
- 1번부터 끝까지 훑으면서
- 더 큰 값을 발견하면 갱신한다

배열 처리에서 가장 기본적인 패턴 중 하나다.

### 9.7.3 값 찾기: 찾으면 멈추기 (Early Return)

7장에서 배운 `break`는 “반복문 탈출”이었다.
그런데 함수에서는 더 강력한 탈출이 있다.

> 찾는 순간 `return`으로 함수 자체를 끝내버릴 수 있다.

```c
/*
 * 최대값을 구하는 함수
 *
 * 매개변수
 * a: 정수값들의 배열 (이 중에서 최대값을 찾는다)
 * n: 배열 a의 크기, 반드시 1 이상이어야 한다
 *
 * 반환값: a에 속한 모든 값들 중 최대값
 */
int find_index(int a[], int n, int target)
{
    int i;

    for (i = 0; i < n; i = i + 1) {
        if (a[i] == target) {
            return i;  /* 찾았다! 즉시 종료하고 위치 반환 */
        }
    }

    return -1;  /* 끝까지 다 봤는데 없다 (보통 -1을 실패 신호로 씀) */
}
```

이 방식은 불필요한 반복을 줄여주므로 효율적이고, 코드가 훨씬 간결해진다.

### 9.7.4 배열을 바꾸는 함수 (Side Effect)

배열은 "주소"가 넘어간다고 했다. 즉, 복사본이 아니라 원본에 접근한다. 따라서 함수 안에서 배열 값을 채우면, 밖에서도 채워진다.

```c
/* 배열 a에 0, 1, 2, ... 순서대로 채워 넣는 함수 */
/*
 * 배열에 0, 1, 2, ... 순서대로 저장하는 함수
 *
 * 매개변수
 * a: 정수값들의 배열 (이 중에서 최대값을 찾는다)
 * n: 배열 a의 크기
 *
 * 반환값: 저장한 개수를 돌려준다 (확인용)
 */
int fill_iota(int a[], int n)
{
    int i;

    for (i = 0; i < n; i = i + 1) {
        a[i] = i; /* 원본 배열이 수정됨 */
    }

    return i;     /* for문에서 반복된 횟수 */
}
```

이 함수는 배열을 `0, 1, 2, ..., n-1`로 채운다.

> \[주의\] 함수는 마법사가 아니다
>
> 만약 `n`을 실제 배열 크기보다 크게 전달하면 어떻게 될까? 함수는 순진하게 `n`번 반복하다가 배열의 끝을 넘어가서 엄한 메모리를 덮어쓴다
>
> 8장에서 배운 대로, 이것은 **미정의 동작(Undefined Behavior)** 이며 프로그램이 꼬일 수 있다. 인덱스가 범위를 넘지 않게 챙기는 건, 전적으로 프로그래머의 책임이다.

## 9.8 함수로 `main`을 정리하기

함수를 쓰면 `main`은 점점 "작업 지시서(Script)"처럼 바뀐다.

- 복잡한 세부 계산은 각 함수에게 맡기고
- `main`은 전체 흐름만 관리한다.

다음은 9.7절의 함수들을 써서 `main`을 정리한 코드다.

```c
#include <stdio.h>

/* 배열 a에 0, 1, 2, ... 순서대로 채워 넣는 함수 */
int fill_iota(int a[], int n)
{
    int i;

    for (i = 0; i < n; i = i + 1) {
        a[i] = i;
    }

    return n;
}

/* 배열에 저장된 모든 값을 다 더한 함수 */
int sum_array(int a[], int n)
{
    int i;
    int sum;

    sum = 0;

    for (i = 0; i < n; i = i + 1) {
        sum = sum + a[i];
    }

    return sum;
}

/* 배열에 저장된 값들 중 최대값을 구하는 함수 */
int max_array(int a[], int n)
{
    int i;
    int m;

    m = a[0];

    for (i = 1; i < n; i = i + 1) {
        if (a[i] > m) {
            m = a[i];
        }
    }

    return m;
}

/* 배열에서 값을 찾아서 인덱스를 반환하는 함수 */
int find_index(int a[], int n, int target)
{
    int i;

    for (i = 0; i < n; i = i + 1) {
        if (a[i] == target) {
            return i;
        }
    }

    return -1;
}

int main()
{
    int a[5];
    int sum;
    int max;
    int idx;

    fill_iota(a, 5);

    sum = sum_array(a, 5);
    max = max_array(a, 5);
    idx = find_index(a, 5, 3);

    /* sum에는 합이 저장되어 있고, max에는 최대값이 저장되어 있고, idx에는 3의 인덱스가 저장되어 있다. */

    return 0;
}
```

이 코드에서 가장 중요한 변화는 이것이다.

- `main`만 읽어도 **배열을 채우고, 합과 최대값을 구하고, 3을 찾는구나**라고 흐름이 한눈에 보인다. 
- `for`문 같은 복잡한 부품은 각 함수 안에 숨겨져 있다.

그런데 코드를 보면 한 가지 의문이 생긴다. `main`을 제일 위에 만들어서 어떤 일을 하려는지 먼저 볼 수는 없을까?


## 9.9 C89에서 중요한 규칙: “미리 알려주기(함수 선언)”

컴파일러는 코드를 위에서 아래로, 한 번만(Single Pass) 읽는다.
그래서 `main`에서 어떤 함수를 호출하려면, 컴파일러는 그 함수가

- 어떤 이름이고
- 입력을 몇 개 받으며
- 무엇을 반환하는지

를 **그 시점까지 알고 있어야 한다.**

방법은 두 가지다.

1. 함수를 `main`보다 위에 정의한다. (작은 프로그램에서 가능)
2. `main` 위에 "이런 함수가 있다"라고 먼저 알려준다. (표준적인 방법)

```c
int sum_array(int a[], int n);
```

이 한 줄을 **함수 선언(Declaration)** 또는 **함수 원형(Prototype)** 이라고 부른다.

### 9.9.1 선언과 정의의 차이

선언은 일종의 목차고, 정의는 본문이다. 선언과 정의의 가장 쉬운 구분법은 **중괄호 `{ }`가 있느냐 없느냐**다. 

- 선언: "이런 함수가 있다" (몸체 없음, 세미콜론으로 끝)
- 정의: "이런 함수가 있고, 이 함수는 이렇게 동작한다" (몸체 `{ }`가 있음)

```c
/* 선언 */
int sum_array(int a[], int n);

/* 정의 */
int sum_array(int a[], int n)
{
    int i;
    int sum;

    sum = 0;
    for (i = 0; i < n; i = i + 1) {
        sum = sum + a[i];
    }
    return sum;
}
```

정의는 선언을 겸한다. 함수를 정의한다는 것은 컴파일러에게 "이 함수는 이름이 뭐고, 재료는 뭘 받는다"는 정보를 다 주는 셈이다. 
그래서 함수를 `main`보다 위에 정의하면, 컴파일러가 이미 읽고 알게 되므로 `main` 위에 굳이 선언을 따로 쓸 필요가 없다. 

### 9.9.2 왜 선언이 좋은가 (프로토타입의 중요성)

함수 원형(선언)을 작성하는 것은 단순한 형식이 아니라, 안전장치를 거는 행위다.

1. 컴파일러의 문법 검사 (Type Checking): 선언이 있으면 컴파일러가 "호출할 때 인자를 제대로 넣었는지" 꼼꼼하게 확인할 수 있다.

```c
/* 선언: 인자 2개를 받기로 약속함 */
int sum_array(int a[], int n);

/* ... */

/* 실수: 인자 3개를 넣어버림 */
sum = sum_array(a, 5, 123);
```

선언이 있으면 컴파일러는 즉시 약속된 인자 개수(2개)와 다르다는 에러를 띄워서 실수를 막아준다.

2. 미정의 동작 (Undefined Behavior) 방지: 만약 선언 없이 함수를 호출했는데 인자의 개수나 타입이 맞지 않다면 어떻게 될까?
C 표준에서는 이를 미정의 동작으로 규정한다. 운 좋게 실행되는 것처럼 보여도, 나중에 데이터가 깨지거나 프로그램이 갑자기 종료될 수 있는 시한폭탄이 된다. 선언은 이를 원천 차단합니다.

\[주의\] C89의 자동 선언: C89 표준에는 "선언 없이 함수를 호출하면, 반환값을 무조건 `int`로 가정하고 넘어가는" 옛날 규칙이 있었다.
하지만 이 방식은:
- 반환값이 `int`가 아닌 경우 잘못된 값을 가져온다.
- 인자 타입 검사를 하지 않아 치명적인 버그를 만든다.

따라서 우리는 함수는 반드시 사용하기 전에 선언한다는 원칙을 절대적으로 지켜야 한다.

함수 자동 선언 규칙은 C99부터는 표준에서 삭제되었고, C23에서는 완전 금지되어 반드시 에러가 발생하게 되었다.

### 9.9.3 입력이 없는 함수는 `(void)`로 선언하자

C89에서는 함수를 선언할 때 괄호 안을 비워두는 것은 입력 정보를 모른다는 의미다. 
- `int f();`: 입력이 무엇인지 모른다 (몇 개가 들어오든 막지 않는다)
- `int f(void);`: 입력이 없다 (인자를 넣으면 에러 발생)

따라서 매개변수가 없는 함수를 선언할 때 `void`를 명시해야 안전하다. 

참고로, `int f();`가 입력 정보를 모른다는 것을 의미한다는 규칙은 C99부터 폐기 예정으로 분류되었고, C23부터 완전 폐기되어 `int f();`도 입력이 없음을 의미하게 되었다. 


## 9.11 초보자가 자주 하는 실수
함수를 처음 배울 때 누구나 한 번쯤 겪는 "함정"들이 있다. 실수들만 피해도 코딩 실력은 한 단계 올라간다.

### 9.11.1 함수 정의에 세미콜론을 붙이는 실수
가장 흔한 문법 실수다. 함수 선언은 "이런 게 있어"라고 끝내는 것이라 세미콜론이 필수지만, 함수 정의는 뒤에 몸체(`{}`)가 오기 때문에 세미콜론을 붙이면 안된다.

```c
/* 선언: OK */
int add(int a, int b);

/* 정의: 실수! 여기서 ;를 찍어버림 */
int add(int a, int b);
{
    return a + b;
}
```

\[무슨 일이 생기나?\] 컴파일러는 `;`를 보고 "아, 함수 선언이 끝났구나"라고 생각한다. 
그리고 그 뒤에 나오는 `{ ... }`를 함수와 상관없는 "뜬금없는 블록"으로 인식해 엉뚱한 에러를 쏟아낸다. 
\(예: `error: expected identifier or '(' before '{' token)`\)

### 9.11.2 반환값을 버리는 실수
함수 호출은 `3 + 5` 처럼 계산 후 값이 남는 식이다. 그런데 초보자는 함수를 "일 시키는 문장"으로만 생각해서, 열심히 계산한 결과를 허공에 날려버리곤 한다.

```c
/* 나쁜 예 */
add(3, 5);  /* 계산은 했지만, 결과(8)를 아무도 받지 않아 사라짐 */

/* 좋은 예 */
int sum = add(3, 5);             /* 결과를 변수에 담거나 */
int sum2 = add(1, add(3, 5));    /* 다른 함수의 인자로 바로 사용 */
```

### 9.11.3 배열 길이를 넘기지 않는 실수
파이썬이나 자바 같은 다른 프로그래밍 언어와 달리, C언어의 배열은 자기 크기(길이)를 모른다. 
함수에 배열을 넘길 때 배열 이름(주소)만 덜렁 넘기면, 함수는 이 배열이 5칸인지 100칸인지 알 방법이 없다.

```c
/* 매개변수에서 배열의 크기를 정해보려고 해도 C언어에서는 무시된다. */
int f_take_array_name_only(int arr[5])
{
    return 0;
}

int main()
{
    int small_arr[1];

    int result = f_take_array_name_only(small_arr);     /* 정상적으로 컴파일 되지만 배열 크기 정보가 전달되지 않았다 */

    return 0;
}
```

따라서 배열을 받는 함수는 반드시 배열의 길이도 함께 받아야 한다.

```c
int f_take_array(int arr[], int n)
{
    return 0;
}

int main()
{
    int small_arr[1];

    int result = f_take_array(small_arr, 1);            /* 배열 크기 정보가 전달되었다 */

    return 0;
}
```

### 9.11.4 다른 함수의 변수를 바꾸기를 기대하는 실수
C언어에서 함수로 정수값(`int`)를 넘길 때는 복사본을 넘긴다.

```c
int try_change(int x) {
    x = 999; /* 복사된 x를 바꿈 (원본에는 영향 없음) */

    return 0;
}

int main(void) {
    int val = 10;
    try_change(val);

    /* val의 값은 여전히 10! */
}
```

\[비유\] 친구에게 숙제 노트를 빌려줬는데, 친구가 그 노트를 복사해서 가져갔다고 하자. 친구가 복사본에 낙서를 한다고 해서, 내 원본 노트에 낙서가 생길까? 
아니다. 함수 호출도 이와 똑같다.
