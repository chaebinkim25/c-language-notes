# 15. 전처리기와 여러 파일: 큰 프로그램을 “조립”하는 법

혼자서 만드는 100줄 내외의 연습용 프로그램은 `main.c` 파일 하나로도 충분하다. 
하지만 우리가 매일 사용하는 브라우저, 게임, 운영체제는 수천만 줄의 코드로 이루어져 있다. 
모든 코드가 하나의 소스 파일 안에 있다면 어떨까? 

코드가 길어지면 '이 함수가 어디에 정의되어 있지?' 의문에 답을 찾는 시간이 급격히 늘어난다.
어느 순간부터는 코딩이 아니라 '거대한 텍스트와의 씨름'을 하게 된다.

그래서 소스 파일을 여러 개로 나누게 된다. 

소스 파일이 많아졌을 때도 파일들을 관리할 수 있게 도와주는 도구가 전처리기(Preprocessor)다. 
전처리기는 컴파일러가 본격적으로 기계어를 만들기 전, 소스 파일들에 일관된 규칙으로 텍스트 처리를 하는 '사전 준비 작업'을 담당한다.

중요한 점은 전처리기가 코드의 논리를 분석하는 똑똑한 AI가 아니라는 것이다. 전처리기는 그저 시키는 대로 글자를 바꾸고 파일을 복사하는 단순하고 정직한 비서에 가깝다. 
비서의 특징을 잘 이해해야 큰 프로그램을 조립할 때 발생하는 황당한 에러들을 잡아낼 수 있다.

## 15.0 목표

이 장을 끝내면 '한 파일짜리 연습 코드'를 짜는 단순한 코딩을 넘어, 여러 파일로 구성된 작은 프로젝트를 설계하고 빌드하는 설계를 할 수 있게 된다. 
구체적으로는 다음 능력을 갖추게 된다.

* **파일 분할의 이유 이해**: 코드가 길어질수록 왜 나누기가 필수가 되는지 납득한다. 
* **헤더(.h)와 소스(.c)의 역할 분담**: 무엇을 제공하는가(헤더: 약속)과 어떻게 할 것인가(소스: 구현)을 명확히 구분해서 작성할 수 있다.
* **선언(Declaration) vs 정의(Definition) 구분**: 컴파일러 단계에서 필요한 정보와 링크 단계에서 필요한 정보의 차이를 이해한다.
  그 결과 흔한 링크 에러를 스스로 해결할 수 있다.
* **전처리기의 실체 파악**: `#include`가 스마트한 가져오기가 아니라, 전처리 단계에서 그대로 붙여넣는 작업임을 코드로 증명할 수 있다.
* **매크로 지뢰 피하기**: 편리하지만 위험한 `#define` 매크로의 대표적인 함정(우선순위, 중복 평가)을 파악하고, 안전한 형태로 쓸 수 있다.

> [!TIP]
> **빌드 과정 연결하기**
>
> 2장에서 맛보기로 보았던 '전처리, 컴파일, 링크'라는 흐름이 드디어 하나의 퍼즐로 맞춰진다.
> 전처리기 단계에서 코드가 어떻게 펼쳐지고, 컴파일러가 각 파일을 어떻게 부품으로 만들며, 링커가 이름을 어떻게 연결하는지 확인해 보자.

## 15.1 큰 프로그램은 ‘한 번에’가 아니라 ‘조립’한다

지금까지 우리가 짠 코드는 한 권의 단편 소설 같았다. 
`main.c`라는 종이 한 장에 모든 내용을 다 적을 수 있었다. 
소설을 계속 이어서 써내려가다보면 다음과 같은 상황에 맞닥뜨리곤 한다. 

* 함수가 50개를 넘어간다.
* 복잡한 `struct` 설계도가 수십 페이지다.
* 로그인 기능, 데이터베이스 기능 등 '재사용'하고 싶은 부품들이 생긴다.

그럴 때 파일을 나누려고 시도하면 컴파일러는 야속하게도 이렇게 말한다.
**"A라는 구조체? B라는 함수? 난 그런 거 본 적 없는데?"**
컴파일러는 왜 다른 파일에 있는 구조체나 함수를 모른다고 할까?

### 15.1.1 C 컴파일러는 한 번에 한 단위씩 처리한다

C 컴파일러는 기본적으로 하나의 단위로 일한다. 

1.  **부품 제작 (Compile):** 컴파일러는 `A.c`를 읽을 때 `B.c`의 내용을 자동으로 찾아보지 않는다.
    오직 주어진 소스만 보고 중간 부품인 오브젝트 파일(`.o` 또는 `.obj`)을 만든다.

2.  **최종 조립 (Link):** 공장의 조립 라인인 **링커(Linker)** 가 흩어져 있던 오브젝트 파일들을 모아 하나의 실행 파일로 조립한다. 

> [!NOTE]
> 번역 단위(translation unit)
> 
> 컴파일러가 실제로 컴파일하는 단위는 보통 소스 파일 하나에서 시작한다.
> 그 소스 파일 안에서 다른 헤더 파일의 붙여넣기를 명령한 경우 붙여넣기가 끝난 결과 전체가 번역 단위가 된다.

### 15.1.2 왜 이렇게 번거롭게 나눌까?

처음에는 귀찮아 보이지만, 규모가 커지면 이 방식은 축복이 된다.

* **수정의 경제학:** 1,000개의 파일 중 하나만 고쳤다면, 그 파일 하나만 다시 컴파일하면 된다. 
* **협업의 기초:** 나는 '엔진' 부품을 만들고, 동료는 '그래픽' 부품을 각자의 파일에서 동시에 만들 수 있다.

그런데 컴파일러가 파일 하나만 본다면, 다른 파일에 있는 함수를 쓰고 싶을 때 어떻게 그 존재를 알려줘야 할까?
"따로 만들어 하나로 합치는" 마법을 가능하게 해주는 삼총사가 바로 이번 장의 주인공들이다.

1.  **선언과 정의:** "이런 부품이 올 거야"라는 약속과 "진짜 부품"의 구분
2.  **헤더(.h):** 부품들을 연결할 때 주고받는 표준 규격서
3.  **전처리기:** 부품을 조립하기 전, 필요한 설계도를 복사해오는 작업 반장

## 15.2 헤더 파일(.h)와 소스 파일(.c): "설계도"와 "공장"

큰 프로그램을 조립하기 위한 가장 기본적인 규칙은 **'설계도'**와 **'공장'**을 분리하는 것이다.

- **헤더 파일 (.h)**: "이런 부품이 있고, 이렇게 사용한다"고 약속(Interface)하는 설계도
- **소스 파일 (.c)**: 부품의 내부 로직을 실제로 구현(Implementation)하는 공장

### 15.2.1 헤더에 넣는 것: "우리 사이의 약속"

여러 `.c` 파일이 함께 공유해야 하는 공통 규격은 헤더에 모아둔다.

- **구조체 정의**: 데이터의 모양(타입 설계도)
- **함수 선언**: 함수의 이름, 매개변수, 반환 타입
- **전역 변수 선언**: 프로그램 전체에서 공유할 변수의 이름과 타입
- **상수 및 매크로**: C에서 제공하는 자동 찾아 바꾸기 기능

헤더 파일은 단독으로 컴파일되지 않는다. 항상 어떤 소스 파일에 붙여넣기 되는 형식으로만 컴파일된다. 

### 15.2.2 소스에 넣는 것: "나만의 비밀 공장"

함수가 어떻게 돌아가는지 상세한 로직은 소스 파일에 숨긴다.

* **함수 정의**: 실제 동작을 수행하는 몸체(`{ ... }`)
* **전역 변수의 진짜 정의**: 실제 메모리를 차지하는 변수 생성
* **파일 전용 함수/변수**: 해당 파일 안에서만 쓸 보조 수단들

### 15.2.3 분리된 모습 한눈에 보기

간단한 '덧셈' 기능을 분리한다면 다음과 같은 모양이 된다.

**`calc.h` (설계도)**

```c
/* 누구나 이 헤더만 읽으면 calc의 기능들을 어떻게 쓰는지 알 수 있다. */

/* 함수 선언 */
int add(int a, int b); 
```

**`calc.c` (공장)**
```c
#include "calc.h" /* 자신이 지켜야 할 약속(헤더)를 포함한다. */

/* 함수를 진짜 구현하는 부분 */
int add(int a, int b)
{   
    return a + b; 
}
```

> [!WARNING]
> **헤더에는 웬만하면 정의를 넣지 말자!**
> 
> 앞서 배웠듯 `#include`는 단순한 복사다. 헤더 파일에 함수나 변수의 정의를 넣어버리면, 그 헤더를 가져다 쓰는 모든 소스 파일마다 똑같은 '공장'이 중복해서 세워진다.
> 결국 링커는 "똑같은 이름의 함수/변수가 여기저기서 튀어나오네? 누굴 써야 해?"라며 비명을 지르게 된다(중복 정의 에러). 헤더에는 오직 설계도(선언)만 남겨두자.
>
> (고급 예외) 정말 필요한 경우에만, `static`으로 파일마다 따로 생기게 만들 때 헤더에 정의를 두는 패턴도 있다. 지금은 기본 규칙(헤더에는 선언만)을 우선으로 한다. 

### 15.2.4 공장 조립하기 (빌드 명령)

설계도(`.h`)와 공장(`.c`)을 모두 준비했다면, 이제 컴파일러에게 모든 공장 파일들을 한꺼번에 넘겨서 하나의 실행 파일로 조립할 차례다.

**Linux / Mac (GCC) 두줄 버전**
```bash
# main.c 공장 파일을 컴파일한다.
gcc -c main.c
# calc.c 공장 파일을 컴파일한다.
gcc -c calc.c
# 컴파일 된 파일들을 합쳐서 실행 파일을 만들고, 이름은(-o) app으로 지정한다.
gcc main.o calc.o -o app
```

**Linux / Mac (GCC) 한줄 버전**
```bash
# 공장 파일들을 나열하고, 결과물(-o) 이름을 app으로 지정한다.
gcc main.c calc.c -o app
```

**Windows (MSVC / cl.exe) 두줄 버전**
```bat
# main.c 공장 파일을 컴파일한다.
cl /c main.c
# calc.c 공장 파일을 컴파일한다.
cl /c calc.c
# 컴파일 된 파일들을 합쳐서 실행 파일을 만들고, 이름은(/Fe:) app으로 지정한다.
cl main.obj calc.obj /Fe:app.exe
```

**Windows (MSVC / cl.exe) 한줄 버전**
```bat
# /Fe: 옵션으로 결과 파일 이름을 지정한다.
cl main.c calc.c /Fe:app.exe
```

> [!TIP]
> **"조립(Link)"의 의미**
> 만약 `main.c`만 컴파일하고 `calc.c`를 빼먹는다면, 컴파일러는 "설계도(calc.h)를 보고 add 함수를 쓰려고 했는데, 정작 add를 만드는 공장(calc.c)이 어디 있는지 모르겠어!"라며 에러를 낸다.
> 우리가 컴파일 명령에 모든 `.c` 파일을 적어주는 이유가 바로 이 '공장들을 서로 연결'하기 위해서다.

## 15.3 전처리기 `#include`는 "붙여넣기"다

우리가 흔히 `#include`를 스마트한 모듈 불러오기처럼 느끼지만, 실제 동작 원리는 훨씬 단순하다.

`#include`는 코드를 분석하지는 않고, 지시받은 파일을 통째로 긁어와서 그 자리에 붙여넣는다.

그렇기 때문에 헤더 파일에 실행 코드를 넣으면 붙여넣기를 너무 많이 해서 컴파일 속도가 느려지게 된다.

### 15.3.1 눈으로 보는 `#include`의 정체

예를 들어 이런 코드가 있다고 가정해 보자.

**calc.h**
```c
int add(int a, int b);
```

**main.c**
```c
#include "calc.h"

int main(void) {
    return add(3, 5);
}
```

전처리기가 `#include` 문을 처리하고 나면, 컴파일러가 실제로 읽게 되는 코드는 다음과 같은 모습이 된다.

**`main.c` (전처리 후 펼쳐진 모습)**
```c
/* --- calc.h의 내용이 그대로 복사되어 들어왔다 --- */
int add(int a, int b);
/* --------------------------------------------- */

int main(void) {
    return add(3, 5);
}
```

결국 `stdlib.h`를 포함하는 것도 마법이 아니다. `malloc`과 `free` 같은 수많은 함수의 이름표(선언)들이 담긴 거대한 텍스트 파일을 내 코드 상단에 붙여넣는 작업일 뿐이다.

> [!TIP]
> 
> **직접 확인해보고 싶다면?**
> 
> 윈도우 사용자라면 **Developer PowerShell** 에서 다음 명령어를 입력해서 확인할 수 있다.
> 
> ```bat 
> cl /P main.c
> ````
> 
> 명령을 실행하면 화면에 아무것도 나오지 않지만, 폴더 안에 `main.i`라는 파일이 새로 생긴다.
>
> Linux / Mac사용자라면 **Terminal** 에서 다음 명령어를 입력해서 폴더 안에 `main.i`를 파일을 만들고 붙여넣기된 결과를 확인할 수 있다.
>
> ```bash
> gcc -E main.c -o main.i
> ```
>
> VS Code로 열어보면 수만 줄의 `stdlib.h` 내용이 내 코드 위에 실제로 붙여넣기 되어 있는 장관을 볼 수 있다.

### 15.3.2 `<...>` vs `"..."`: 어디서 찾을까?

컴파일러에게 "어느 폴더에서 파일을 찾아야 해?"라고 알려주는 방식이다.

* **`#include <stdlib.h>`**: "C언어 표준 라이브러리 설치 폴더에서 stdlib.h 파일을 찾아라."
* **`#include "my_data.h"`**: "(많은 컴파일러에서) 지금 내가 코드를 쓰고 있는 이 폴더에서 먼저 찾아라."

| 기호 | 찾는 위치 | 주요 대상 |
| :--- | :--- | :--- |
| `< >` | 시스템 경로 (표준 폴더) | `stdio.h`, `stdlib.h` 등 표준 헤더 |
| `" "` | 사용자 경로 (내 프로젝트 폴더) | 내가 직접 만든 `.h` 파일 |

> [!NOTE]
> **헤더 파일은 "주인공"이 아니다.**
> 헤더 파일(`.h`)은 혼자서 컴파일되어 실행 파일이 될 수 없다.
> 헤더는 오직 소스 파일(`.c`)에 입양(복사)되어 그 파일의 일부로서 존재할 때만 의미가 있다.
> 그래서 우리는 컴파일러에게 `.c` 파일만 넘겨주고, `.h` 파일은 그 과정에서 자동으로 불려 들어가게 설계한다.


## 15.4 선언(Declaration) vs 정의(Definition)

우리는 9장에서 '미리 알려주기(함수 선언)'이 왜 필요한지를 봤다. 
컴파일러가 함수를 호출하는 코드를 만났을 때, 그 함수의 이름과 입출력 타입을 미리 알고 있어야 타입 오류를 잡아낼 수 있기 때문이었다.

파일이 여러 개일 때 이 원칙은 더 엄격해진다. 컴파일러는 현재 읽고 있는 파일 밖의 상황을 전혀 모르기 때문이다. 
다른 파일에 있는 함수나 변수를 쓰려면, 현재 파일에서 "이런 게 존재한다"라고 반드시 알려줘야 한다.

여기서 가장 중요한 철칙이 등장한다.
> **"밖에서 공유되는 이름은 정의가 프로그램 전체에서 한 번만(Single Definition Rule), 선언은 내용만 같다면 여러 번 해도 된다."**

### 15.4.1 함수의 정의와 선언

- **함수 정의:** 함수의 '몸체'를 만드는 작업이다. 실제 기계어 코드가 생성되어 실행 파일의 코드 영역에 자리를 잡는다.
```c
/* 정의: 설계도대로 실제 건물을 짓는 것 (메모리 차지 O) */
int add(int a, int b)
{
    return a + b;
} 
```

- **함수 선언:** 함수의 타입 정보가 들어있는 '이름표'만 붙이는 작업이다. 컴파일러에게 "나중에 링커가 진짜 몸체를 찾아줄 테니 일단 믿고 넘어가 줘"라고 부탁하는 것이다. 
```c
/* 선언: "이런 건물이 있을 거야"라고 지도에 표시하는 것 (메모리 차지 X) */
int add(int a, int b); 
```

### 15.4.2 전역 변수의 정의와 선언

전역 변수는 함수보다 선언과 정의의 구분이 조금 더 까다롭다. 함수는 `{ }` 몸체의 유무로 명확히 갈리지만, 변수는 문법이 비슷하기 때문이다. 

- **전역 변수 정의:** 변수를 위해 실제 메모리 공간을 확보하는 단계다. 초기값을 주면 명확한 '정의'가 된다.
```c
/* 정의: "메모리 한 칸을 차지하고 0을 채워 넣어라" */
int program_state = 0; 
```

- **전역 변수 잠정 정의 (상황에 따라 선언처럼도 볼 수 있는 정의):** 초기값이 없이 타입과 이름만 적으면 "이런 변수가 어딘가에 있을 수도 있다"고 알려준다.

```c
/* 잠정 정의: "이런 이름의 변수가 어딘가에 정의되어 있을 수도 있어" */
int program_state; 
```

> [!CAUTION]
> **컴파일러의 잠정 정의 (Tentative Definition)과 그 한계**
>
> C 언어는 `int program_state;`처럼 초기값 없이 이름만 적힌 전역 변수를 보면 잠정적인 정의로 받아둔다.
> 그러다가 번역하는 프로그램 소스의 끝까지 읽었는데 진짜 정의가 안 나오면, 그제야 스스로 메모리를 할당해버린다.
> 
> 문제는 컴파일러가 `A.c`를 읽을 때 `B.c`를 보지 못한다는 것이다. 
> 만약 여러 소스 파일에서 똑같이 `int program_state;`라고 적어두면, 오브젝트 파일들이 각자 "내가 정의해줄게!"라고 나서게 된다.
> 결국 나중에 링커가 이 파일들을 하나로 합칠 때, "똑같은 이름의 정의가 왜 이렇게 많아?"라며 에러를 내뱉게 된다.
> 
> 그래서 프로젝트를 설계할 때 다음 규칙을 지킨다.
> 1. **소스 파일(.c)** : 단 한 곳에서만 초기값을 주어 확실하게 정의한다. 
> 2. **헤더 파일(.h)** : 다른 파일들이 가져다 쓸 수 있도록 **선언**만 한다. (`extern` 키워드의 핵심 용도)

전역 변수를 진짜 선언하기 위해서는 `extern`이라는 키워드를 붙여줘야 한다.

- **전역 변수 선언(`extern`:** 전역 변수의 '이름표'만 붙이는 작업이다. 컴파일러에게 "나중에 링커가 진짜 몸체를 찾아줄테니 믿고 따로 메모리를 할당받지 마"라고 당부하는 것이다.
```c
/* 선언: "이런 이름의 변수가 어딘가에 정의되어 있어" */
extern int program_state; 
```

`extern` 키워드를 썼을 때도 초기화 식이 있으면 전역 변수가 정의 된다. 

- **전역 변수 정의**
```c
/* 정의: "메모리 한 칸을 차지하고 0을 채워 넣어라" */
extern int program_state = 0; 
```

### 15.4.3 구조체: "타입 설계도"의 정의와 선언

구조체 자체는 함수나 변수와 달리 실제 메모리를 차지하는 '실체'가 아니라, 데이터를 담는 **'틀'**이다.

- **구조체 정의:** 구조체가 어떤 멤버들로 구성되는지 구체적인 설계도를 그리는 것이다.

```c
/* 정의: "struct Point라는 타입은 이렇게 생겼어" */
struct Point {
    int x;
    int y;
};
```

- **구조체 선언 (전방 선언)** 구체적인 멤버는 나중에 알려주기로 하고, 일단 이런 이름의 태그가 있다는 것만 알린다. 
```c
/* 선언: struct Point라는 구조체 타입을 어딘가에서 정의했어. */
struct Point;
```

구조체 설계도(정의)가 없으면 컴파일러는 `p.x` 같이 멤버에 접근할 때 해당 데이터가 메모리의 어디에 위치하는지 계산할 수 없다. 
`sizeof(struct Point)` 같이 크기 정보도 쓸 수 없다. 
구조체의 포인터만 쓰지 않는 한 구조체 정의는 컴파일 할 단위 안에서 반드시 정의되어 있어야 한다.

전방 선언만 있으면 포인터 선언은 가능하다:
```c
struct Point *p; /* 포인터는 크기가 정해져 있어서 가능 */
```

하지만 멤버 접근이나 실제 변수 선언은 불가능하다(멤버를 모르니 크기를 결정할 수 없음):
```c
struct Point v;  /* 정의가 없으면 불가능 */
```

### 15.4.4 컴파일 에러 vs 링크 에러: "범인은 누구인가?"

코드를 빌드하다 에러가 발생하면, 가장 먼저 확인해야 할 것은 누가 나에게 화를 내고 있는가다. 에러의 종류에 따라 우리가 확인해야 할 곳이 완전히 다르다.

1. 컴파일 에러: "나는 그게 뭔지 모른다" (선언의 부재)
- **담당자**: 컴파일러
- **상황**: 소스 코드를 읽다가 듣도 보도 못한 이름(함수나 변수)이 나왔을 때 발생한다.
- **주요 메시지**: `error: 'add' undeclared`, `identifier not found`
- **비유**: 조립 설명서를 읽는데, 갑자기 설명도 없는 듣도 보도 못한 부품 번호가 튀어나온 상황이다.
- **해결법**: 해당 함수/구조체의 선언이 들어있는 헤더 파일(.h)을 `#include` 했는지 확인한다.

2. 링크 에러 (미발견): "약속은 들었는데 실물이 없다" (정의의 부재)
- **담당자**: 링커 (Linker)
- **상황**: 모든 파일의 컴파일은 끝났는데, 막상 조립하려고 보니 선언만 있고 실제 몸체(구현부)가 없을 때 발생한다.
- **주요 메시지**: `LNK2019: unresolved external symbol`, `undefined reference to 'add'`
- **비유**: 조립 설명서에 'A 부품'이 필요하다고 해서 박스를 다 찾았는데, 정작 'A 부품' 실물이 들어있지 않은 상황이다.
- **해결법**: 함수를 정의한 소스 파일(`.c`)을 프로젝트에 포함했는지, 혹은 함수 이름에 오타가 없는지 확인한다.

3. 링크 에러 (중복): "똑같은 실물이 너무 많다" (정의의 중복)
- **담당자**: 링커 (Linker)
- **상황**: 조립하려고 부품들을 모아보니, 똑같은 이름의 부품(정의)이 두 개 이상 존재할 때 발생한다.
- **주요 메시지**: `LNK2005: 'add' already defined`, `multiple definition of 'add'`
- **비유**: 'A 부품'은 하나만 있으면 되는데, 서로 다른 상자에서 똑같은 'A 부품'이 두 개 튀어나와서 어느 것을 써야 할지 모르는 상황이다.
- **해결법**: 헤더 파일에 함수 몸체나 변수 정의를 넣지 않았는지 확인한다 (정의는 소스 파일에 딱 한 번만!).

디버깅 요약표

| 에러 종류 | 범인 | 원인 | 확인해야 할 곳 |
| :--- | :--- | :--- | :--- |
| **컴파일 에러** | 컴파일러 | "이게 대체 뭐야?" (선언 없음) | `#include` 확인 |
| **링크 에러 (Missing)** | 링커 | "실물이 없잖아!" (정의 없음) | `.c` 파일 포함 여부 확인 |
| **링크 에러 (Duplicate)** | 링커 | "왜 실물이 두 개야?" (중복 정의) | 헤더 파일에 몸체(`{}`) 있는지 확인 |

> [!NOTE]
>
> C89에서는 함수 선언 없이 호출하면 컴파일러가 경고만 내고 넘어가는 경우도 있다(자동적 선언).
> 하지만 위험하므로 이 책에서는 “선언이 없으면 에러”라고 생각하고 코딩한다.

## 15.5 `static`과 `extern`: "이름이 어디까지 보이는가"

파일을 나누기 시작하면 새로운 고민이 생긴다. "어떤 건 다른 파일에 공개하고 싶고, 어떤 건 다른 파일 것을 쓰고 싶고, 어떤 건 비공개로 쓰고 싶은데?" 이 가시성을 조절하는 스위치가 바로 `static`과 `extern`이다.

- **`static`**: "이 파일 안에서만 쓰겠다." (**비공개/내수용**)
- **`extern`**: "다른 파일에 있는 것을 쓰겠다." (**공개/수출입**)

### 15.5.1 `static`: 파일 안으로 숨기기

소스 파일(`.c`) 내부에서만 사용하는 보조 함수나 변수에는 `static`을 붙인다.

**contact.c**
```c
/* 전화번호 형식이 맞는지 검사하는 보조 로직 (이 파일 안에서만 필요) */
static int validate_phone(char* number) {
    return 1;
}

void add_contact(char* name, char* phone) {
    if (validate_phone(phone)) { /* ... */ }
}
```

**왜 `static`을 쓸까?**
1. **이름 충돌 방지**: `main.c`에서도 똑같은 이름의 `validate_phone`을 만들어도 서로 간섭하지 않는다. 각자의 파일 안에서만 유효하기 때문이다.
2. **캡슐화**: 외부(`main.c`)에서는 꼭 필요한 기능(`add_contact`)만 보이고, 복잡한 내부 동작은 숨겨져서 코드가 깔끔해진다.
   내부 동작을 완전히 바꿔서 업데이트 하더라도 공개된 기능만 잘 유지하면 다른 파일에서는 변할 것이 없다.

### 15.5.2 `extern`: 다른 파일의 변수 빌려오기

변수는 함수와 달리 선언과 정의의 구분이 모호하다. 
`extern`과 초기화를 하지 않는 조합은 "난 지금 변수를 만드는 게 아니라, 다른 파일에 이미 만들어진 녀석의 이름만 빌려오는 거야"라고 컴파일러에게 확실히 말해주는 도구다.

**counter.h**
```
extern int g_count; /* "어딘가에 g_count라는 int 변수가 있으니 믿고 써라" (선언) */
```

**counter.c**
```c
int g_count = 0;    /* "진짜 메모리를 할당한다" (정의) */
```

**중요한 규칙:**
* `extern` 선언은 메모리를 단 1바이트도 사용하지 않는다. 그저 이름표일 뿐이다.
* 진짜 메모리를 만드는 정의는 반드시 단 하나의 소스 파일(`.c`)에만 존재해야 한다.

> [!NOTE]
> **함수 선언에는 왜 `extern`을 안 붙이나?**
> 
> C 언어에서 함수 선언(프로토타입)은 기본적으로 `extern` 성격을 가진다.
> 그래서 별도로 `static`을 붙이지 않는 한 모든 함수는 "다른 파일에서 가져다 쓸 수 있는 상태"가 된다.
> `extern`을 붙여도 의미는 똑같지만 관습적으로 함수 선언 앞의 `extern`은 생략한다.

**요약**

| 키워드 | 의미 | 주요 용도 | 메모리 할당 |
| :--- | :--- | :--- | :--- |
| **`static`** | 파일 내부 전용 | 내부 보조 함수, 파일 전용 변수 | O (해당 파일 내) |
| **`extern`** | 외부 참조 전용 | 다른 파일의 전역 변수 가져오기 | X (이름만 빌림) |

**정리하자면:**
이제 여러분은 `static`이라는 담장을 세워 내 코드를 보호하고, `extern`이라는 다리를 놓아 필요한 데이터를 공유할 수 있게 되었다.

## 15.6 중복 포함 방지: 인클루드 가드 (Include Guard)

`#include`는 단순한 '복사'라고 배웠다. 정직한 동작 때문에 의도치 않은 문제가 발생한다. 바로 똑같은 설계도가 여러 번 복사되는 중복 포함 문제다.

아무리 조심해도, 프로그램이 커지면 `A.h`가 `B.h`를 포함하고, `main.c`가 `A.h`와 `B.h`를 둘 다 포함하는 상황이 발생하곤 한다. 
결과적으로 `B.h`의 내용이 `main.c`에 두 번 복사되고, 컴파일러는 "구조체가 왜 두 번 정의됐어?"라며 화를 낸다.

그런 상황을 막기 위한 방패가 바로 인클루드 가드다.

### 15.6.1 표준 방식: `#ifndef` 패턴

모든 헤더 파일의 처음과 끝을 아래와 같은 전처리기 지시문으로 감싼다.

**contact.h**
```c
#ifndef CONTACT_H  /* 1. 만약 CONTACT_H라는 '이름표'가 정의되지 않았다면? */
#define CONTACT_H  /* 2. 지금 즉시 CONTACT_H 이름표를 만들고, 아래 내용을 복사해! */

struct Contact {
    char name[20];
    char phone[20];
};

#endif             /* 3. 여기까지가 가드의 끝 */
```

**동작 원리:**
1. 전처리기가 처음 이 헤더를 만났을 때는 `CONTACT_H`가 없으므로 내용을 복사한다.
2. 두 번째로 이 헤더를 만나면? 이미 `CONTACT_H`가 정의되어 있으므로 `#ifndef` 조건이 거짓이 되어 `#endif`까지의 모든 내용을 통째로 무시한다.

### 15.6.2 이름 짓기 관습 (Naming Convention)

가드에 사용하는 이름(`CONTACT_H`)은 프로젝트 전체에서 유일해야 한다. 그래서 보통 다음과 같은 규칙을 쓴다.

- **파일명_H**: `contact.h` → `CONTACT_H`
- **프로젝트명_파일명_H**: `MYPROJECT_CONTACT_H` (더 안전함)

> [!CAUTION]
> **언더바 `_`는 피하라!**
> 
> 이름 앞에 언더바 두 개 `__` 를 붙이거나, 대문자로 시작하는 이름 앞에 언더바 `_`를 붙이는 것은 컴파일러나 표준 라이브러리가 사용하는 영역이다.
> 우리의 이름표와 시스템 이름표가 충돌할 위험이 있으니 평범한 대문자 이름을 권장한다.

### 15.6.3 현대적인 대안: `#pragma once`

최근 대부분의 컴파일러(MSVC, GCC, Clang 등)는 훨씬 간단한 방법을 지원한다. 헤더 제일 앞에 딱 한 줄만 적으면 된다.

**contact.h**
```c
#pragma once

struct Contact {
    char name[20];
    char phone[20];
};
```

- **장점**: 코드가 깔끔하고, 실수로 가드 이름을 중복해서 지을 걱정이 없다.
- **단점**: 아주 오래된 컴파일러에서는 작동하지 않을 수 있다. (표준은 아니지만 사실상 표준처럼 쓰인다.)

> [!TIP]
> **전처리기의 세계 vs C의 세계**
> 
> `#ifndef`나 `#define` 같은 줄은 컴파일러가 코드를 기계어로 바꾸기 전, 전처리기 단계에서 이미 사라진다.
> 컴파일러가 실제로 마주하는 코드는 가드 덕분에 깔끔하게 '한 번만' 나타나는 깨끗한 코드다.


## 15.7 `#define` 매크로: 빠르고 편하지만 함정이 있다

전처리기의 또 다른 핵심 기능은 **매크로(Macro)**다. 
매크로는 특정 단어를 다른 텍스트로 '치환'해주는 강력한 도구이지만, 전처리기가 코드의 의미를 분석하지 않고 단순 복사만 하기 때문에 발생하는 독특한 함정들이 있다.

### 15.7.1 상수 매크로: "이름 붙인 숫자"

```c
#define MAX_NAME 20
```

매크로 상수는 변수가 아니다.
- **메모리를 쓰지 않는다**: 컴파일러가 일을 시작하기 전, 코드 안의 모든 `MAX_NAME`은 숫자 `20`으로 바뀌어 흔적도 없이 사라진다.
- **디버깅의 한계**: 에러가 났을 때 디버거는 `MAX_NAME`이라는 이름을 모를 때가 많다. 그저 숫자 `20`에서 에러가 났다고 알려줄 뿐이다.

> [!TIP]
> **관습**: 매크로는 일반 변수와 확실히 구분하기 위해 모두 대문자로 쓰는 것이 전 세계적인 약속이다.

### 15.7.2 함수형 매크로: "가짜 함수"

함수처럼 호출할 수 있지만, 실제로는 코드를 그 자리에 펼쳐놓는 방식이다. 실행 속도는 미세하게 빠를 수 있지만, '복사해서 붙여넣기'의 특성상 치명적인 지뢰가 숨어있다.

#### **함정 1) 괄호 지옥: 우선순위 꼬임**

매크로 본문에서 인자와 전체 식을 괄호로 감싸지 않으면 연산 순서가 엉망이 된다.

```c
#define SQUARE_BAD(x) x * x
int a = SQUARE_BAD(1 + 2); 
/* 기대: (1+2) * (1+2) = 9 */
/* 실제: 1 + 2 * 1 + 2 = 5 (곱셈이 먼저 실행됨!) */

#define SQUARE_HALF_GOOD(x) (x) * (x)
int b = 100 / SQUARE_HALF_GOOD(5);
/* 기대: 100 / (5 * 5) = 4 */
/* 실제: 100 / (5) * (5) = 100 (나눗셈과 곱셈은 순서대로 실행됨!) */
```

* **해결책**: **"인자도 괄호, 전체도 괄호"**를 공식처럼 사용하세요. `((x) * (x))`

#### **함정 2) 인자의 중복 평가 (부작용)**

매크로는 인자를 본문에 그대로 복사하기 때문에, 인자에 들어간 식이 의도치 않게 여러 번 실행될 수 있다.

```c
#define MAX(a, b) ((a) > (b) ? (a) : (b))
int i = 5, j = 10;
int res = MAX(i++, j++); 
/* 실제 펼쳐진 모습: ((i++) > (j++) ? (i++) : (j++)) */
```

위 코드에서 `j++`는 비교할 때 한 번, 결과값으로 선택될 때 또 한 번 실행되어 총 두 번 실행되게 된다. 결과적으로 미정의 동작 (Undefined Behvaior)를 일으킨다.

> [!WARNING]
> **매크로 인자에는 절대 `i++` 같은 증감 연산자, 함수 호출, 대입 연산을 넣지 말자.** 예상치 못한 결과로 인해 프로그램이 의도와 다르게 동작할 수 있다.

### 15.7.3 `#`, `##` 연산자: "매크로 전용 도구" (맛보기)

이 연산자들은 오직 `#define` 정의 안에서만 특별한 힘을 발휘하는 텍스트 조작 도구다.

- **`#` (문자열화)**: 인자를 쌍따옴표로 감싸서 문자열로 만든다.
- **`##` (토큰 연결)**: 두 단어를 붙여서 하나의 새로운 이름을 만든다.

```c
#define PRINT_VAR(var) printf(#var " = %d\n", var)
#define MAKE_NAME(n) user_##n

int a = 10;
PRINT_VAR(a); /* "a = 10" 출력 */

int MAKE_NAME(1) = 100; /* int user_1 = 100; 과 같음 */
```

주로 코드를 자동으로 생성하는 복잡한 라이브러리에서 쓰인다. 지금은 "이런 게 있다" 정도만 알고 넘어가도 충분하다.

**요약: 매크로 vs 함수**

| 구분 | 매크로 (`#define`) | 함수 (`Function`) |
| :--- | :--- | :--- |
| **처리 시점** | 컴파일 전 (전처리기) | 실행 시간 (Runtime) |
| **작동 원리** | 텍스트 치환 (단순 복사) | 제어 흐름 이동 (호출) |
| **타입 체크** | 안 함 (무엇이든 치환) | 엄격함 |
| **안전성** | 낮음 (함정이 많음) | 높음 |

