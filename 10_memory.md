# 10. 메모리와 주소: 값이 ‘어디에’ 있는가

지금까지 우리는...
9장까지 숨 가쁘게 달려오며 다음 문법들을 익혔다.

- `int`로 값을 만들고 계산하기
- `if`로 갈림길을 만들기
- `for`로 반복 작업 수행하기
- 배열로 여러 값을 한꺼번에 다루기
- 함수로 복잡한 일을 나눠서 처리하기

**초보자가 부딪히는 3가지 의문**

여기까지 오면, 초보자라면 거의 반드시 이런 의문을 갖게 된다.

1. "함수에 `int`를 넘기면 원본이 안 바뀌는데, 배열을 넘기면 왜 원본이 바뀌지?"
2. "다른 변수는 `=`로 대입이 되는데, 배열은 왜 통째로 복사가 안되지?"
3. "도대체 내가 만든 변수들은 컴퓨터 어디에 저장되는 거지?"

이 질문들의 핵심은 하나로 귀결된다. 우리는 값(value)만 봤지, 그 값이 어디에 저장되는지(위치)를 아직 제대로 보지 못했다.

**10장의 목표**
이번 장의 목표는 이미 배운 문법들이 왜 그렇게 동작하는지를 메모리라는 관점에서 시원하게 파헤치는 것이다.

> 이 장의 목표
>
> - 컴퓨터가 값을 저장하는 공간인 **메모리(Memory)**를 이해한다
> - 메모리의 각 칸을 구분하는 번호인 **주소(Address)**의 개념을 잡는다
> - 변수는 단순한 값이 아니라 값이 들어있는 자리 + 그 자리의 이름표임을 이해한다
> - 배열 이름이 왜 배열 전체가 아니라 첫 칸의 위치 정보처럼 행동하는지 밝혀낸다
> - 함수 호출에서 값 전달(Call by Value)와 배열 전달(Call by reference)**가 왜 다르게 동작하는지 한 번에 정리한다
> - C 언어의 가장 큰 산인 (포인터)을 배우기 위한 준비 운동을 마친다

---

## 10.1 컴퓨터는 기억을 어디에 해둘까?

우리는 일상에서 뭔가를 기억할 때 다음과 같은 방법을 쓴다.

- 머릿속에 저장하거나
- 메모장에 적어두거나
- 파일에 저장한다

컴퓨터도 비슷하다. 그리고 프로그램이 실행되는 동안 컴퓨터가 가장 자주 쓰는 메모장이 따로 있다. 그게 바로 **메모리(Memory)**다. 

### 메모리는 칸이 엄청나게 많은 긴 서랍장이다

메모리를 가장 쉽게 상상하는 방법은 다음과 같다.

- 메모리 = 아주 길게 이어진 칸들의 줄
- 각 칸에는 숫자 하나(0~255 같은 작은 값)가 들어갈 수 있다
- 프로그램은 이 칸들에 값을 써두고, 필요할 때 다시 읽는다

여기서 놓치지 말아야 할 중요한 포인트가 있다. 컴퓨터의 데이터는 공중에 둥둥 떠 있지 않다. 항상 메모리 어딘가의 칸들에 들어 있다.

### 가장 작은 칸을 뭐라고 부를까?

메모리 칸의 기본 단위를 보통 바이트(byte)라고 부른다.

처음에는 바이트라는 용어가 낯설 수 있으니, 지금은 그냥 딱 두가지만 기억해도 충분하다.

1. 바이트 = 메모리의 한 칸
2. 데이터는 이 칸을 여러 개 묶어서 저장하기도 한다.

예를 들어 보면,
- `int`는 컴퓨터마다 다르지만 여러 칸을 묶어서 쓴다

> **C89에서 `int`의 크기는 고정이 아니다.**  
> 어떤 컴퓨터에서는 2바이트(2칸)을 쓰고, 어느 컴퓨터에서는 4바이트(4칸)을 쓸 수도 있다. 
> 우리는 정확히 몇 바이트인가?를 외우는 대신, 타입에 따라 필요한 칸의 개수가 다를 수 있다는 사실만 확실히 잡고 가면 된다.

---

## 10.2 주소: 메모리 칸에 붙은 ‘번지 번호’

앞서 메모리를 칸이 엄청나게 많은 서랍장이라고 했다. 그런데 서랍이 수천만 개나 된다면, 당연히 이런 문제가 생긴다.

"내가 방금 적어둔 숫자 10이 몇 번째 칸에 있더라?”

그래서 컴퓨터는 메모리의 각 칸마다 고유한 위치 번호를 붙여 두었다. 그 번호를 주소라고 부른다.

**주소는 데이터의 “좌표”다**

주소는 일상 생활의 위치찾기와 똑같다.

- 집 주소: 수원시 팔달구… (집이 어디 있는지)
- 사물함 번호: 108번 사물함 (내 짐이 어디 있는지)
- 좌석 번호: E열 7번 (내가 앉을 자리가 어디인지)

메모리도 마찬가지다.

- 메모리 주소: 이것이 메모리 맨 앞에서부터 몇 번째 칸인가?

우리는 지금까지 `a = 10`이라고 하면 단순히 `10` (값)만 생각했다. 하지만 컴퓨터 내부에서는 항상 두가지 정보가 함께 따라다닌다.

1. 값: 그 칸 안에 무엇이 들어있는가? (예: `10`)
2. 주소: 그 값이 어디에 있는가? (예: `1000번지`)

예) int 값이 4칸(4바이트)를 쓰는 컴퓨터에서, 0 ~ 255까지 숫자는 제일 앞칸에 저장된다고 하면,
```
 1000   1001   1002   1003
[ 10]  [  0]  [  0]  [  0]   ← 이 4칸 묶음이 a (타입: int)의 자리
```

주소는 한 칸의 번호이고, 타입은 몇 칸을 묶어서 값 하나를 저장할지를 결정한다.

---

## 10.3 변수는 값이 아니라 자리 + 이름표다

우리는 5장에서 변수를 이름 붙인 상자라고 배웠다.  
10장에서는 그 상자를 좀 더 컴퓨터 내부의 시선에서 들여다본다.

**선언 `int x;`는 무슨 뜻인가?**

이 코드는 단순히 x라는 변수를 뿅 하고 만든다고 하는 추상적인 마법의 주문이 아니다. 컴퓨터 입장에서 `int x;`는 아주 구체적인 작업 지시서다. 

1. **공간 확보**: 메모리 어딘가에 `int` 하나를 저장할 만큼의 자리를 찾아서 확보한다.
2. **이름표 부착**: 확보한 그 자리에 `x`라는 이름표를 붙인다.

그래서 변수의 정체는 어딘가의 자리(주소) + 그 자리를 부르는 이름(식별자)다. 

**대입 `x = 10;`은 무슨 뜻인가?**

이 문장은 컴퓨터에게 다음과 같이 명령하는 것이다.

- `x`라는 이름표가 붙은 자리를 찾아서,
- 그 자리(칸)에 값 `10`을 저장하라.

### `y = x;`는 무슨 뜻인가?

초보자들이 자주 착각하는 포인트가 바로 여기다. `y = x;`는 x 상자 자체를 y로 옮겨라거나 두 상자를 합쳐라는 뜻이 절대 아니다.

철저하게 내용물만 복사하는 과정이다.

1. `x` 자리에 가서 그 안에 들어있는 값(내용물)을 읽는다.
2. 읽어온 값을 `y` 자리에 그대로 배껴 쓴다(복사).

변수끼리의 대입(=)은 항상 "값 복사"다. `x`와 `y`는 여전히 별개의 자리이며, 서로의 위치(주소)에는 전혀 영향을 주지 않는다.

---

## 10.4 초기화하지 않은 변수는 왜 알 수 없는 값이 저장되어 있을까?

우리는 5장에서 이미 이런 경고를 들었다.

> *초기화 없이 `int x;`만 선언하면,*
> * `x` 안에는 알 수 없는 값이 들어있을 수 있다.*

메모리의 원리를 알았으니 그 이유가 명확해진다.

**메모리는 재활용되는 공책이다**

컴퓨터 입장에서 `int x;`라는 명령은 앞에서 봤듯이, 

> *메모리에서 `int` 크기만큼 빈칸을 잡아서 `x`라는 이름을 붙여줘 (청소는 안해도 돼)*

새로운 자리를 확보하는 것일 뿐, 그 자리를 0으로 싹 지우라는 말이 아니다.

우리가 변수를 선언해서 받은 그 메모리 칸은, 방금 전까지 다른 프로그램이나 함수가 쓰다가 반납한 메모리 칸일 확률이 매우 높다.
그 칸에는 예전에 쓰던 데이터(숫자, 문자 등의 흔적)이 그대로 남아있다.

남겨진 흔적을 우리는 알 수 없는 값이라고 부른다.

**초기화를 안 하면 생기는 일**

초기화(`=`)를 하지 않고 변수를 읽는다는건 이런 상황과 같다. 

1. 공책의 비어있는 페이지를 펼쳤다. (변수 선언)
2. 이전 사람이 지우지 않고 남겨둔 낙서를 읽었다. (알 수 없는 값 참조)
3. 내가 적은 적이 없는 값인데 내가 적은 겂으로 착각하고 계산에 썼다.

프로그램은 운 좋게 문제 없이 동작하거나, 엉뚱한 결과를 내거나, 오류가 발생하여 갑자기 종료될 수 있다.

**프로그래밍 규칙: 변수는 만들자마자 초기값을 저장하라**
C언어는 프로그래머를 믿기 때문에 자동으로 청소를 해주지 않는다. 청소는 온전히 프로그래머의 몫이다.
특히 C89는 블록 앞에서 선언을 모두 해야하기 때문에 나중에 변수를 쓸 때가 초기화를 하려다가 잊어버리고 청소를 안하는 일이 더 자주 발생한다.

* 방법 1 (선언과 동시에): `int x = 0;` (가장 추천)
* 방법 2 (쓰기 직전에): `x = 10;` (사용하기 전에는 무조건 대입)

> 변수라는 그릇은 씻어서(초기화해서) 사용하세요. 남이 먹다 남은 것이 들어있을 수 있습니다.

---

## 10.5 블록과 함수: 작업대가 생겼다가 사라진다

우리는 2장과 9장에서 중괄호 `{ }`의 의미를 배웠다.

- `{ }`는 "여기부터 여기까지가 한 묶음"이다는 의미다.
- 블록 안에서 만든 이름은 블록 밖에서 쓸 수 없다.

여기에 10장에서 배운 매모리 관점을 더하면 정의가 이렇게 바뀐다. 
블록은 메모리 위에 잠깐 쓰는 작업대를 펼치는 것이다.

**변수에는 저장 기간이 있다**

우리가 만든 변수는 영원히 존재하지 않는다. 변수는 자기가 속한 블록(작업대)가 유지되는 동안에만 쓰인다. 
컴퓨터 용어로 변수의 저장기간(Lifetime)이라고 부른다. 

1. `{` (블록 시작): 새 작업대를 펼친다. 여기서 만든 변수는 이 작업대 위에 올라간다.
2. `}` (블록 끝): 작업대를 통째로 치워버린다. 그 위에 있떤 변수들도 모두 메모리에서 사라진다.

```c
int main()
{
    /* 함수가 시작되며 새 작업대가 펼쳐진다 */
    int x;      /* 메모리에서 int만큼을 새로 확보하고, 이름표 x를 붙여놓는다. */
    x = 1;

    {
        /* 블록이 시작되며 새 작업대가 펼쳐진다 */
        int y;   /* 메모리에서 int만큼을 새로 확보하고, 이름표 y를 붙여놓는다. */
        y = 2;
    }
    /* 블록이 끝나며 작업대를 치운다. 이름표 y가 붙어있던 메모리 공간도 재활용 할 수 있게 반납한다. */
        

    {
        /* 블록이 시작되며 새 작업대가 펼쳐진다 */
        int z;   /* 메모리에서 int만큼을 새로 확보하고, 이름표 z를 붙여놓는다. */
                 /* 컴퓨터에 따라서 이전 블록의 y가 붙어있던 메모리 공간이 할당될 수도 있다. */
        z = 3;
    }
    /* 블록이 끝나며 작업대를 치운다. 이름표 z가 붙어있던 메모리 공간도 재활용 할 수 있게 반납한다. */
    return 0;
}
/* 함수 실행이 끝나며 작업대를 치운다. 이름표 x가 붙어 있던 메모리 공간도 재활용 할 수 있게 반납한다. */
```

블록 안에서 변수를 선언해서 확보한 메모리 공간은, 블록이 닫히는 순간 다른 코드에서 쓸 수 있게 반납된다. 

---

## 10.6 배열: 연속된 자리와 첫 칸의 위치 정보

8장에서 배열을 "같은 타입 상자들이 줄지어 있는 것"이라고 배웠다. 10장에서는 배열을 메모리 관점으로 다시 본다. 

1. `int a[5];`는 메모리에 무엇을 만드는가?

이 배열 선언은 컴퓨터에게 이렇게 명령한다: "int 5개를 담을 자리를 연속으로 확보하고, 제일 앞에 a라는 이름표를 붙여라." 

여기서 핵심은 연속(Contiguous)다. 

- 
