# 10. 메모리와 주소: 값이 ‘어디에’ 있는가

지금까지 우리는...
9장까지 숨 가쁘게 달려오며 다음 문법들을 익혔다.

- `int`로 값을 만들고 계산하기
- `if`로 갈림길을 만들기
- `for`로 반복 작업 수행하기
- 배열로 여러 값을 한꺼번에 다루기
- 함수로 복잡한 일을 나눠서 처리하기

**초보자가 부딪히는 3가지 의문**

여기까지 오면, 초보자라면 거의 반드시 이런 의문을 갖게 된다.

1. "함수에 `int`를 넘기면 원본이 안 바뀌는데, 배열을 넘기면 왜 원본이 바뀌지?"
2. "다른 변수는 `=`로 대입이 되는데, 배열은 왜 통째로 복사가 안되지?"
3. "도대체 내가 만든 변수들은 컴퓨터 어디에 저장되는 거지?"

이 질문들의 핵심은 하나로 귀결된다. 우리는 값(value)만 봤지, 그 값이 어디에 저장되는지(위치)를 아직 제대로 보지 못했다.

**10장의 목표**
이번 장의 목표는 이미 배운 문법들이 왜 그렇게 동작하는지를 메모리라는 관점에서 시원하게 파헤치는 것이다.

> 이 장의 목표
>
> - 컴퓨터가 값을 저장하는 공간인 **메모리(Memory)**를 이해한다
> - 메모리의 각 칸을 구분하는 번호인 **주소(Address)**의 개념을 잡는다
> - 변수는 단순한 값이 아니라 값이 들어있는 자리 + 그 자리의 이름표임을 이해한다
> - 배열 이름이 왜 배열 전체가 아니라 첫 칸의 위치 정보처럼 행동하는지 밝혀낸다
> - 함수 호출에서 값 전달(Call by Value)와 배열 전달(Call by reference)**가 왜 다르게 동작하는지 한 번에 정리한다
> - C 언어의 가장 큰 산인 (포인터)을 배우기 위한 준비 운동을 마친다

---

## 10.1 컴퓨터는 기억을 어디에 해둘까?

우리는 일상에서 뭔가를 기억할 때 다음과 같은 방법을 쓴다.

- 머릿속에 저장하거나
- 메모장에 적어두거나
- 파일에 저장한다

컴퓨터도 비슷하다. 그리고 프로그램이 실행되는 동안 컴퓨터가 가장 자주 쓰는 메모장이 따로 있다. 그게 바로 **메모리(Memory)**다. 

### 메모리는 칸이 엄청나게 많은 긴 서랍장이다

메모리를 가장 쉽게 상상하는 방법은 다음과 같다.

- 메모리 = 아주 길게 이어진 칸들의 줄
- 각 칸에는 숫자 하나(0~255 같은 작은 값)가 들어갈 수 있다
- 프로그램은 이 칸들에 값을 써두고, 필요할 때 다시 읽는다

여기서 놓치지 말아야 할 중요한 포인트가 있다. 컴퓨터의 데이터는 공중에 둥둥 떠 있지 않다. 항상 메모리 어딘가의 칸들에 들어 있다.

### 가장 작은 칸을 뭐라고 부를까?

메모리 칸의 기본 단위를 보통 바이트(byte)라고 부른다.

처음에는 바이트라는 용어가 낯설 수 있으니, 지금은 그냥 딱 두가지만 기억해도 충분하다.

1. 바이트 = 메모리의 한 칸
2. 데이터는 이 칸을 여러 개 묶어서 저장하기도 한다.

예를 들어 보면,
- `int`는 컴퓨터마다 다르지만 여러 칸을 묶어서 쓴다

> **C89에서 `int`의 크기는 고정이 아니다.**  
> 어떤 컴퓨터에서는 2바이트(2칸)을 쓰고, 어느 컴퓨터에서는 4바이트(4칸)을 쓸 수도 있다. 
> 우리는 정확히 몇 바이트인가?를 외우는 대신, 타입에 따라 필요한 칸의 개수가 다를 수 있다는 사실만 확실히 잡고 가면 된다.

---

## 10.2 주소: 메모리 칸에 붙은 ‘번지 번호’

앞서 메모리를 칸이 엄청나게 많은 서랍장이라고 했다. 그런데 서랍이 수천만 개나 된다면, 당연히 이런 문제가 생긴다.

"내가 방금 적어둔 숫자 10이 몇 번째 칸에 있더라?”

그래서 컴퓨터는 메모리의 각 칸마다 고유한 위치 번호를 붙여 두었다. 그 번호를 주소라고 부른다.

**주소는 데이터의 “좌표”다**

주소는 일상 생활의 위치찾기와 똑같다.

- 집 주소: 수원시 팔달구… (집이 어디 있는지)
- 사물함 번호: 108번 사물함 (내 짐이 어디 있는지)
- 좌석 번호: E열 7번 (내가 앉을 자리가 어디인지)

메모리도 마찬가지다.

- 메모리 주소: 이것이 메모리 맨 앞에서부터 몇 번째 칸인가?

우리는 지금까지 `a = 10`이라고 하면 단순히 `10` (값)만 생각했다. 하지만 컴퓨터 내부에서는 항상 두가지 정보가 함께 따라다닌다.

1. 값: 그 칸 안에 무엇이 들어있는가? (예: `10`)
2. 주소: 그 값이 어디에 있는가? (예: `1000번지`)

예) int 값이 4칸(4바이트)를 쓰는 컴퓨터에서, 0 ~ 255까지 숫자는 제일 앞칸에 저장된다고 하면,
```
 1000   1001   1002   1003
[ 10]  [  0]  [  0]  [  0]   ← 이 4칸 묶음이 a (타입: int)의 자리
```

주소는 한 칸의 번호이고, 타입은 몇 칸을 묶어서 값 하나를 저장할지를 결정한다.

---

## 10.3 변수는 값이 아니라 자리 + 이름표다

우리는 5장에서 변수를 이름 붙인 상자라고 배웠다.  
10장에서는 그 상자를 좀 더 컴퓨터 내부의 시선에서 들여다본다.

**선언 `int x;`는 무슨 뜻인가?**

이 코드는 단순히 x라는 변수를 뿅 하고 만든다고 하는 추상적인 마법의 주문이 아니다. 컴퓨터 입장에서 `int x;`는 아주 구체적인 작업 지시서다. 

1. **공간 확보**: 메모리 어딘가에 `int` 하나를 저장할 만큼의 자리를 찾아서 확보한다.
2. **이름표 부착**: 확보한 그 자리에 `x`라는 이름표를 붙인다.

그래서 변수의 정체는 어딘가의 자리(주소) + 그 자리를 부르는 이름(식별자)다. 

**대입 `x = 10;`은 무슨 뜻인가?**

이 문장은 컴퓨터에게 다음과 같이 명령하는 것이다.

- `x`라는 이름표가 붙은 자리를 찾아서,
- 그 자리(칸)에 값 `10`을 저장하라.

### `y = x;`는 무슨 뜻인가?

초보자들이 자주 착각하는 포인트가 바로 여기다. `y = x;`는 x 상자 자체를 y로 옮겨라거나 두 상자를 합쳐라는 뜻이 절대 아니다.

철저하게 내용물만 복사하는 과정이다.

1. `x` 자리에 가서 그 안에 들어있는 값(내용물)을 읽는다.
2. 읽어온 값을 `y` 자리에 그대로 배껴 쓴다(복사).

변수끼리의 대입(=)은 항상 "값 복사"다. `x`와 `y`는 여전히 별개의 자리이며, 서로의 위치(주소)에는 전혀 영향을 주지 않는다.

---

## 10.4 초기화하지 않은 변수는 왜 알 수 없는 값이 저장되어 있을까?

우리는 5장에서 이미 이런 경고를 들었다.

> *초기화 없이 `int x;`만 선언하면,*
> * `x` 안에는 알 수 없는 값이 들어있을 수 있다.*

메모리의 원리를 알았으니 그 이유가 명확해진다.

**메모리는 재활용되는 공책이다**

컴퓨터 입장에서 `int x;`라는 명령은 앞에서 봤듯이, 

> *메모리에서 `int` 크기만큼 빈칸을 잡아서 `x`라는 이름을 붙여줘 (청소는 안해도 돼)*

새로운 자리를 확보하는 것일 뿐, 그 자리를 0으로 싹 지우라는 말이 아니다.

우리가 변수를 선언해서 받은 그 메모리 칸은, 방금 전까지 다른 프로그램이나 함수가 쓰다가 반납한 메모리 칸일 확률이 매우 높다.
그 칸에는 예전에 쓰던 데이터(숫자, 문자 등의 흔적)이 그대로 남아있다.

남겨진 흔적을 우리는 알 수 없는 값이라고 부른다.

**초기화를 안 하면 생기는 일**

초기화(`=`)를 하지 않고 변수를 읽는다는건 이런 상황과 같다. 

1. 공책의 비어있는 페이지를 펼쳤다. (변수 선언)
2. 이전 사람이 지우지 않고 남겨둔 낙서를 읽었다. (알 수 없는 값 참조)
3. 내가 적은 적이 없는 값인데 내가 적은 겂으로 착각하고 계산에 썼다.

프로그램은 운 좋게 문제 없이 동작하거나, 엉뚱한 결과를 내거나, 오류가 발생하여 갑자기 종료될 수 있다.

**프로그래밍 규칙: 변수는 만들자마자 초기값을 저장하라**
C언어는 프로그래머를 믿기 때문에 자동으로 청소를 해주지 않는다. 청소는 온전히 프로그래머의 몫이다.
특히 C89는 블록 앞에서 선언을 모두 해야하기 때문에 나중에 변수를 쓸 때가 초기화를 하려다가 잊어버리고 청소를 안하는 일이 더 자주 발생한다.

* 방법 1 (선언과 동시에): `int x = 0;` (가장 추천)
* 방법 2 (쓰기 직전에): `x = 10;` (사용하기 전에는 무조건 대입)

> 변수라는 그릇은 씻어서(초기화해서) 사용하세요. 남이 먹다 남은 것이 들어있을 수 있습니다.

---

## 10.5 블록과 함수: 작업대가 생겼다가 사라진다

우리는 2장과 9장에서 중괄호 `{ }`의 의미를 배웠다.

- `{ }`는 "여기부터 여기까지가 한 묶음"이다는 의미다.
- 블록 안에서 만든 이름은 블록 밖에서 쓸 수 없다.

여기에 10장에서 배운 매모리 관점을 더하면 정의가 이렇게 바뀐다. 
블록은 메모리 위에 잠깐 쓰는 작업대를 펼치는 것이다.

**변수에는 저장 기간이 있다**

우리가 만든 변수는 영원히 존재하지 않는다. 변수는 자기가 속한 블록(작업대)가 유지되는 동안에만 쓰인다. 
컴퓨터 용어로 변수의 저장기간(Lifetime)이라고 부른다. 

1. `{` (블록 시작): 새 작업대를 펼친다. 여기서 만든 변수는 이 작업대 위에 올라간다.
2. `}` (블록 끝): 작업대를 통째로 치워버린다. 그 위에 있떤 변수들도 모두 메모리에서 사라진다.

```c
int main()
{
    /* 함수가 시작되며 새 작업대가 펼쳐진다 */
    int x;      /* 메모리에서 int만큼을 새로 확보하고, 이름표 x를 붙여놓는다. */
    x = 1;

    {
        /* 블록이 시작되며 새 작업대가 펼쳐진다 */
        int y;   /* 메모리에서 int만큼을 새로 확보하고, 이름표 y를 붙여놓는다. */
        y = 2;
    }
    /* 블록이 끝나며 작업대를 치운다. 이름표 y가 붙어있던 메모리 공간도 재활용 할 수 있게 반납한다. */
        

    {
        /* 블록이 시작되며 새 작업대가 펼쳐진다 */
        int z;   /* 메모리에서 int만큼을 새로 확보하고, 이름표 z를 붙여놓는다. */
                 /* 컴퓨터에 따라서 이전 블록의 y가 붙어있던 메모리 공간이 할당될 수도 있다. */
        z = 3;
    }
    /* 블록이 끝나며 작업대를 치운다. 이름표 z가 붙어있던 메모리 공간도 재활용 할 수 있게 반납한다. */
    return 0;
}
/* 함수 실행이 끝나며 작업대를 치운다. 이름표 x가 붙어 있던 메모리 공간도 재활용 할 수 있게 반납한다. */
```

블록 안에서 변수를 선언해서 확보한 메모리 공간은, 블록이 닫히는 순간 다른 코드에서 쓸 수 있게 반납된다. 

---

## 10.6 배열: 연속된 자리와 첫 칸의 위치 정보

8장에서 배열을 "같은 타입 상자들이 줄지어 있는 것"이라고 배웠다. 10장에서는 배열을 메모리 관점으로 다시 본다. 

1. `int a[5];`는 메모리에 무엇을 만드는가?

이 배열 선언은 컴퓨터에게 다음과 같이 명령한다: "int 5개를 담을 자리를 연속으로 확보하고, 제일 앞에 a라는 이름표를 붙여라." 

여기서 핵심은 연속성(Contiguous)이다. 중간에 빈틈이 전혀 없이 붙어있어야 한다. 

만약 `int`가 4바이트고, 시작 주소가 1000번지라면, 

| 배열 요소 | `a[0]` | `a[1]` | `a[2]` | `a[3]` | `a[4]` |
| :--- | :---: | :---: | :---: | :---: | :---: |
| **저장된 값** | `[ 값 ]` | `[ 값 ]` | `[ 값 ]` | `[ 값 ]` | `[ 값 ]` |
| **메모리 주소** | **1000** | 1004 | 1008 | 1012 | 1016 |

- 상자들은 물리적으로 다닥다닥 붙어 있다.
- 컴퓨터는 시작점(`1000`)만 알면 수학 계산(`1000 + 4 * 칸수`)으로 모든 위치를 즉시 찾아낼 수 있다.

2. 배열 이름 `a`는 왜 특별한가?

배열에서 가장 오해하기 쉬우면서도 중요한 성질은 이것이다: 배열의 이름(`a`)은 "배열 전체(값 덩어리)"가 아니다.

대부분의 문맥에서 배열 이름 `a`는 첫 번째 칸(`a[0]`)의 주소값(위치 정보)으로 변환되어 사용된다.

비유: `a`는 집 그 자체가 아니라, 그 집의 도로명 주소다.

3. 함수 전달: 복사본 vs 원본

이 "주소값"이라는 특성 때문에 9장에서 배운 차이가 발생한다.

| 구분 | `int` 변수 (`x`) | 배열 (`a`) |
| :--- | :--- | :--- |
| **전달 내용** | 값을 복사해서 전달 | 시작 주소를 복사해서 전달 |
| **비유** | 친구에게 내 노트를 복사해서 줌 | 친구에게 "내 노트 도서관 3번 책상에 있어"라고 위치를 알려줌 |
| **결과** | 친구가 낙서해도 내 원본은 무사함 | 친구가 그 위치로 가서 낙서하면 내 원본이 바뀜 |

**결론:**
배열을 함수로 넘길 때 "배열 5개를 통째로 복사"하는 비효율적인 일이 일어나지 않는 이유는, 우리가 "시작 위치(주소)" 단 하나만 넘겼기 때문이다.

---

## 10.9 왜 `b = a;` 같은 배열 대입이 안 될까?

8장에서는 "규칙이니까 외우자"고 했던 내용을, 이제 메모리 구조를 통해 이해해보자.

```c
int a[3] = { 1, 2, 3 };
int b[3];
```

b = a;  /* 컴파일 에러 발생! */

배열을 선언하는 순간(`int b[3];`) 컴파일러는 메모리의 특정 위치(예: 2000번지)를 `b`라고 딱 정해버린다.

배열 `a`도 선언을 해서 다음과 같은 상황이 되었다고 가정해보자.

- `a`: 1000번지에 고정된 이름표 (상수)
- `b`: 2000번지에 고정된 이름표 (상수)

그런데 `b = a;`라는 코드는 이런 의미가 된다: "지금부터 2000번지(b)를 1000번지(a)로 바꿔라."

C언어에서 배열의 이름은 메모리상의 고정된 위치(주소 상수)다. 태어날 때부터 정해진 주소를 바꿀 수 없으므로 대입 연산자(`=`)의 왼쪽에 올 수 없다.
전문 용어로는 수정 가능한 L-value가 아니다라고 한다.

---

## 10.10 C가 무서운 이유: 메모리 안전장치가 없다

이제 마지막으로, 이 장의 가장 중요한 경고를 한다.

1. 무한한 자유, 그리고 책임

C언어는 메모리 접근에서 안전장치가 거의 없다. 대표적인 예가 배열 범위 초과다.

```
int a[3] = { 1, 2, 3 };

// a는 0, 1, 2번 방만 있다.
// 그런데 3번 방에 짐을 넣으라고 한다면?
a[3] = 10; 
```

2. 왜 에러가 안 날까? (이웃집 침범 사건)

많은 초심자가 "컴파일 에러가 나겠지"라고 생각하지만, C언어는 에러를 내지 않는다.

메모리 관점에서 보면, `a[3]`은 `a[2]` 바로 뒷집 주소를 계산해서 접근한 것 뿐이다. 만약 그 뒷집에 다른 중요한 변수 `b`가 살고 있었다면 어떻게 될까?

메모리 상황: `int a[3]` 뒤에 `int b = 99;`가 선언되어 있었다고 가정해보자. 

| 메모리 주소 | 1000 | 1004 | 1008 | 1012 |
| :--- | :--- | :--- | :--- | :--- |
| **주인** | `a[0]` | `a[1]` | `a[2]` | `b` (원래 `b`의 집) |
| **값** | 1 | 2 | 3 | 99 |

여기서 `a[3] = 10;`을 실행하면, 컴퓨터는 1012번지에 10을 쓴다. 

결과:
- 나는 `a`만 건드렸는데, 갑자기 `b`의 값이 10으로 바뀐다.
- 프로그램은 아무런 경고도 없이 조용히 미쳐간다.

3. 미정의 동작

이것이 1장에서 언급했던 Undefined Behavior의 가장 무서운 사례다. 

- 운이 좋으면: 프로그램이 즉시 오류를 발생시키고 종료되어서(Segmentaiton Fault) 버그를 찾을 수 있다.
- 운이 나쁘면: 되는 것처럼 보이다가, 중요한 순간(예: 결제 처리)에 데이터가 꼬인다.
- 최악의 경우: 해커가 이 빈틈을 이용해 악성 코드를 심는다 (버퍼 오버플로우 공격).

교훈: C언어에서 인덱스 관리는 전적으로 프로그래머의 몫이다. `0`부터 `크기 - 1`까지만 쓰도록 스스로 감시해야 한다.
