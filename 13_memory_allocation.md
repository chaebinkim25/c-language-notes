# 13. 동적 메모리 할당: 필요할 때 만들고, 다 쓰면 반납하기

12장에서 우리는 문자열이 `char` 배열과 `'\0'`(null 문자)라는 약속으로 만들어진다는 것을 배웠다.
그리고 12.9절에서 포인터로 문자열을 직접 가리키는 방법을 보면서, 이런 말을 했었다.

> 다음 장에서 배울 동적 메모리 할당(`malloc`)은 배열의 이름이 아니라, **시작 주소(포인터)** 만 던져준다.
> (데이터가 어디에 있는지 위치만 알려준다.)

이제 그 "다음 장"이 왔다.
우리는 8장에서 배열을 배울 때, C89의 아주 불편한 현실도 같이 확인했다.

**C89에는 고무줄 같은 배열이 없다.**

`int a[n];`처럼 프로그램 실행 중에 크기가 정해지는 배열을 만들 수 없다.
코드를 짤 때(컴파일 타임) 무조건 크기를 못 박아야 했다.

그렇다면 질문은 하나로 모인다.

프로그램을 실행해 보니 필요한 칸 수가 그때그때 달라지는 상황(사용자 입력, 파일 크기, 네트워크…)에서,
우리는 어떻게 **그때그때 필요한 만큼의 배열/문자열** 을 만들까?

그 해답이 바로 **동적 메모리 할당**이다.

시스템에게 메모리를 잠시 빌려서 쓰고, 다 쓰면 반납하는 방법이다.

## 13.0 이 장의 목표

이 장을 끝내면 다음을 할 수 있게 된다.

* **필요성 이해 (Why)**: C89의 고정 배열이 가진 한계를 이해하고, **실행 중에 크기가 결정되는 데이터**를 다루기 위해 왜 동적 메모리 할당이 필수적인지 설명할 수 있다.

* **기본 도구 (Tools)**: `<stdlib.h>`의 `malloc`으로 메모리를 **빌리고**, `free`로 **반납**하는 기본적인 사용 패턴을 익힌다.

* **안전 수칙 (Safety)**: 자유에는 책임이 따른다. `NULL` 체크, 메모리 누수(Leak), 이중 해제(Double Free), 해제 후 사용(Use-after-free) 등 **치명적인 버그를 예방하는 코딩 습관**을 기른다.

* **실전 응용 (Practice)**: 낭비 없이 **딱 필요한 만큼**의 크기를 가진 `int` 배열이나 문자열을 동적으로 생성하고 활용하는 함수를 직접 작성할 수 있다.
 
## 13.1 왜 동적 메모리가 필요한가

### 13.1.1 C 배열은 “미리 방 개수를 정한 집”이다
8장에서 우리는 배열을 만들 때 대괄호 안에 숫자를 썼다.

```c
int a[5];
```

여기서 대괄호 안의 숫자 `[5]`는 단순한 힌트가 아니다. 집을 짓기 전에 **방 개수가 5개로 정해진 설계도**를 확정하는 것과 같다.
C 언어의 배열은 태생적으로 고정 크기다. 그래서 변수를 사용해 배열의 크기를 지정하는 코드는 원칙적으로 불가능하다.

> [!NOTE]
> **참고: 가변 길이 배열(VLA)의 흥망성쇠**
> 사실 C 언어 역사에서 **잠깐의 외도**가 있긴 했다.
> 1999년에 발표된 C99 표준에서는 `int a[n];` 같은 가변 길이 배열(VLA) 기능을 표준에 포함시키고, 컴파일러들이 의무적으로 지원하도록 강제했었따.
>
> 하지만, 막상 써보니 문제가 많았다. 스택 메모리가 터져버리는 사고(Stack Overflow)가 빈번했고, 보안 취약점도 발견되었다.
>
> 결국 2011년 발표된 C11 표준부터는 VLA가 의무에서 선택으로 강등되었다.
> 컴파일러가 "우리는 위험해서 지원 안할래요"라고 거부해도 표준 위반이 아니게 된 것이다.
> (실제로 윈도우의 MSVC 컴파일러는 VLA를 지원하지 않는다.)
>
> 그러니 우리는 역사의 교훈을 받아들여야 한다. "배열의 크기는 무조건 상수(숫자)로만 적는다. 변수는 안된다."

### 13.1.2 그런데 현실 데이터는 "방 개수를 미리 모르는 집"이 많다
현실에서는 이런 상황이 훨씬 많다.

* 사용자가 숫자를 몇 개 입력할지 모른다.
* 파일에 데이터가 몇 줄이나 있는지 모른다.
* 문자열 길이가 입력을 받아봐야 안다. ("이름이 3글자인지 30글자인지?")

이런 경우, 기존 방식으로는 **미리 방 1000개 지어두기** 전법으로 버틸 수밖에 없었다.

하지만 이 방식에는 치명적인 딜레마가 있다.

1.  **너무 작으면 터진다:** 데이터가 지정한 개수를 넘어가면 배열 범위를 벗어나서 프로그램이 뻗는다. (버퍼 오버플로우)
2.  **너무 크면 낭비다:** 실제로는 10개만 쓰는데 1000개를 잡아두면, 나머지 990칸의 메모리는 낭비된다.

그래서 **필요한 순간에, 필요한 만큼만 딱 빌리는** 방식이 필요하다.


## 13.2 "작업대"와 "창고": 메모리의 유통기한(언제까지 쓸 수 있나)

10장에서 **블록 `{ }`**은 **작업대**라고 배웠다.

* `{`를 만나면 작업대를 펼치고,
* `}`를 만나면 작업대를 치워버린다.

그래서 블록 안에서 만든 변수(지역 변수)는 블록이 끝나면 같이 사라진다.

```c
int *p;

{
    int x = 10;
    p = &x; /* x의 주소를 밖으로 빼냈다 */
}
/* 여기서 x는 사라졌다. p는 "철거된 집의 주소"를 들고 있다 */
```

이 과정에서 포인터가 가리키던 대상이 사라지면, 11장에서 배운 **댕글링 포인터(Dangling Pointer)** 사고가 발생한다.

### 그럼 동적 메모리는 무엇이 다를까?

지역 변수는 **작업대(블록)** 이 치워지면 같이 사라진다.
하지만 동적 메모리는 **작업대가 아니라 창고**에 따로 보관한다고 생각하면 된다.

작업대(함수/블록)가 치워져도, 창고에 넣어둔 물건은 그대로 남아 있다.
대신, 우리가 **이제 필요 없다고 반납(free) 신호를 보내기 전까지** 계속 자리를 차지하고 있다.

> [!NOTE]
> **용어: 스택(Stack)과 힙(Heap)**
> 사람들은 보통
> * 지역 변수가 사는 곳을 **스택(stack)**
> * 동적 메모리가 사는 곳을 **힙(heap)**
>
> 이라고 부른다. 지금 단계에서는 용어보다 **규칙 하나**만 기억하면 충분하다.
> **"동적 메모리는 내가 `free`하기 전까지 영원히 쓸 수 있다."**

## 13.3 `malloc`: 바이트 단위로 메모리를 빌려오기

### 13.3.1 준비물: `<stdlib.h>`
동적 메모리 함수(`malloc`, `free`)는 표준 라이브러리 `<stdlib.h>`에 들어 있다.
이 도구들을 쓰려면 프로그램 소스 파일에 반드시 헤더를 포함해야 한다.

```c
#include <stdlib.h>
```

### 13.3.2 `malloc`이 하는 일 (핵심 2줄)
`malloc`은 **"Memory ALLOCation(메모리 할당)"** 의 줄임말이다.
하는 일은 딱 2줄로 요약된다.

1.  **요청:** "운영체제님, 저 **OO 바이트**만 빌려주세요." (크기를 바이트 단위로 줘야 함)
2.  **응답:** "여기 **빈 땅의 시작 주소**다. 실패하면 `NULL`이다."

즉, `malloc`은 알아서 예쁜 "배열"을 만들어 주는 게 아니다.
그저 **"데이터를 담을 수 있는 빈 땅의 주소(`void *`)"** 만 던져준다.
우리는 그 땅을 받아서 `int` 배열로 쓰든, `char` 배열로 쓰든 알아서 해야 한다.

### 13.3.3 예제: int 5칸짜리 동적 배열 만들기
코드를 작성할 때 다음 4단계를 반드시 기억해야 한다.

1.  **메모리 빌리기 (Allocation)**
    * 목표: `int` 5개를 담고 싶다.
    * 계산: `int` 크기(보통 4바이트) * 5개 = **20바이트** 필요.
    * `malloc`에게는 반드시 **"20바이트 줘"**라고 말해야 한다. (`malloc(5)`라고 하면 5바이트만 줘서 망한다.)

2.  **실패 검사 (필수!)**
    * 메모리가 꽉 찼다면 `malloc`은 `NULL`을 리턴한다.
    * 이때 방심하고 데이터를 넣으려고 하면 프로그램은 즉시 뻗어버린다(Crash). 반드시 체크해야 한다.

3.  **사용하기**
    * 이제 포인터를 배열 이름처럼(`a[i]`) 쓸 수 있다.
    * 11~12장에서 배운 "포인터와 배열의 관계" 덕분이다.

4.  **반납하기 (Deallocation)**
    * 다 썼으면 반드시 `free`로 반납해야 한다.
    * **[안전 수칙]** 반납한 주소를 계속 들고 있으면 위험하다(댕글링 포인터). "이제 이 열쇠는 못 쓴다"고 `NULL`로 지워두는 것이 좋다.

```c
#include <stdlib.h> /* malloc, free가 사는 곳 */

int main(void)
{
    int *a;
    int i;

    /* 1. 메모리 빌리기 (Allocation)
       - 목표: int 5개를 담고 싶다.
       - 계산: int 크기(보통 4바이트) * 5개 = 20바이트 필요.
       - malloc에게는 "20바이트 줘"라고 말해야 한다.
    */
    a = (int *)malloc(5 * sizeof(int));

    /* 2. 실패 검사 (필수!) */
    if (a == NULL) {
        return 1; /* 에러 종료 */
    }

    /* 3. 사용하기
       - 이제 포인터 a를 배열 이름처럼(a[i]) 쓸 수 있다.
       - 11~12장에서 배운 "포인터와 배열의 관계" 덕분이다.
    */
    for (i = 0; i < 5; i++) {
        a[i] = i * 10;
    }

    /* 4. 반납하기 (Deallocation)
       - 다 썼으면 반드시 free로 반납해야 한다.
    */
    free(a);
    
    /* [안전 수칙]
       반납한 주소를 계속 들고 있으면 위험하다(댕글링 포인터).
       "이제 이 열쇠는 못 쓴다"고 NULL로 지워두는 것이 좋다.
    */
    a = NULL;

    return 0;
}
```

> [!TIP]
> **캐스팅(`(int *)`)을 꼭 해야 하나요?**
>
> 사실 C 언어 표준에서는 필수 사항이 아니다.
> `malloc`의 반환값인 `void *`는 대입될 때 자동으로 상대방 타입으로 변한다.
>
> 하지만 **교재에서는 캐스팅을 명시적으로 적었다.** 이유는 두 가지다.
> 1.  **C++ 호환성:** C++ 컴파일러는 자동 변환을 안 해준다. (나중에 코드를 C++로 옮길 때 에러가 난다.)
> 2.  **명확성:** "이 메모리는 `int` 용도다"라고 코드 읽는 사람에게 알려주는 효과가 있다.
>
> 중요한 건 캐스팅 자체가 아니라 **`sizeof(타입)`으로 크기를 정확히 계산하는 습관**이다.

### 13.3.4 "몇 바이트?"를 계산하는 표준 패턴
동적 배열을 만들 때 전 세계 C 프로그래머들이 쓰는 **공식** 같은 패턴이다.

```c
T *p = (T *)malloc(n * sizeof(T));
```

* **`T`**: 원소 타입 (예: `int`, `char`, `double`…)
* **`n`**: 필요한 개수
* **`sizeof(T)`**: 그 타입 하나의 크기

이 공식을 쓰면 "타입이 바뀌어도", "컴퓨터가 바뀌어도" 항상 정확한 크기의 메모리를 빌릴 수 있다.

## 13.4 free: 다 쓴 메모리를 반드시 "반납하기"

동적 메모리의 규칙은 단순하지만, 무거운 책임이 따른다.
규칙은 딱 하나다.

**"빌린 건 반드시 갚아라."**

`malloc`으로 빌린 메모리는 사용이 끝나면 반드시 `free` 함수로 반납해야 한다.

만약 반납하지 않으면 어떻게 될까?
프로그램이 끝날 때까지 그 메모리는 "사용 중"으로 표시되어 낭비된다.
이것이 쌓이고 쌓이면 컴퓨터가 점점 느려지다가 멈춰버린다.
이 현상을 **메모리 누수(Memory Leak)**라고 부른다.

### 13.4.1 `free` 이후의 포인터는 “철거된 집 열쇠”다
`free`를 호출한 순간, 그 메모리는 더 이상 내 것이 아니다.
운영체제에게 소유권이 넘어갔다.

* 그 자리에는 나중에 다른 데이터가 들어갈 수도 있고,
* 즉시 운영체제가 회수하여 접근이 차단될 수도 있다.

따라서 **"이미 반납한 열쇠"**를 가지고 문을 열려고 시도하면 큰일 난다.

```c
free(a);
a[0] = 123; /* 위험! 해제된 메모리 사용 (Use-After-Free) */
```

이런 코드는 운 좋으면 에러가 발생하고, 운 나쁘면 **해킹의 원인(보안 취약점)**이 된다. (전문 용어로 **Use-After-Free**라고 한다.)

### 13.4.2 안전벨트: `free` 후에 `NULL`로 만드는 습관
실수로 이미 반납한 메모리를 또 반납하거나(`Double Free`), 반납한 메모리를 건드리는 실수를 막기 위해 가장 좋은 습관은 이것이다.

**"반납하자마자 포인터에 `NULL`을 대입해서 열쇠를 없애버린다."**

```c
free(a);
a = NULL; /* 열쇠를 아예 없애버린다 */
```

이렇게 하면 실수를 해도 안전하다.

1.  **접근 시도:** `NULL` 포인터를 건드리면 운영체제가 즉시 에러를 띄우고 프로그램을 종료시킨다. (엉뚱한 데이터가 오염되는 것보다 훨씬 낫다. 디버깅하기 쉽기 때문이다.)
2.  **중복 해제 방지:** C 언어 표준에서 **`free(NULL)`은 "아무 일도 하지 않음"**으로 정의되어 있다. 포인터가 `NULL`인 상태에서 실수로 `free`를 또 호출해도 문제 없다.

> [!WARNING]
> **절대 하면 안 되는 것: 지역 변수(스택)를 free하기**
>
> `free`는 오직 `malloc`으로 빌린 **힙(Heap)** 메모리만 반납할 수 있다.
> 그 외에 멀쩡한 지역 변수(스택)의 주소를 `free`에게 넘겨주면 미정의 동작 (Undefined Behavior)가 발생한다.

```c
int x = 10;
free(&x); /* 으악! 스택 메모리는 free 할 수 없습니다! */
```

## 13.5 `calloc`: "0으로 청소된" 메모리를 빌리기

### 13.5.1 알 수 없는 값 vs 0
`malloc`이 빌려주는 메모리는 **"이전 세입자가 쓰다 남은 방"**과 같다.
운영체제는 속도를 위해 방을 치우지 않고 그냥 내준다.
그래서 그 안에는 알 수 없는 값이 들어 있다.
(10장에서 초기화하지 않은 지역 변수가 이상한 값을 가졌던 것과 똑같은 원리다.)

반면 `calloc`은 **"입주 청소가 완료된 방"**을 준다.
메모리를 빌린 후, 모든 비트를 **0**으로 싹 채워서 건네준다.

* **`malloc`**: 청소 안 된 빈 방 (알 수 없는 값 들어있음)
* **`calloc`**: 0으로 싹 청소된 방 (깔끔함)

### 13.5.2 사용법: 콤마(,)에 주의하자
`malloc`과 다르게 `calloc`은 인자를 2개 받는다.

```c
/* malloc: 우리가 곱셈을 해서 "총 크기"를 알려준다 */
p = (int *)malloc(n * sizeof(int));

/* calloc: "개수"와 "크기"를 따로 알려준다 (콤마 사용!) */
p = (int *)calloc(n, sizeof(int));
```

* **첫 번째 인자 (`n`):** 필요한 개수
* **두 번째 인자 (`sizeof`):** 한 칸의 크기

`malloc`은 우리가 직접 곱셈을 해서 "총 크기"를 알려줘야 하지만,
`calloc`은 개수와 크기를 **콤마(,)**로 구분해서 따로 알려준다.
이렇게 하면 `calloc`이 내부적으로 총 크기를 계산해서 메모리를 확보하고, 그 공간을 **0으로 초기화**해준다.

### 13.5.3 그럼 무조건 calloc이 좋은가?
"청소까지 해주니 `malloc` 말고 무조건 `calloc`만 쓰면 되지 않나요?"

정답은 **"상황에 따라 다르다"**.
세상에 공짜는 없다. **청소하는 데도 시간이 걸린다.**

1.  **`malloc` 유리:** 빌리자마자 바로 데이터를 덮어쓸 예정이라면(예: 파일에서 데이터를 읽어오기), 굳이 0으로 청소할 필요가 없다. 이때는 더 빠른 `malloc`을 쓴다.
2.  **`calloc` 유리:** 배열을 만들고 카운터(0부터 시작)로 쓰거나, 안전하게 초기화된 상태가 필요하다면 `calloc`이 편하다.

> [!NOTE]
> **기술적 디테일: “모든 바이트가 0”**
> 
> `calloc`은 메모리의 모든 비트를 0으로 채운다.
> 정수 타입(`int`, `char` 등)에서 모든 비트가 0이면 숫자 **0**이 되므로 안심하고 쓰면 된다.
> (대부분의 시스템에서 포인터 `NULL`과 실수 `0.0`도 0으로 표현되므로 문제없이 작동한다.)

## 13.6 realloc: 크기를 바꾸기 (주의해서 사용하기)

프로그램을 짜다 보면 이런 상황이 생긴다.

* "처음엔 10칸이면 될 줄 알았는데, 쓰다 보니 20칸이 필요해졌다."

이때 **"새로 만들고, 데이터를 옮기고, 기존 것은 지우기"**를 한 방에 해결해 주는 함수가 `realloc`이다.

### 13.6.1 realloc의 작동 원리: "증축" 아니면 "이사"
`realloc` 함수를 호출하면 운영체제는 두 가지 방법 중 하나를 선택한다.

1.  **증축 (Expand):** 다행히 현재 메모리 바로 뒷공간이 비어있다. 그냥 울타리만 넓힌다. (주소 변동 없음)
2.  **이사 (Move):** 뒷공간이 꽉 차 있다. **더 넓은 새로운 땅을 찾아서 통째로 이사한다.**

여기서 중요한 점은 **"이사 서비스"**가 포함되어 있다는 것이다.
`realloc`은 이사를 갈 때 **기존에 있던 데이터(짐)를 새집으로 그대로 복사**해 주고, **옛날 집은 알아서 철거(`free`)** 해 준다.
우리는 그냥 늘어난 공간만 더 쓰면 된다.

### 13.6.2 가장 중요한 규칙: 주소가 바뀔 수 있다
위에서 봤듯이 "이사를 가는 상황"이 생기면 메모리의 **주소(포인터)**가 바뀐다.
그래서 `realloc`을 쓸 때는 항상 **"반환값을 새로 받아야"** 한다.

하지만 변수에 `realloc`의 결과를 바로 덮어쓰는 코드는 **대형 사고**가 터질 수 있다.

```c
/* 절대 이렇게 짜지 마세요! */
a = (int *)realloc(a, new_bytes);
```

이 방식이 위험한 이유는 `realloc`이 **실패했을 경우** 때문이다.
메모리가 부족해서 실패하면 `realloc`은 `NULL`을 리턴한다.

1.  `realloc`이 `NULL`을 던진다.
2.  기존 변수에 `NULL`이 덮어씌워진다.
3.  **원래 있던 메모리 주소를 잃어버렸다!** (데이터는 유지되고 있는데, 찾아갈 지도가 사라짐. 메모리 누수)

### 13.6.3 안전한 패턴: 임시 포인터 사용
그래서 `realloc`을 쓸 때는 반드시 **임시 포인터(`tmp`)**를 둬서 보험을 들어야 한다.

1.  **일단 임시 변수에 결과를 받는다.** (`tmp = realloc(...)`)
2.  **성공/실패를 검사한다.**
    * **실패 시 (`tmp == NULL`):** 원본 포인터는 아직 살아있다. 여기서 에러 처리를 하면 된다.
    * **성공 시 (`else`):** 원본 포인터를 새 주소(`tmp`)로 갱신한다. (만약 주소가 바뀌었다면, 옛날 주소는 이미 `realloc`이 알아서 `free`했다.)

```c
int *tmp;

/* 1. 일단 임시 변수에 결과를 받는다 */
tmp = (int *)realloc(a, new_bytes);

if (tmp == NULL) {
    /* 실패: 메모리 부족. */
    /* 하지만 원본 a는 아직 살아있다! 여기서 에러 처리를 하면 된다. */
    printf("메모리 늘리기 실패!\n");
} else {
    /* 성공: a를 새 주소(tmp)로 갱신한다. */
    /* (만약 주소가 바뀌었다면, 옛날 주소는 이미 realloc이 알아서 free했다) */
    a = tmp; 
}
```

이 패턴을 쓰면 실패해도 원래 데이터를 지킬 수 있고, 성공하면 자연스럽게 새 주소로 갈아탈 수 있다.


## 13.7 실전: “딱 맞는 문자열”을 동적으로 복사하기

12장에서 우리는 **"문자열은 `char` 배열이다"**라고 배웠다.
그런데 현실에서는 문자열의 길이가 **프로그램이 실행된 뒤에야(입력을 받아봐야)** 정해질 때가 많다.

여기서 동적 메모리가 빛을 발한다.
우리는 다음과 같은 순서로 "딱 맞는" 문자열을 만들 것이다.

1.  문자열의 길이를 먼저 잰다. (`str_len`)
2.  그 길이 + **1(null 문자 자리)** 만큼만 메모리를 빌린다. (`malloc`)
3.  내용을 복사해서 돌려준다. (`str_copy`)


## 13.7.1 str_dup: 문자열을 복사해서 새 메모리를 돌려주는 함수
이 함수는 C 프로그래밍에서 아주 유명한 패턴이다.
가장 중요한 규칙은 **"책임의 이동"**이다.

* **함수 안에서:** 메모리를 빌린다(`malloc`).
* **함수 밖에서:** 사용자가 다 쓰고 나면 반드시 반납해야 한다(`free`).

함수를 만들 때 가장 주의해야 할 점은 `malloc`을 호출할 때 계산식이다.
반드시 글자 수(`len`)에 **+1**을 해야 한다.
맨 뒤에 숨어있는 **`\0` (널 문자)** 가 들어갈 자리를 확보하지 않으면, 문자열 끝을 알 수 없어서 프로그램이 폭주하게 된다.

```c
#include <stdlib.h>

/* 12장에서 만든 함수가 있다고 가정 */
int str_len(const char s[]);
void str_copy(char dst[], int dst_size, const char src[]);

/*
 * str_dup: src 문자열을 복사한 “새 문자열”을 만든다.
 * 반환값:
 * - 성공: 새로 빌린 메모리의 시작 주소
 * - 실패: NULL
 */
char *str_dup(const char src[])
{
    int len;
    char *p;

    /* 1. 길이 재기 */
    len = str_len(src);

    /* 2. 메모리 빌리기
       주의: 글자 수(len)에 반드시 +1을 해야 한다.
       맨 뒤에 숨어있는 '\0' (널 문자)가 들어갈 자리다.
    */
    p = (char *)malloc((len + 1) * sizeof(char));
    
    if (p == NULL) {
        return NULL; /* 메모리 부족 */
    }

    /* 3. 복사하기 */
    str_copy(p, len + 1, src);

    /* 4. 새 주소 던져주기 */
    return p;
}
```

> [!NOTE]
> **`sizeof(char)`는 생략해도 되나요?**
> C 표준에서 `char`의 크기는 무조건 **1바이트**로 정의되어 있다.
> 그래서 `(len + 1)`만 써도 되지만, 앞서 배운 `malloc` 공식(`개수 * sizeof(타입)`)을
> 일관성 있게 지키기 위해 적어주는 것이 좋은 습관이다.

## 13.7.2 사용 예제: 박물관 전시품을 기념품으로 만들기
12장에서 **문자열 리터럴("Hello")** 은 **"박물관 전시품(Read-only)"** 이라서 손대면(수정하면) 경찰이 출동한다고 했다.

하지만 `str_dup`으로 복사해온 문자열은 다르다.
이것은 박물관 매점에서 돈 주고 산 **"내 기념품(Heap Memory)"** 이다.
내 것이므로 마음대로 칠하고 수정해도 된다.

```c
#include <stdlib.h>

int main(void)
{
    char *name;

    /* "Hello"라는 전시품을 복제해서 내 것을 만들었다 */
    name = str_dup("Hello");
    
    if (name == NULL) {
        return 1;
    }

    /* 이제 name은 완전한 내 소유다. 수정 가능! */
    name[0] = 'h'; 
    /* 문자열이 hello로 수정되었다 */

    /* 내 물건이니, 다 썼으면 내가 직접 치워야 한다 */
    free(name);
    name = NULL;

    return 0;
}
```

이처럼 `malloc`을 활용하면, 길이도 내 마음대로, 내용 수정도 내 마음대로 할 수 있는 진정한 의미의 **가변 문자열(Variable String)** 을 다룰 수 있게 된다.
물론, 내 물건이니 다 썼으면 내가 직접 치워야(`free`) 한다는 점만 기억하면 된다.


## 13.8 동적 메모리 3대 사고 (그리고 예방책)

동적 메모리는 강력한 무기지만, C 언어는 안전장치를 제공하지 않는다.

따라서 발생할 수 있는 사고 패턴을 미리 외워두고, 항상 경계해야 한다.

### 13.8.1 메모리 누수 (Memory Leak): "빌린 걸 안 돌려줌"
가장 흔하지만, 가장 찾기 힘든 사고다.

```c
int *a;
a = (int *)malloc(100 * sizeof(int));

/* ... 열심히 사용 ... */

return 0; /* 으악! free(a) 없이 퇴근해버림 -> 누수 발생 */
```
* **증상:** 프로그램이 금방 끝나면 운영체제가 정리해주기도 한다. 하지만 메모리를 조금씩 갉아먹다가, **오래 켜두면(서버, 게임 등) 결국 컴퓨터가 멈추거나 프로그램이 강제 종료된다.**
* **흔한 실수:** `free`를 까먹는 것뿐만 아니라, **주소를 잃어버리는 것**도 누수다.
    * 앞서 빌린 메모리의 주소를 보관하던 포인터 변수에 다른 값을 덮어써버리면, 원래 메모리는 영원히 찾을 수도, 반납할 수도 없게 된다.
* **예방책:**
    * `malloc`을 적는 순간, 코드의 끝부분에 `free`를 먼저 적어두는 습관을 들인다.
    * "이 포인터는 누가 `free` 할 책임이 있는가?"를 주석으로 명시한다.

### 13.8.2 이중 해제 (Double Free): "같은 걸 두 번 반납"
이미 반납한 열쇠를 관리실에 또 반납하러 가는 꼴이다.

```c
free(a);
free(a); /* 위험 */
```

* **증상:** `free`한 공간을 다시 `free`하는 것은 미정의 동작 (Undefined Behavior)다. 메모리 관리 대장(Heap Manager)이 꼬여서, 프로그램이 즉시 **비정상 종료(Crash)** 하거나 엉뚱한 데이터를 건드리게 된다.
* **예방책:**
    * `free` 후에는 반드시 포인터에 `NULL`을 넣는 패턴을 습관화한다. (`free(NULL)`은 안전하니까!)
    * 함수끼리 포인터를 주고받을 때 **"소유권(누가 해제할지)"**을 명확히 한다.

### 13.8.3 해제 후 사용 (Use-after-free): "반납했는데 다시 사용"
전문 용어로 **댕글링 포인터(Dangling Pointer)** 문제라고도 한다.

```c
free(a);
a[0] = 1; /* 위험 */
```

* **증상:** `free`나 `realloc`에 의해 해제된 공간을 가리키는 포인터의 값을 참조하는 것은 미정의 동작 (Undefined Behavior)다. 운 좋으면(?) 비정상 종료가 되지만, 운 나쁘면 **해킹(보안 취약점)**의 원인이 되거나 나중에 원인을 알 수 없는 버그가 터진다.
* **예방책:**
    * 역시 `free` 후 `NULL` 대입이 최고의 예방책이다.
    * 사용하기 전에 포인터가 `NULL`인지 검사하는 방어 코드를 짠다.

## 13.8.4 \[경고\] "내가 빌린 것만 반납하라" (Invalid Free)
초보자가 가장 많이 하는 실수 중 하나다.
`free`는 오직 **`malloc` 친구들(calloc, realloc)이 준 주소**만 받을 수 있다.

다음 두 가지는 절대 `free` 하면 안 된다.

1.  **스택(지역) 변수 반납 금지:** 잘 쓰고 있는 지역 변수의 주소를 반납하려 하면 안 된다.
```c
int x = 10;
free(&x); /* 절대 안 됨! x는 스택에 있다. */
```

2.  **문자열 리터럴 반납 금지:** `"Hello"` 같은 고정된 문자열은 힙(Heap)에 있지 않다.
```c
char *p = "Hello";
free(p); /* 절대 안 됨! "Hello"는 코드 영역(상수)에 있다. */
```

* **증상:** `calloc`, `malloc`, `realloc` 함수로 받은 것이 아닌 포인터를 해제하는 것은 미정의 동작 (Undefined Behavior)다. 운영체제가 "내 구역도 아닌데 감히 건드려?" 하고 프로그램을 즉시 강제 종료시킨다.

