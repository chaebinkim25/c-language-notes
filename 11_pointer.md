# 11. 포인터: 값이 있는 곳을 가리키기

10장에서 우리는 **"값이 공중에 둥둥 떠 있는 게 아니다"**라는 사실을 확실히 알았다.
모든 데이터는 메모리라는 거대한 아파트의 **특정 호수(주소, address)** 칸에 저장된다.

하지만 10장까지는 여기서 멈췄다.

* 데이터에 주소가 있다는 **이론**은 알았지만,
* 그 주소를 **코드에서 직접 다루는 문법**은 배우지 않았다.
    (마치 맛집 주소는 알지만, 정작 찾아가는 길은 모르는 상태와 같다.)

11장에서는 드디어 그 '찾아가는 문법'을 배운다. 핵심은 이것이다.

> **"주소도 결국은 숫자 데이터(값)이다."**
> **그리고 그 주소 값을 저장하기 위해 만든 변수가 바로 포인터(pointer)다.**

포인터를 장착하면, 그동안 "그냥 외우세요"라고 했던 의문들이 한 번에 풀린다.

1.  함수에 `int`를 넘기면 왜 원본이 안 바뀌는가? (주소가 아니라 **값만 복사**해줬으니까)
2.  배열을 넘기면 왜 원본이 바뀌는가? (배열은 태생적으로 **주소를 전달**하니까)
3.  왜 C언어가 강력하면서도 위험한가? (메모리의 **정확한 주소**를 콕 집어서 조작할 수 있기 때문)

이제 메모리의 주소를 손에 쥐고 흔드는 C언어의 진짜 힘, 포인터의 세계로 들어가 보자.


## 11.0 이 장의 목표

이 장의 목표는 단순히 `*`나 `&` 같은 기호를 어디에 적는지 문법을 외우는 것이 아니다.
여러분의 머릿속에 **메모리 지도를 그리고, 자유자재로 이동할 수 있는 능력**을 만드는 것이 진짜 목표다.

코드를 볼 때 더 이상 글자만 보지 않고, 메모리 상자의 연결 관계가 그려져야 한다.

우리는 이 장을 통해 다음 단계들을 정복할 것이다.

**1. 도구 익히기: 주소를 다루는 새로운 문법**
* **주소 추출:** 변수가 살고 있는 위치를 알아내는 `&` 연산자
* **포인터 선언:** 그 주소를 저장하기 위한 전용 변수 `int *p`
* **간접 접근:** 주소를 타고 가서 실제 값을 읽고 쓰는 `*` 연산자

**2. 실전 응용: 한계를 돌파하기**
* **원격 제어:** 포인터를 이용해 함수 안에서 **외부 변수(원본)를 수정**하는 방법 (Swap 함수 완성)
* **배열의 정체:** 배열의 이름이 사실상 포인터처럼 행동하는 이유

**3. 안전하게 사용하기**
* **위험성 인지:** 포인터를 잘못 썼을 때 프로그램이 어떻게 망가지는지(미정의 동작)를 이해하고 예방하기

포인터를 이해하면 C언어의 절반을 넘은 것이다. 이제 시작해보자.


## 11.1 왜 포인터가 필요한가: 10장의 질문을 완성하기

### 11.1.1 “값만” 넘기면 생기는 한계

9장에서 함수 호출은 기본적으로 **값을 복사해서 전달(Call by Value)** 한다는 것을 배웠다.
그래서 함수 안에서 매개변수를 아무리 지지고 볶아도, 함수 밖의 원본은 바뀌지 않는다.

이 성질이 가장 뚜렷하게 드러나는 예제가 바로 `swap` 함수다.
두 변수의 값을 서로 바꾸는 함수를 만들고 싶을 때, 초보자는 보통 이렇게 코드를 짠다.

```c
void swap_bad(int a, int b)
{
    int tmp = a;
    a = b;
    b = tmp;
}

int main()
{
    int x = 1;
    int y = 2;

    swap_bad(x, y);

    /* 기대: x = 2, y = 1 */
    /* 현실: x = 1, y = 2 (바뀌지 않는다) */
    
    return 0;
}
```
왜 안 바뀔까?

10장에서 우리는 "함수의 작업대가 펼쳐졌다가 사라진다"는 관점을 배웠다. `main`의 작업대와 `swap_bad`의 작업대는 서로 다른 작업대다. 

**swap_bad의 작업대(메모리) 그림으로 보기**
```
[main 작업대]                    [swap_bad 작업대]
x : 1        ---(값 복사)--->    a : 1
y : 2        ---(값 복사)--->    b : 2
                                tmp : (선언 후 값 저장)
```
`swap_bad` 안에서 바뀌는 것은 `a`, `b`, `tmp` 뿐이다. 
`x`, `y`는 다른 작업대에 있어서 그대로 남는다. 

**swap_bad에서 값 변화 추적**

| 단계 | main의 x | main의 y | a | b | tmp |
| :--- | :---: | :---: | :---: | :---: | :---: |
| **호출 직후** | 1 | 2 | **1** | **2** | - |
| **tmp = a** | 1 | 2 | 1 | 2 | **1** |
| **a = b** | 1 | 2 | **2** | 2 | 1 |
| **b = tmp** | 1 | 2 | 2 | **1** | 1 |
| **return 후** | 1 | 2 | (사라짐) | (사라짐) | (사라짐) |

`swap_bad`는 자기 작업대 위의 복사본만 바꾼다.

### 11.1.2 배열은 왜 “원본이 바뀌는 것처럼” 보였나?
그런데 9~10장에서 배열은 다르게 보였다. 배열을 함수에 넘겨서 `a[0] = 999;` 같은 걸 하면, 호출한 쪽의 원본 배열이 실제로 바뀌었다.

10장에서 우리는 그 이유를 메모리 관점으로 정리했다.

> 배열은 너무 크다. 그래서 통째로 복사하는 대신, "배열의 시작 주소(위치 정보)" 딱 하나만 넘긴다.

비유하자면 이렇다.

- 변수 전달: 문서의 사본을 복사해서 준다. (수정해도 원본 불변)
- 배열 전달: 문서가 들어있는 금고의 위치(주소)와 열쇠를 준다. (직접 가서 원본 수정 가능)

> [!NOTE]
> 배열도 사실은 값을 복사해서 넘긴다. 다만 그 값이 주소 값이라서, 함수가 원본에 접근할 수 있을 뿐이다. 

### 11.1.3 포인터가 해결하는 문제
정리하면 이렇다.

- 값을 넘기면

  - 장점: 원본이 안전하다.
  - 단점: 원본을 직접 바꿀 수 없다.

- 주소를 넘기면

  - 장점: 원본에 접근하여 수정할 수 있다.
  - 단점: 실수하면 원본을 망가뜨릴 수 있다. (책임이 따른다)

포인터는 바로 이 **주소를 넘겨서 원본을 제어하는 방식**을 정식 문법으로 만든 도구다.


## 11.2 주소 연산자 `&`: "이 값은 어디에 있나?"

C언어에서 어떤 변수가 메모리 몇 번지에 살고 있는지 알아내는 연산자가 바로 `&`다.
(읽을 때는 "Address of", 즉 "~의 주소"라고 읽자.)

### 11.2.1 `&x`의 의미

```c
int x;

x = 10;

/* &x : 변수 x가 저장된 메모리 위치(주소) */
```

- `x`는 상자 안에 들어있는 값(10)을 달라는 뜻이다.
- `&x`는 상자가 놓여있는 위치(메모리 주소)를 알려달라는 뜻이다.

각 컴퓨터마다, 같은 컴퓨터에서도 프로그램이 실행될 때마다 메모리 주소 값은 달라질 수 있다. 중요한 것은 변수가 항상 메모리 어딘가에 자리를 잡고 있다는 사실이다. 프로그램이 실행되며 상자가 자리를 잡았을 때, `&`는 "이 상자가 있는 곳(좌표)"를 알려준다.

### 11.2.2 `&`는 아무 데나 붙일 수 없다

`&` 연산자를 쓰려면, 대상이 **메모리에 저장된 자리(칸)** 이어야 한다.

✅ 주소를 얻을 수 있는 것들 (메모리에 자리가 있음)

- 일반 변수: `&x` (이름표가 붙은 상자)
- 배열 원소: `&a[3]` (배열이라는 큰 상자의 세 번째 칸)

❌ 주소를 얻을 수 없는 것들 (메모리에 자리가 없음)

- 정수 상수: `&10`
  - `10`은 상자(변수)가 아니라 내용물 그 자체다. 내용물의 주소를 달라고 할 수는 없다.
- 계산 결과 (수식): `&(x + 1)`
  - `x + 1`은 계산하는 순간 잠시 생겼다가 사라지는 임시 값이다. 우리가 어느 상자에 담아둔 값으로 취급할 수 없다.

비유로 말하면,

- **변수 (`x`)**: 주소가 있는 집
- **값 (`10`, `x+1`)**: 그때그때 생기는 숫자(집이 아님)


## 11.3 포인터 변수 만들기: `int *p;`를 읽는 법

### 11.3.1 포인터란?
포인터(pointer)를 한 문장으로 말하면 이거다.

**주소를 담는 변수**

비유를 해보자면, 값이 들어있는 집이 아니라, 그 집으로 가는 **주소를 적어둔 상자**다.

### 11.3.2 포인터 선언: `int *p;`

```c
int *p;
```

이 선언은 이렇게 읽으면 된다.

"`p`는 `int`가 들어있는 상자의 주소를 담는다."

Q. 그냥 주소만 담으면 되는데, 왜 굳이 `int`를 앞에 붙일까?

10장에서 배웠듯이, 메모리 주소만 가지고는 "여기서부터 몇 칸을 읽어야 하는지" 알 수 없기 때문이다.

- `int *p`: "p가 가리키는 주소로 가서 값을 읽고 쓸 때는 `int` 규칙에 따르겠다는 약속."

타입은 주소에 도착해서 데이터를 어떻게 다룰지에 대한 해석 규칙이기 때문에 필요하다.

> [!TIP]
> 별의 위치는 상관 없다. `int *p;`, `int* p;`, `int * p;` 모두 똑같은 의미다.
> 그런데 초보자는 다음 함정에 자주 빠진다.
> ```c
> int* p, q;     /* q는 포인터가 아니다! q는 int 다 */
> ```
> 그래서 포인터는 한 줄에 하나씩 선언하는 습관이 안전하다.
> ```c
> int *p;
> int *q;
> ```

### 11.3.3 기본 연결: `p = &x;`

이제 포인터 변수 `p`와 실제 변수 `x`를 연결해보자. 

```c
int x = 10;    /* 정수형 변수 x 생성. (값 10 저장) */
int *p;        /* 포인터 변수 p 생성. (아직 값이 없다.)

p = &x;        /* x의 주소를 p에 대입 (연결!)
```

이제 `p` 안에는 `x`가 사는 집 주소가 들어 있다. 말로 표현하면 "`p`가 `x`를 가리킨다(point)"라고 한다. 

그림으로 보면 관계가 더 명확해진다. 

**메모리 상태 시뮬레이션 (가정)**
* `x`가 **100번지**에 살고 있다고 가정하자.
* `p`가 **200번지**에 살고 있다고 가정하자.

| 변수 이름 | 메모리 주소 | 들어있는 값 | 비고 |
| :--- | :--- | :--- | :--- |
| **x** | 100 | **10** | 실제 데이터 |
| **p** | 200 | **100** | x의 주소 |

**여기서 놓치면 안 되는 핵심:**
1. **`p`도 변수다:** `p` 또한 메모리 어딘가(200번지)에 자기 자리를 차지하고 있다.
2. **`p`의 값은 주소다:** `p`의 상자를 열어보면 `10`이 아니라 `100`(`x`의 주소)가 들어 있다.


## 11.4 역참조 연산자 `*`: "그 주소로 가서 값을 꺼낸다"

포인터 변수에 주소를 담는 것까지 성공했다. (`p = &x`)
이제 포인터의 존재 이유인 **주소를 이용해 건너편의 값을 조작하는 방법**을 배울 차례다.

이때 사용하는 연산자가 바로 `*`(별표)이며, 이를 **역참조(Dereference) 연산자**라고 부른다.
말이 어렵다면 이렇게 기억하자.

`*p`는 "`p`에 적힌 주소로 가서, 거기에 있는 값을 다룬다"는 뜻이다. 


### 11.4.1 `*p`의 의미 (읽기)

`p` 자체는 "주소"다. 
`*p`는 그 주소로 가서 만나는 "데이터"다.

```c
int x = 10;
int *p = &x;  // p가 x를 가리킴

int y = *p;   // "p에 적힌 주소로 가서 값을 가져와라"
              // 결과: y에는 10이 저장됨
```

메모리 그림 (주소 숫자는 예시다)

```
주소 1000:  x의 자리  [ 10 ]
주소 2000:  p의 자리  [1000]  ← p는 x의 주소(1000)를 들고 있다
```

여기서 `y = *p;`는 이런 느낌이다. 
- `p`를 열어본다 ... `1000 번지`
- `1000 번지`로 간다 ... 그 안의 값 `10`
- 그 `10`을 `y`에 저장한다

### 11.4.2 `*p`는 읽기만 하는게 아니다: "쓰기"도 된다 (중요!)

포인터가 진짜 강력해지는(그리고 위험해지는) 순간은 바로 **원본을 직접 바꿀 때**다. 

```c
int x = 10;
int *p = &x;

*p = 20;    /* "p가 가리키는 곳(x)으로 가서 20을 적어라" */
```

이 코드가 실행되면 변수 `x`의 이름은 한 번도 부르지 않았지만, `x`의 값은 20으로 바뀐다. 포인터의 마법, 원격 제어다. 

비유:
- `p`는 TV 리모컨이다.
- `*p`는 리모컨으로 조작하는 TV 화면이다.
- 리모컨(`p`)를 통해 TV 화면(`x`)를 바꿀 수 있다.

> [!WARNING]
> 역참조는 "전제조건"이 있다
>
> `*p`를 쓰려면, `p`가 반드시 유효한 대상의 주소를 가지고 있어야 한다.
>
> 다음 코드는 이면지를 찢어서 거기 적힌 주소로 가라는 말이라서 결과가 보장되지 않는다. (미정의 동작)
>
> ```c
> int *p;
> *p = 10; /* 위험: p가 어디를 가리키는지 모른다. */
> ```

### 11.4.3 [주의] 선언에서의 `*` vs 동작에서의 `*`

초보자가 가장 많이 혼란스러워하는 것이 바로 이 `*` 기호다.
**선언할 때**와 **사용할 때**의 의미가 완전히 다르니 꼭 구분해야 한다.

| 상황 | 코드 | 의미 | 역할 |
| :--- | :--- | :--- | :--- |
| **만들 때 (선언)** | `int *p;` | "나는 포인터 변수입니다." | **신분 표시** (변수 타입의 일부) |
| **쓸 때 (동작)** | `*p = 20;` | "주소를 타고 가세요." | **이동 명령** (역참조 연산자) |

비유하자면 이렇다.
* **선언할 때의 `*`**는 **경찰 뱃지**다. ("나 경찰이야"라고 신분을 밝힘)
* **사용할 때의 `*`**는 경찰이 **실제로 권한을 행사**하는 것이다. ("거기 멈춰!"라고 명령함)

---

### 11.4.4 `p`와 `*p` 헷갈리지 말기

마지막으로 한 번 더 정리하자.

* **`p` (주소):** 집의 주소. 이걸 바꾸면 가리키는 집(대상)이 바뀐다.
* **`*p` (값):** 집 안의 가구. 이걸 바꾸면 그 집의 내용물(원본 변수)이 바뀐다.

```c
int main(void)
{
    int x;
    int y;
    int *p;

    x = 10;
    y = 30;

    p = &x;     /* p에 저장된 주소: x */
    *p = 11;    /* p에 저장된 주소에 저장된 값: x를 11로 변경 */

    p = &y;     /* p에 저장된 주소: y */
    *p = 31;    /* p에 저장된 주소에 저장된 값: y를 31로 변경 */

    return 0;
}
```

## 11.5 포인터의 초기화: 가장 흔한 사고 3종 세트

포인터는 강력한 만큼, **안전장치가 거의 없다**.
정수 변수는 실수로 이상한 값을 넣으면 계산이 틀리고 말지만, 포인터는 실수하면 프로그램이 강제로 종료되거나, 메모리를 망가뜨리는 대형 사고로 이어진다.

초보자가 반드시 피해야 할 **포인터 사고 3가지**를 미리 확인하고 가자.

---

### 11.5.1 초기화하지 않은 포인터: "눈 가리고 총 쏘기"

변수를 선언만 하고 초기화하지 않으면 그 안에는 **알 수 없는 값**이 들어있다고 배웠다.
포인터도 똑같다.

```c
int *p;   /* p 안에는 알 수 없는 주소가 들어있다 */

*p = 10;  /* 으악! 어디에 10을 적는 거지? */
```
이 상태의 포인터를 **와일드 포인터(Wild Pointer)** 라고 부른다. 배열 범위 초과와 비슷하다.

- 내가 뭘 건드린 것 같긴 한데
- 어딘지 모르고 아무데나 낙서했다. 

초기화되지 않은 포인터 `p`는 값을 읽는 것도 위험하기 때문에 어떤 상태인지 확인할 방법도 없다. 

### 11.5.2 NULL 포인터: "가리키는 곳이 없음"

포인터가 당장 가리킬 대상이 없다면, **지금은 아무것도 가리키지 않는다**라고 명찰을 달아줘야 한다. C언어에서는 이를 `NULL` (또는 0)으로 표현한다.

포인터에 항상 적절한 주소나 `NULL`을 저장되어 있게 프로그래밍을 했다면, 포인터가 `NULL`이 아닌지만 확인하면, 적절한 주소가 저장되어 있음을 확신할 수 있다. 

참고로, `NULL`을 역참조(`*p`)하는 것은 미정의 동작이다. 대부분의 환경에서는 바로 프로그램 종료로 이어지지만, 반드시 그렇게 되어야 한다고 보장해주지 않는다.

```c
#include <stddef.h> /* 여기에 NULL이 무엇인지 정의되어 있다 */

int main()
{
    int *p = NULL;   /* "나는 아무것도 안 가리킨다"라고 명시 */
    
    /* 안전하게 사용하는 법 */
    if (p != NULL) {
        *p = 10;     /* 가리키는 대상이 있을 때만 접근한다 */
    }
}
```

핵심 규칙:
1. 포인터를 만들면, 정상적인 주소나 `NULL`이나 둘 중 하나로 반드시 초기화를 한다.
2. 포인터를 쓸 때는 `NULL`인지 아닌지 검사한다.

참고로, `NULL`에 접근해서 오류가 발생하는 것은 다행이다. (버그를 바로 찾을 수 있기 때문이다). 제일 무서운 건 1번 사고(와일드 포인터)처럼 엉뚱한 곳을 건드리고 조용히 넘어가는 것이다.

### 11.5.3 댕글링(Dangling): "철거된 집의 열쇠"

10장에서 **블록 `{ }`이 끝나면 그 안의 변수는 사라진다(반납된다)** 고 했다. 그런데 포인터가 그 사라진 변수의 주소를 계속 기억하고 있다면?

```c
#include <stddef.h>

int main()
{
    int *p;
    
    {
        int x = 10;
        p = &x;     /* p는 x의 주소를 저장 */
    } /* 여기서 x는 메모리에서 사라진다! */

    if (p != NULL) {    
        *p = 20;        /* 위험! 이미 사라진 x의 자리에 접근 시도 */
    }

    return 0;
}
```

이것을 **댕글링 포인터(Dangling Pointer)** 라고 한다. 마치 **철거된 집의 주소**를 들고 찾아가는 꼴이다.

그 자리에 이미 다른 변수가 입주했을 수도 있다.

`*p = 20`은 남의 집에 무단 침입해서 가구를 부수는 범죄(메모리 오염)가 된다.

그럼 어떻게 고쳐야 할까?

```c
#include <stddef.h>

int main()
{
    int *p;
    
    {
        int x = 10;
        p = &x;     /* p는 x의 주소를 저장 */
        /* ... */
        p = NULL;   /* p에서 x 주소 정보를 제거한다 */
    } /* 여기서 x는 메모리에서 사라진다! */

    p = NULL;       /* 여기서라도 p에서 x 주소 정보를 제거한다 */

    if (p != NULL) {    
        *p = 20;        /* 위험! 이미 사라진 x의 자리에 접근 시도 */
    }

    return 0;
}
```

집이 철거되기 전이나, 늦어도 철거된 직후에는 열쇠를 버린다. 애초에 열쇠를 가지고 나오지 않는 것도 방법이다. 

### 11.5.4 안전 수칙

선언과 동시에 초기화하라:

- 가리킬 곳이 있으면 `int *p = &x;`
- 가리킬 곳이 아직 없으면 `int *p = NULL;`

쓰기 전에 검사하라:

- `p != NULL` 확인은 최소 안전벨트다.
- 단, `p`가 `NULL`로 초기화되어있지 않았다면 검사도 위험할 수 있다.

없어진 주소는 잊어라:

- 블록/함수가 끝나면 지역 변수는 사라진다.
- 지역 변수의 주소를 블록 밖으로 유출하지 말자.


## 11.6 함수에 포인터 넘기기: 원본을 바꾸는 기술

이제 11장의 하이라이트다. 포인터를 배웠으니, 9장에서 해결하지 못했던 문제를 해결할 시간이다.

**주소를 넘기면, 함수가 내 허락 없이도(사실은 허락한 거지만) 내 방에 들어와서 가구를 바꿀 수 있다.**

이것을 전문 용어로 참조에 의한 호출(Call by Reference) **효과**라고 한다. (엄밀히 말하면 C는 항상 '값을 복사해서 전달'하지만, 그 값이 주소(포인터)일 때, 함수가 원본을 바꾸는 *참조 호출처럼 보이는 효과*가 생긴다!) 

### 11.6.1 진짜 swap: `swap_int(int *a, int *b)`

주소를 받아서 원본을 바꾸는 제대로 된 `swap` 함수를 만들어보자.

```c
/* 매개변수가 포인터(int*)다. 즉, 주소를 받겠다는 뜻이다. */
void swap_int(int *a, int *b)
{
    int tmp;

    tmp = *a;   /* 1. a가 가리키는 곳(x)의 값을 읽어온다 */
    *a = *b;    /* 2. b가 가리키는 값(y)을 a가 가리키는 곳(x)에 쓴다 */
    *b = tmp;   /* 3. tmp 값을 b가 가리키는 곳(y)에 쓴다 */
}

int main()
{
    int x = 1;
    int y = 2;

    /* 값(1, 2)이 아니라 주소(&x, &y)를 넘긴다 */
    swap_int(&x, &y);

    /* 잘못된 호출: swap_int(x, y); 인자의 타입이 틀리다. */

    /* 성공! x=2, y=1 */
    return 0;
}
```

**성공의 핵심:**
* `swap_int`는 `x`, `y`라는 변수 이름은 모른다.
* 하지만 `&x`(주소)를 `a`라는 리모컨에 담아왔다.
* `*a`를 건드리는 순간, 메인 함수에 있는 `x`가 바뀐다.

### [값 변화 추적]

| 단계 | main x | main y | a (가리키는 곳) | b (가리키는 곳) | 동작 |
| :--- | :---: | :---: | :---: | :---: | :--- |
| **호출 직후** | 1 | 2 | &x (1000번지) | &y (1004번지) | 주소 전달 완료 |
| **함수 내부** | **2** | **1** | &x | &y | `*a`, `*b`를 통해 원본 교체 |
| **리턴 후** | **2** | **1** | (사라짐) | (사라짐) | **원본이 바뀌어 있음!** |


### 11.6.2 출력 인자(Output Parameter): "결과를 담아오세요"

함수는 `return`으로 값을 하나만 반환할 수 있다는 한계가 있다.
하지만 포인터를 쓰면 **여러 개의 결과**를 얻어낼 수 있다.

> **"빈 그릇(변수)의 주소를 줄 테니, 여기에 결과를 담아줘."** 패턴이다.

#### 예제: 몫과 나머지를 한 번에 구하기 `divmod`

```c
#include <stddef.h>    

/*
 * 반환값(int): 성공하면 0, 0으로 나누면 -1 (에러 코드 역할)
 * 결과값: 포인터 q(몫)와 r(나머지)에 채워 넣음
 */
int divmod(int a, int b, int *q, int *r)
{
    if (b == 0) return -1; // 0으로 나누기 방어, 에러 코드 -1

    if (q != NULL) *q = a / b; // q라는 주소를 줬다면 몫을 쓴다
    if (r != NULL) *r = a % b; // r이라는 주소를 줬다면 나머지를 쓴다

    return 0; // 성공
}

int main()
{
    int mok, nameoji, ok;

    ok = divmod(10, 3, &mok, &nameoji);

    /*
     * ok에는 나누기 성공을 의미하는 0이 저장되어 있다.
     * mok에는 10 / 3의 결과인 3이 저장되어 있다.
     * nameoji에는 10 % 3의 결과인 1이 저장되어 있따.
     */

    return 0;
}
```

### 11.6.3 NULL 체크의 진짜 매력: "필요 없는 건 무시하기"

위의 `divmod` 코드에서 `if (q != NULL)` 체크를 넣은 것은 단순히 오류를 방지하기 위함만이 아니다.
이 덕분에 **함수를 훨씬 유연하게 쓸 수 있다.**

만약 나는 "몫"만 필요하고 "나머지"는 필요 없다면?

```c
int mok;
/* 나머지가 들어갈 자리에 NULL을 넣어버린다 */
divmod(10, 3, &mok, NULL);
```

함수 내부에서 `r`이 `NULL`이므로 `*r = ...` 부분은 실행되지 않고 안전하게 넘어간다.
이처럼 포인터 인자는 **옵션(선택 사항)** 을 처리할 때도 매우 유용하다.



## 11.7 배열과 포인터의 관계: 배열 이름은 왜 포인터처럼 보이나?

10장의 결론을 다시 꺼내보자.

> **배열의 이름은 크기 계산 연산 (`sizeof`)와 주소 연산 (`&`)을 제외한 대부분의 식에서 자동으로 첫 번째 칸의 시작 주소값처럼 사용된다.**

C 언어에서는 이 현상을 **배열의 포인터 퇴화(Array Decay)** 라고 부른다. 배열을 함수에 전달하면, 배열 전체가 복사되는 것이 아니라 시작 주소만 복사되어 전달되서 크기가 큰 배열도 아주 빠르게 함수로 넘길 수 있었고, 다른 연산에서도 같은 원칙이 적용된다.

```c
int nums[5] = {10, 20, 30, 40, 50};

/* 'nums'는 5개 int의 배열이다. */
/* 하지만, 다음 초기값을 구하는 식에서, 'nums'는 &nums[0]으로 퇴화한다. */
int *p = nums;
```

`int *p = nums;`에서 `p`의 초기값을 구하는데 쓰이는 `nums` 변수는 첫 번째 원소가 저장된 주소값으로 변환된다. 

### 11.7.1 함수 매개변수: `int a[]`는 사실 `int *a`다

함수의 매개변수 선언 부분에서만큼은 다음 세 표현이 **완전히 똑같다.**

```c
void func(int a[]); /* "나는 배열을 받을 거야" (사람을 위한 힌트 / 가장 흔한 표기) */
void func(int a[5]); /* "크기가 5인 배열?" (매개변수가 배열일 때 배열의 크기는 무시됨) */
void func(int *a);  /* "나는 주소를 받을 거야" (실제 컴파일러의 해석) */
```

컴파일러 입장에서 매개변수 자리에 있는 `int a[]`는 `int *a`를 배열처럼 보이게 써주는 표기일 뿐이다. 특히 주의할 점은 `int a[5]`라고 크기를 적어도, 컴파일러는 이 숫자를 무시한다는 점이다. 길이가 10인 배열을 넘겨도 아무런 에러가 나지 않는다. 

따라서 함수 안에서 `sizeof`를 계산해보면 배열의 크기가 아닌, 포인터의 크기가 나온다. 
```c
void func(int a[5])
{
    sizeof a; /* 이 식을 계산한 결과는 포인터의 크기가 된다. 32비트 시스템에서는 4, 64비트 시스템에서는 8이 출력된다. */
}
```

### 11.7.2 가장 큰 차이점: 저장된 값을 바꿀 수 있는지

"배열 이름도 주소고, 포인터도 주소라면 둘은 같은 건가?"
비슷하지만 **결정적인 차이**가 있다.

* **포인터 변수 (`int *p`):** 주소를 적은 **포스트잇**. 언제든 떼서 다른 주소를 적을 수 있다. (변수)
* **배열 이름 (`int arr[10]`):** 건물의 **머릿돌**. 건물이 지어질 때(선언될 때) 그 위치로 고정된다. 절대 바꿀 수 없다. (상수 주소)

```c
int arr[5];
int arr2[5];
int *p;

p = arr;    /* (O) 포스트잇(p)에 주소를 적는 건 자유 */
arr = arr2; /* (X) 머릿돌(arr)을 뽑아서 다른 곳에 옮길 수 없다 (컴파일 에러) */
```

퇴화된 배열 이름은 더 이상 변수가 아니고, 값을 바꿀 수 없는 주소값처럼 행동한다.

### 11.7.3 차이점: 크기 계산 연산 `sizeof`를 했을 때

10장에서 확인한 바와 같이 `sizeof` 연산을 했을 때 배열은 배열 전체의 크기(원소 크기 × 길이)가 나온다. 반면 포인터에 `sizeof` 연산을 하면 단순히 주소 변수의 크기가 나온다.

```c
int arr[5];
int *p;

sizeof arr;    /* int가 4 byte일 때, 결과는 20 (배열 전체) */
sizeof p;      /* 64비트 시스템에서 결과는 8 (주소 크기) */
```

### 11.7.4 차이점: 주소 연산 `&`를 했을 때

이 부분이 초보자가 가장 헷갈려하는 부분이다. 

- 포인터의 주소를 구하면, 포인터를 가리키는 포인터(이중 포인터)가 된다.
- 배열의 주소를 구하면, 배열 전체를 가리키는 포인터(배열 포인터)가 된다.

```c
int arr[5];
int *p = arr;

int (*ptr_arr)[5] = &arr;    /* 배열의 주소는 '배열을 가리키는 포인터 타입' */
int **pp = &p;               /* 포인터의 주소는 '포인터를 가리키는 포인터 타입' */
```

> [!NOTE]
> `arr` (첫 번째 칸의 주소)와 `&arr` (배열 전체의 주소)의 값 자체는 똑같다. 하지만 둘은 타입이 다르다. `arr + 1`은 `int` 하나 크기만큼 이동하지만, `&arr + 1`은 배열 전체 크기만큼 이동한다.

## 11.8 포인터 산술(Pointer Arithmetic): "+1"에서 1은 상자 하나다

`int *p`에서 `p + 1`을 하면 주소값이 어느만큼 늘어날까? **`p + 1`은 다음 상자로 이동한 주소를 계산한다**.
따라서, 실제 물리적인 주소값은 `int` 상자 하나 크기만큼 늘어난다.

### 11.8.1 그림으로 이해하기: "보폭(Stride)"이 다르다

포인터에게 `+1`은 **한 걸음 앞으로 가라**는 뜻이다. 여기서 **다리 길이(타입의 크기)** 에 따라 실제 이동 거리가 달라진다.

```c
int a[2] = {10, 20};
int *p = a;            /* &a[0] */
p + 1;                 /* &a[1]을 계산한 값 */
```

`a`의 메모리 번지수가 1000번지고, `p`의 메모리 번지수가 2000번지라고 가정하고 메모리를 들여다보자. (편의상 `int`는 4바이트, 포인터는 8바이트로 가정한다.)
```
이 4칸 묶음이 a[0]의 자리    이 4칸 묶음은 a[1]의 자리
__________________________  __________________________
 1000   1001   1002   1003   1004   1005   1006   1007  
[ 10]  [  0]  [  0]  [  0]  [ ? ]  [ ? ]  [ ? ]  [ ? ]  


이 8칸 묶음이 p (int* 타입)의 자리
______________________________________________________
 2000   2001   2002   2003   2004   2005   2006   2007  
[232]  [  3]  [  0]  [  0]  [  0]  [  0]  [  0]  [  0]
(※ 값 1000은 1바이트를 넘으므로, 232와 3으로 나뉘어 8칸 공간에 저장됨)
(※ 값이 바이트로 저장되는 모양/순서는 시스템마다 다를 수 있다)
```
이와 같은 메모리 상태에서 `p + 1`은 `int`의 크기만큼 옆으로 점프한 `1004`가 된다.

일반적으로, 포인터 `p`와 이동할 정도 `offset`에 대하여 `p + offset`이라고 명령하면, 컴퓨터는 내부적으로 다음과 같이 계산한다.

```math
계산된 주소 = p + (offset \times sizeof(*p))
```

여기서 타입을 모르면 보폭을 알 수 없기 때문에 포인터를 선언할 때 반드시 가리키는 타입을 `int *`처럼 명시하게 되어있다. 

### 11.8.2 포인터로 배열 합 구하기

인덱스 변수 `i`를 써서 `a[i]`와 같이 배열 원소에 접근하지 않고, 포인터만으로 배열을 훑는 코드를 짜보자.

```c
int main()
{
    int a[5] = {10, 20, 30, 40, 50};
    int sum = 0;
    int *p = a; /* p는 첫 번째 칸(&a[0])을 가리킨다 */

    int i;
    for (i = 0; i < 5; i = i + 1) {
        sum = sum + *p;  /* 1. 현재 p가 가리키는 값을 더한다 */
        p = p + 1;       /* 2. p를 다음 칸으로 이동시킨다 (int 크기만큼 점프) */
    }

    /* 루프 종료 후: */    
    /* sum: 150 */
    /* p: &a[5] (배열의 끝을 벗어난 위치를 가리킴) */

    return 0;
}
```

### 11.8.3 끝 포인터(End Pointer) 패턴: "문턱"을 기준으로 멈춘다

한 단계 더 나아가 보자. `i`라는 카운터 변수조차 없애버릴 수 있다. **"마지막 원소의 다음 칸"** 을 미리 계산해서 문턱으로 삼고, 포인터가 거기에 도달하면 멈추는 패턴이다.

```c
int main()
{
    int a[5] = { 10, 20, 30, 40, 50 };
    int sum = 0;
    
    int *p = a;         /* 시작점: &a[0] */
    int *end = a + 5;   /* 끝점(문턱): &a[5].
                           (유효한 인덱스는 0~4이므로, 5는 "끝난 직후"를 의미) */

    /* p가 문턱(end)에 도달하기 전까지 계속 전진 */
    for ( ; p < end; p = p + 1) {
        sum = sum + *p;
    }

    return 0;
}
```

**여기서 중요한 규칙 (Fence Post Rule):**

1. `end` (`a + 5`)는 실제 데이터가 아니라 "여기까지"를 나타내는 표지판이다.
2. `p < end`처럼 주소를 비교하는 것은 안전하고 올바른 코드다.
3. 하지만 `*end`처럼 내용을 열어보는 것(Dereference)는 절대 안된다. (내 땅이 아니므로 무슨 일이 일어날지 모른다.)

> [!NOTE]
> 포인터 덧셈/뺄셈과 비교 연산은, 포인터들이 "같은 배열"을 가리킬 때만 의미가 있다. 서로 다른 배열을 가리키는 포인터끼리 비교하는 것은 정의되지 않은 행동이다.


## 11.9 `a[i]`를 포인터 연산으로 분해하기

우리가 지금까지 썼던 배열의 대괄호 `[]`, C언어 표준에 따르면 `[]`는 포인터 연산을 보기 좋게 포장한 것으로 정의되어 있다. 

C언어 표준은 `E1[E2]`를 다음과 같이 정의한다. 

```math
E1[E2] \equiv (*(E1+(E2)))
```

여기서 `E1`이 배열의 이름이라면 첫번째 원소의 주소로 변환되고, `E2`가 정수라면, `E1 + (E2)`에서는 이전 장에서 봤던 "주소 + 정수" 연산이 수행된다. 전체 과정을 두 단계로 나눠보면, 

1. `E1 + E2`: 시작 주소에서 상자 `E2`개의 크기만큼 떨어진 곳의 주소를 계산한다.
2. `*(...)`: 그 주소로 가서 값을 가져온다(역참조).

### 11.9.1 같은 일을 두 방식으로 쓰기

이 원리를 알면, 배열을 다루는 두 가지 방식이 **완벽하게 똑같다**는 것을 알 수 있다.

```c
int main()
{
    int a[3] = { 10, 20, 30 };
    int *p = a;                     /* 시작점: &a[0] */

    /* 1. 익숙한 인덱스 방식 */
    a[1] = 40;                      /* 배열 a의 1번 인덱스 상자에 40을 저장한다. */

    /* 2. 포인터 연산 방식 */
    *(a + 1) = 50;                  /* 배열 a의 제일 앞에서 상자 1개 크기만큼 떨어진 주소에 50을 저장한다. */

    return 0;
}
```

> [!NOTE]
> 참고로, 역참조 연산자 `*`은 덧셈 연산자 `+`보다 우선순위가 높다.
>
> `*(a + 1)`이 주소를 1칸 이동한 뒤 값을 읽는 우리가 의도한 `a[1]`이다.
> 
> `*a + 1`이라고 쓰면 `*a`가 먼저 계산되서 `a[0]`를 얻고 여기에 `1`을 더해서, 결과적으로 `a[0] + 1`을 얻는다. 
 
### 11.9.2 재미있는 사실: 포인터에도 `[]`를 쓸 수 있다

많은 초보자가 **배열에만 `[]`를 쓸 수 있다**고 착각한다. 하지만 `[]`는 그저 `*( + )` 식을 짧게 쓴 것일 뿐이므로, **일반 포인터 변수에도 똑같이 쓸 수 있다.**

```c
int x = 10;
int *p = &x;

p[0] = 20;  /* 이 식은 *(p + 0) = 20; 과 똑같은 식이다. 정리하면 *p = 20; 과 완전이 같다. */
```

이 성질 덕분에 나중에 배울 **동적 할당(malloc)** 메모리도 마치 배열인 것처럼 편하게(`p[i]`) 다룰 수 있다.

### 11.9.3 \[충격 주의\] `i[a]`도 된다?

C언에서 포인터가 들어간 덧셈 `+`을 할 때, 피연산자 중에 하나는 포인터여야 하고, 다른 하나는 정수형이어야하지만, 순서는 상관 없다. 수학에서 $A + B = B + A$이듯이, C언어에서도 `pointer + int`나 `int + pointer`나 모두 유효하다. 

그렇다면... `a[i]` 대신 `i[a]`라고 써도 될까? 논리적 흐름을 따라가 보자. 

1. `a[i]`는 C 언어 표준에서의 정의에 따르면 `*(a + i)`와 동일하다.
2. 덧셈은 순서를 바꿔도 되므로, `*(a + i)`는 `*(i + a)`와 같다.
3. C 언어 표준에서의 정의에 따르면 `*(i + a)`는 `i[a]`와 동일하다. 

```c
int a[3] = { 10, 20, 30 };

1[a]; /* ??? */
```

**놀랍게도 `1[a]`는 `a[1]`과 같은 20이다**. C 언어 표준에서도 `E1[E2]`에서 `E1`과 `E2` 중 하나가 어떤 타입에 대한 포인터고, 다른 하나는 정수여야 한다고만 나와 있다.

> [!WARNING] 절대 따라하지 마세요
>
> `1[a]`는 문법적으로는 올바르지만, 사람이 읽기에는 최악의 코드다.
> 본 예제는 포인터 연산의 원리를 이해하기 위한 용도일 뿐, 실무에서 이렇게 쓰면 동료 프로그래머들에게 미움받을 것이다.
