# 11. 포인터: 값이 있는 곳을 가리키기

10장에서 우리는 **"값이 공중에 둥둥 떠 있는 게 아니다"**라는 사실을 확실히 알았다.
모든 데이터는 메모리라는 거대한 아파트의 **특정 호수(주소, address)** 칸에 저장된다.

하지만 10장까지는 여기서 멈췄다.

* 데이터에 주소가 있다는 **이론**은 알았지만,
* 그 주소를 **코드에서 직접 다루는 문법**은 배우지 않았다.
    (마치 맛집 주소는 알지만, 정작 찾아가는 길은 모르는 상태와 같다.)

11장에서는 드디어 그 '찾아가는 문법'을 배운다. 핵심은 이것이다.

> **"주소도 결국은 숫자 데이터(값)이다."**
> **그리고 그 주소 값을 저장하기 위해 만든 변수가 바로 포인터(pointer)다.**

포인터를 장착하면, 그동안 "그냥 외우세요"라고 했던 의문들이 한 번에 풀린다.

1.  함수에 `int`를 넘기면 왜 원본이 안 바뀌는가? (주소가 아니라 **값만 복사**해줬으니까)
2.  배열을 넘기면 왜 원본이 바뀌는가? (배열은 태생적으로 **주소를 전달**하니까)
3.  왜 C언어가 강력하면서도 위험한가? (메모리의 **정확한 주소**를 콕 집어서 조작할 수 있기 때문)

이제 메모리의 주소를 손에 쥐고 흔드는 C언어의 진짜 힘, 포인터의 세계로 들어가 보자.


## 11.0 이 장의 목표

이 장의 목표는 단순히 `*`나 `&` 같은 기호를 어디에 적는지 문법을 외우는 것이 아니다.
여러분의 머릿속에 **메모리 지도를 그리고, 자유자재로 이동할 수 있는 능력**을 만드는 것이 진짜 목표다.

코드를 볼 때 더 이상 글자만 보지 않고, 메모리 상자의 연결 관계가 그려져야 한다.

우리는 이 장을 통해 다음 단계들을 정복할 것이다.

**1. 도구 익히기: 주소를 다루는 새로운 문법**
* **주소 추출:** 변수가 살고 있는 위치를 알아내는 `&` 연산자
* **포인터 선언:** 그 주소를 저장하기 위한 전용 변수 `int *p`
* **간접 접근:** 주소를 타고 가서 실제 값을 읽고 쓰는 `*` 연산자

**2. 실전 응용: 한계를 돌파하기**
* **원격 제어:** 포인터를 이용해 함수 안에서 **외부 변수(원본)를 수정**하는 방법 (Swap 함수 완성)
* **배열의 정체:** 배열의 이름이 사실상 포인터처럼 행동하는 이유

**3. 안전하게 사용하기**
* **위험성 인지:** 포인터를 잘못 썼을 때 프로그램이 어떻게 망가지는지(미정의 동작)를 이해하고 예방하기

포인터를 이해하면 C언어의 절반을 넘은 것이다. 이제 시작해보자.


## 11.1 왜 포인터가 필요한가: 10장의 질문을 완성하기

### 11.1.1 “값만” 넘기면 생기는 한계

9장에서 함수 호출은 기본적으로 **값을 복사해서 전달(Call by Value)** 한다는 것을 배웠다.
그래서 함수 안에서 매개변수를 아무리 지지고 볶아도, 함수 밖의 원본은 바뀌지 않는다.

이 성질이 가장 뚜렷하게 드러나는 예제가 바로 `swap` 함수다.
두 변수의 값을 서로 바꾸는 함수를 만들고 싶을 때, 초보자는 보통 이렇게 코드를 짠다.

```c
void swap_bad(int a, int b)
{
    int tmp = a;
    a = b;
    b = tmp;
}

int main()
{
    int x = 1;
    int y = 2;

    swap_bad(x, y);

    /* 기대: x = 2, y = 1 */
    /* 현실: x = 1, y = 2 (바뀌지 않는다) */
    
    return 0;
}
```
왜 안 바뀔까?

10장에서 우리는 "함수의 작업대가 펼쳐졌다가 사라진다"는 관점을 배웠다. `main`의 작업대와 `swap_bad`의 작업대는 서로 다른 작업대다. 

**swap_bad의 작업대(메모리) 그림으로 보기**
```
[main 작업대]                    [swap_bad 작업대]
x : 1        ---(값 복사)--->    a : 1
y : 2        ---(값 복사)--->    b : 2
                                tmp : (선언 후 값 저장)
```
`swap_bad` 안에서 바뀌는 것은 `a`, `b`, `tmp` 뿐이다. 
`x`, `y`는 다른 작업대에 있어서 그대로 남는다. 

**swap_bad에서 값 변화 추적**

| 단계 | main의 x | main의 y | a | b | tmp |
| :--- | :---: | :---: | :---: | :---: | :---: |
| **호출 직후** | 1 | 2 | **1** | **2** | - |
| **tmp = a** | 1 | 2 | 1 | 2 | **1** |
| **a = b** | 1 | 2 | **2** | 2 | 1 |
| **b = tmp** | 1 | 2 | 2 | **1** | 1 |
| **return 후** | 1 | 2 | (사라짐) | (사라짐) | (사라짐) |

`swap_bad`는 자기 작업대 위의 복사본만 바꾼다.

### 11.1.2 배열은 왜 “원본이 바뀌는 것처럼” 보였나?
그런데 9~10장에서 배열은 다르게 보였다. 배열을 함수에 넘겨서 `a[0] = 999;` 같은 걸 하면, 호출한 쪽의 원본 배열이 실제로 바뀌었다.

10장에서 우리는 그 이유를 메모리 관점으로 정리했다.

> 배열은 너무 크다. 그래서 통째로 복사하는 대신, "배열의 시작 주소(위치 정보)" 딱 하나만 넘긴다.

비유하자면 이렇다.

- 변수 전달: 문서의 사본을 복사해서 준다. (수정해도 원본 불변)
- 배열 전달: 문서가 들어있는 금고의 위치(주소)와 열쇠를 준다. (직접 가서 원본 수정 가능)

> [!NOTE]
> 배열도 사실은 값을 복사해서 넘긴다. 다만 그 값이 주소 값이라서, 함수가 원본에 접근할 수 있을 뿐이다. 

### 11.1.3 포인터가 해결하는 문제
정리하면 이렇다.

- 값을 넘기면

  - 장점: 원본이 안전하다.
  - 단점: 원본을 직접 바꿀 수 없다.

- 주소를 넘기면

  - 장점: 원본에 접근하여 수정할 수 있다.
  - 단점: 실수하면 원본을 망가뜨릴 수 있다. (책임이 따른다)

포인터는 바로 이 **주소를 넘겨서 원본을 제어하는 방식**을 정식 문법으로 만든 도구다.


## 11.2 주소 연산자 `&`: "이 값은 어디에 있나?"

C언어에서 어떤 변수가 메모리 몇 번지에 살고 있는지 알아내는 연산자가 바로 `&`다.
(읽을 때는 "Address of", 즉 "~의 주소"라고 읽자.)

### 11.2.1 `&x`의 의미

```c
int x;

x = 10;

/* &x : 변수 x가 저장된 메모리 위치(주소) */
```

- `x`는 상자 안에 들어있는 값(10)을 달라는 뜻이다.
- `&x`는 상자가 놓여있는 위치(메모리 주소)를 알려달라는 뜻이다.

각 컴퓨터마다, 같은 컴퓨터에서도 프로그램이 실행될 때마다 메모리 주소 값은 달라질 수 있다. 중요한 것은 변수가 항상 메모리 어딘가에 자리를 잡고 있다는 사실이다. 프로그램이 실행되며 상자가 자리를 잡았을 때, `&`는 "이 상자가 있는 곳(좌표)"를 알려준다.

### 11.2.2 `&`는 아무 데나 붙일 수 없다

`&` 연산자를 쓰려면, 대상이 **메모리에 저장된 자리(칸)** 이어야 한다.

✅ 주소를 얻을 수 있는 것들 (메모리에 자리가 있음)

- 일반 변수: `&x` (이름표가 붙은 상자)
- 배열 원소: `&a[3]` (배열이라는 큰 상자의 세 번째 칸)

❌ 주소를 얻을 수 없는 것들 (메모리에 자리가 없음)

- 정수 상수: `&10`
  - `10`은 상자(변수)가 아니라 내용물 그 자체다. 내용물의 주소를 달라고 할 수는 없다.
- 계산 결과 (수식): `&(x + 1)`
  - `x + 1`은 계산하는 순간 잠시 생겼다가 사라지는 임시 값이다. 우리가 어느 상자에 담아둔 값으로 취급할 수 없다.

비유로 말하면,

- **변수 (`x`)**: 주소가 있는 집
- **값 (`10`, `x+1`)**: 그때그때 생기는 숫자(집이 아님)


## 11.3 포인터 변수 만들기: `int *p;`를 읽는 법

### 11.3.1 포인터란?
포인터(pointer)를 한 문장으로 말하면 이거다.

**주소를 담는 변수**

비유를 해보자면, 값이 들어있는 집이 아니라, 그 집으로 가는 **주소를 적어둔 상자**다.

### 11.3.2 포인터 선언: `int *p;`

```c
int *p;
```

이 선언은 이렇게 읽으면 된다.

"`p`는 `int`가 들어있는 상자의 주소를 담는다."

Q. 그냥 주소만 담으면 되는데, 왜 굳이 `int`를 앞에 붙일까?

10장에서 배웠듯이, 메모리 주소만 가지고는 "여기서부터 몇 칸을 읽어야 하는지" 알 수 없기 때문이다.

- `int *p`: "p가 가리키는 주소로 가서 값을 읽고 쓸 때는 `int` 규칙에 따르겠다는 약속."

타입은 주소에 도착해서 데이터를 어떻게 다룰지에 대한 해석 규칙이기 때문에 필요하다.

> [!TIP]
> 별의 위치는 상관 없다. `int *p;`, `int* p;`, `int * p;` 모두 똑같은 의미다.
> 그런데 초보자는 다음 함정에 자주 빠진다.
> ```c
> int* p, q;     /* q는 포인터가 아니다! q는 int 다 */
> ```
> 그래서 포인터는 한 줄에 하나씩 선언하는 습관이 안전하다.
> ```c
> int *p;
> int *q;
> ```

### 11.3.3 기본 연결: `p = &x;`

이제 포인터 변수 `p`와 실제 변수 `x`를 연결해보자. 

```c
int x = 10;    /* 정수형 변수 x 생성. (값 10 저장) */
int *p;        /* 포인터 변수 p 생성. (아직 값이 없다.)

p = &x;        /* x의 주소를 p에 대입 (연결!)
```

이제 `p` 안에는 `x`가 사는 집 주소가 들어 있다. 말로 표현하면 "`p`가 `x`를 가리킨다(point)"라고 한다. 

그림으로 보면 관계가 더 명확해진다. 

**메모리 상태 시뮬레이션 (가정)**
* `x`가 **100번지**에 살고 있다고 가정하자.
* `p`가 **200번지**에 살고 있다고 가정하자.

| 변수 이름 | 메모리 주소 | 들어있는 값 | 비고 |
| :--- | :--- | :--- | :--- |
| **x** | 100 | **10** | 실제 데이터 |
| **p** | 200 | **100** | x의 주소 |

**여기서 놓치면 안 되는 핵심:**
1. **`p`도 변수다:** `p` 또한 메모리 어딘가(200번지)에 자기 자리를 차지하고 있다.
2. **`p`의 값은 주소다:** `p`의 상자를 열어보면 `10`이 아니라 `100`(`x`의 주소)가 들어 있다.


## 11.4 역참조 연산자 `*`: "그 주소로 가서 값을 꺼낸다"

포인터 변수에 주소를 담는 것까지 성공했다. (`p = &x`)
이제 포인터의 존재 이유인 **주소를 이용해 건너편의 값을 조작하는 방법**을 배울 차례다.

이때 사용하는 연산자가 바로 **`*` (별표)**이며, 이를 **역참조(Dereference) 연산자**라고 부른다.
말이 어렵다면 **주소 타고 가기**라고 기억하자.

### 11.4.1 `*p`의 의미

- **`p`** : 주소 (예: 1000번지)
- **`*p`** : 그 주소로 **이동해서 만난 값** (예: 1000번지 안에 있는 데이터)

```c
int x = 10;
int *p = &x;  // p가 x를 가리킴

int y = *p;   // "p에 적힌 주소로 가서 값을 가져와라"
              // 결과: y에는 10이 저장됨
```

### 11.4.2 `*p`는 읽기만 하는게 아니다: "쓰기"도 된다 (중요!)

포인터가 진짜 강력해지는(그리고 위험해지는) 순간은 바로 **값을 변경할 때**다. 

```c
int x = 10;
int *p = &x;

*p = 20;    /* "p가 가리키는 곳(x)으로 가서 20을 적어라" */
```

이 코드가 실행되면 변수 `x`의 이름은 한 번도 부르지 않았지만, `x`의 값은 20으로 바뀐다. 포인터의 마법, 원격 제어다. 

비유:
- `p`는 TV 리모컨이다.
- `*p`는 리모컨으로 조작하는 TV 화면이다.
- 리모컨(`p`)를 통해 TV 화면(`x`)를 바꿀 수 있다.

### 11.4.3 [주의] 만들 때의 `*` vs 쓸 때의 `*`

초보자가 가장 많이 혼란스러워하는 것이 바로 이 `*` 기호다.
**선언할 때**와 **사용할 때**의 의미가 완전히 다르니 꼭 구분해야 한다.

| 상황 | 코드 | 의미 | 역할 |
| :--- | :--- | :--- | :--- |
| **만들 때 (선언)** | `int *p;` | "나는 포인터 변수입니다." | **신분 표시** (변수 타입의 일부) |
| **쓸 때 (동작)** | `*p = 20;` | "주소를 타고 가세요." | **이동 명령** (역참조 연산자) |

비유하자면 이렇다.
* **선언할 때의 `*`**는 **경찰 뱃지**다. ("나 경찰이야"라고 신분을 밝힘)
* **사용할 때의 `*`**는 경찰이 **실제로 권한을 행사**하는 것이다. ("거기 멈춰!"라고 명령함)

---

### 11.4.4 `p`와 `*p` 헷갈리지 말기

마지막으로 한 번 더 정리하자.

* **`p` (주소):** 집의 주소. 이걸 바꾸면 가리키는 집(대상)이 바뀐다.
* **`*p` (값):** 집 안의 가구. 이걸 바꾸면 그 집의 내용물(원본 변수)이 바뀐다.

```c
p = &y;  // p가 이제 y를 가리킴 (타겟 변경)
*p = 30; // p가 가리키는 곳(지금은 y)의 값을 30으로 바꿈 (내용 변경)
```

## 11.5 포인터의 초기화: 가장 흔한 사고 3종 세트

포인터는 강력한 만큼, **안전장치가 거의 없다**.
정수 변수는 실수로 이상한 값을 넣으면 계산이 틀리고 말지만, 포인터는 실수하면 프로그램이 강제로 종료되거나, 메모리를 망가뜨리는 대형 사고로 이어진다.

초보자가 반드시 피해야 할 **포인터 사고 3가지**를 미리 확인하고 가자.

---

### 11.5.1 초기화하지 않은 포인터: "눈 가리고 총 쏘기"

변수를 선언만 하고 초기화하지 않으면 그 안에는 **알 수 없는 값**이 들어있다고 배웠다.
포인터도 똑같다.

```c
int *p;   /* p 안에는 알 수 없는 주소가 들어있다 */

*p = 10;  /* 으악! 어디에 10을 적는 거지? */
```
이 상태의 포인터를 **와일드 포인터(Wild Pointer)** 라고 부른다. 마치 눈을 가리고 아무 데나 총을 쏘는 것과 같다.

운 좋게 아무도 없는 허공을 쏠 수도 있지만,

운 나쁘게 중요한 시스템 메모리를 맞춰서 프로그램을 즉사시킬 수도 있다.

11.5.2 (사고 2) NULL 포인터: “가리키는 곳이 없음”
포인터가 당장 가리킬 대상이 없다면, **"지금은 아무것도 가리키지 않는다"**라고 명찰을 달아줘야 한다. C언어에서는 이를 NULL (또는 0)로 표현한다.

C
#include <stdio.h> // NULL을 쓰기 위해 필요

int *p = NULL;   /* "나는 아무것도 안 가리킨다"라고 명시 */

// *p = 10;      /* (에러) NULL인 곳에는 값을 쓸 수 없다. 프로그램이 죽는다. */

/* 안전하게 사용하는 법 */
if (p != NULL) {
    *p = 10;     /* 가리키는 대상이 있을 때만 접근한다 */
}
핵심 규칙:

"포인터가 NULL인지 아닌지 검사하는 습관이 프로그램을 살린다."

참고로, NULL에 접근해서 프로그램이 죽는 것은 차라리 다행이다. (버그를 바로 찾을 수 있으니까). 제일 무서운 건 1번 사고(와일드 포인터)처럼 엉뚱한 곳을 건드리고 조용히 넘어가는 것이다.

11.5.3 (사고 3) 댕글링(Dangling): “철거된 집의 열쇠”
10장에서 **블록 { }가 끝나면 그 안의 변수는 사라진다(반납된다)**고 했다. 그런데 포인터가 그 사라진 변수의 주소를 계속 기억하고 있다면?

C
int *p;

{
    int x = 10;
    p = &x;     /* p는 x의 주소를 저장 */
} /* 여기서 x는 메모리에서 사라진다! */

*p = 20;        /* 위험! 이미 사라진 x의 자리에 접근 시도 */
이것을 **댕글링 포인터(Dangling Pointer)**라고 한다. 마치 **"철거된 집의 주소"**를 들고 찾아가는 꼴이다.

그 자리에 이미 다른 변수가 입주했을 수도 있다.

*p = 20은 남의 집에 무단 침입해서 가구를 부수는 범죄(메모리 오염)가 된다.

11.5.4 안전 수칙 (생존 가이드)
선언과 동시에 초기화하라:

가리킬 곳이 있으면 int *p = &x;

없으면 int *p = NULL; (일단 NULL로 막아두기)

쓰기 전에 검사하라:

습관적으로 if (p != NULL)을 확인하라.

죽은 주소는 잊어라:

지역 변수의 주소를 블록 밖으로 유출하지 말자.
