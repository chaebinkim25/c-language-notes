# 11. 포인터: 값이 있는 곳을 가리키기

10장에서 우리는 **"값이 공중에 둥둥 떠 있는 게 아니다"**라는 사실을 확실히 알았다.
모든 데이터는 메모리라는 거대한 아파트의 **특정 호수(주소, address)** 칸에 저장된다.

하지만 10장까지는 여기서 멈췄다.

* 데이터에 주소가 있다는 **이론**은 알았지만,
* 그 주소를 **코드에서 직접 다루는 문법**은 배우지 않았다.
    (마치 맛집 주소는 알지만, 정작 찾아가는 길은 모르는 상태와 같다.)

11장에서는 드디어 그 '찾아가는 문법'을 배운다. 핵심은 이것이다.

> **"주소도 결국은 숫자 데이터(값)이다."**
> **그리고 그 주소 값을 저장하기 위해 만든 변수가 바로 포인터(pointer)다.**

포인터를 장착하면, 그동안 "그냥 외우세요"라고 했던 의문들이 한 번에 풀린다.

1.  함수에 `int`를 넘기면 왜 원본이 안 바뀌는가? (주소가 아니라 **값만 복사**해줬으니까)
2.  배열을 넘기면 왜 원본이 바뀌는가? (배열은 태생적으로 **주소를 전달**하니까)
3.  왜 C언어가 강력하면서도 위험한가? (메모리의 **정확한 주소**를 콕 집어서 조작할 수 있기 때문)

이제 메모리의 주소를 손에 쥐고 흔드는 C언어의 진짜 힘, 포인터의 세계로 들어가 보자.


## 11.0 이 장의 목표

이 장의 목표는 단순히 `*`나 `&` 같은 기호를 어디에 적는지 문법을 외우는 것이 아니다.
여러분의 머릿속에 **메모리 지도를 그리고, 자유자재로 이동할 수 있는 능력**을 만드는 것이 진짜 목표다.

코드를 볼 때 더 이상 글자만 보지 않고, 메모리 상자의 연결 관계가 그려져야 한다.

우리는 이 장을 통해 다음 단계들을 정복할 것이다.

**1. 도구 익히기: 주소를 다루는 새로운 문법**
* **주소 추출:** 변수가 살고 있는 위치를 알아내는 `&` 연산자
* **포인터 선언:** 그 주소를 저장하기 위한 전용 변수 `int *p`
* **간접 접근:** 주소를 타고 가서 실제 값을 읽고 쓰는 `*` 연산자

**2. 실전 응용: 한계를 돌파하기**
* **원격 제어:** 포인터를 이용해 함수 안에서 **외부 변수(원본)를 수정**하는 방법 (Swap 함수 완성)
* **배열의 정체:** 배열의 이름이 사실상 포인터처럼 행동하는 이유

**3. 안전하게 사용하기**
* **위험성 인지:** 포인터를 잘못 썼을 때 프로그램이 어떻게 망가지는지(미정의 동작)를 이해하고 예방하기

포인터를 이해하면 C언어의 절반을 넘은 것이다. 이제 시작해보자.


## 11.1 왜 포인터가 필요한가: 10장의 질문을 완성하기

### 11.1.1 “값만” 넘기면 생기는 한계

9장에서 함수 호출은 기본적으로 **값을 복사해서 전달(Call by Value)** 한다는 것을 배웠다.
그래서 함수 안에서 매개변수를 아무리 지지고 볶아도, 함수 밖의 원본은 바뀌지 않는다.

이 성질이 가장 뚜렷하게 드러나는 예제가 바로 `swap` 함수다.
두 변수의 값을 서로 바꾸는 함수를 만들고 싶을 때, 초보자는 보통 이렇게 코드를 짠다.

```c
void swap_bad(int a, int b)
{
    int tmp = a;
    a = b;
    b = tmp;
}

int main()
{
    int x = 1;
    int y = 2;

    swap_bad(x, y);

    /* 기대: x = 2, y = 1 */
    /* 현실: x = 1, y = 2 (바뀌지 않는다) */
    
    return 0;
}
```
왜 안 바뀔까?

10장에서 우리는 "함수의 작업대가 펼쳐졌다가 사라진다"는 관점을 배웠다. `main`의 작업대와 `swap_bad`의 작업대는 서로 다른 작업대다. 

**swap_bad의 작업대(메모리) 그림으로 보기**
```
[main 작업대]                    [swap_bad 작업대]
x : 1        ---(값 복사)--->    a : 1
y : 2        ---(값 복사)--->    b : 2
                                tmp : (선언 후 값 저장)
```
`swap_bad` 안에서 바뀌는 것은 `a`, `b`, `tmp` 뿐이다. 
`x`, `y`는 다른 작업대에 있어서 그대로 남는다. 

**swap_bad에서 값 변화 추적**

| 단계 | main의 x | main의 y | a | b | tmp |
| :--- | :---: | :---: | :---: | :---: | :---: |
| **호출 직후** | 1 | 2 | **1** | **2** | - |
| **tmp = a** | 1 | 2 | 1 | 2 | **1** |
| **a = b** | 1 | 2 | **2** | 2 | 1 |
| **b = tmp** | 1 | 2 | 2 | **1** | 1 |
| **return 후** | 1 | 2 | (사라짐) | (사라짐) | (사라짐) |

`swap_bad`는 자기 작업대 위의 복사본만 바꾼다.

### 11.1.2 배열은 왜 “원본이 바뀌는 것처럼” 보였나?
그런데 9~10장에서 배열은 다르게 보였다. 배열을 함수에 넘겨서 `a[0] = 999;` 같은 걸 하면, 호출한 쪽의 원본 배열이 실제로 바뀌었다.

10장에서 우리는 그 이유를 메모리 관점으로 정리했다.

> 배열은 너무 크다. 그래서 통째로 복사하는 대신, "배열의 시작 주소(위치 정보)" 딱 하나만 넘긴다.

비유하자면 이렇다.

- 변수 전달: 문서의 사본을 복사해서 준다. (수정해도 원본 불변)
- 배열 전달: 문서가 들어있는 금고의 위치(주소)와 열쇠를 준다. (직접 가서 원본 수정 가능)

> [!NOTE]
> 배열도 사실은 값을 복사해서 넘긴다. 다만 그 값이 주소 값이라서, 함수가 원본에 접근할 수 있을 뿐이다. 

### 11.1.3 포인터가 해결하는 문제
정리하면 이렇다.

- 값을 넘기면

  - 장점: 원본이 안전하다.
  - 단점: 원본을 직접 바꿀 수 없다.

- 주소를 넘기면

  - 장점: 원본에 접근하여 수정할 수 있다.
  - 단점: 실수하면 원본을 망가뜨릴 수 있다. (책임이 따른다)

포인터는 바로 이 **주소를 넘겨서 원본을 제어하는 방식**을 정식 문법으로 만든 도구다.


## 11.2 주소 연산자 `&`: "이 값은 어디에 있나?"

C언어에서 어떤 변수가 메모리 몇 번지에 살고 있는지 알아내는 연산자가 바로 `&`다.
(읽을 때는 "Address of", 즉 "~의 주소"라고 읽자.)

### 11.2.1 `&x`의 의미

```c
int x;

x = 10;

/* &x : 변수 x가 저장된 메모리 위치(주소) */
```

- `x`는 상자 안에 들어있는 값(10)을 달라는 뜻이다.
- `&x`는 상자가 놓여있는 위치(메모리 주소)를 알려달라는 뜻이다.

각 컴퓨터마다, 같은 컴퓨터에서도 프로그램이 실행될 때마다 메모리 주소 값은 달라질 수 있다. 중요한 것은 변수가 항상 메모리 어딘가에 자리를 잡고 있다는 사실이다. 프로그램이 실행되며 상자가 자리를 잡았을 때, `&`는 "이 상자가 있는 곳(좌표)"를 알려준다.

### 11.2.2 `&`는 아무 데나 붙일 수 없다

`&` 연산자를 쓰려면, 대상이 **메모리에 저장된 자리(칸)** 이어야 한다.

✅ 주소를 얻을 수 있는 것들 (메모리에 자리가 있음)

- 일반 변수: `&x` (이름표가 붙은 상자)
- 배열 원소: `&a[3]` (배열이라는 큰 상자의 세 번째 칸)

❌ 주소를 얻을 수 없는 것들 (메모리에 자리가 없음)

- 정수 상수: `&10`
  - `10`은 상자(변수)가 아니라 내용물 그 자체다. 내용물의 주소를 달라고 할 수는 없다.
- 계산 결과 (수식): `&(x + 1)`
  - `x + 1`은 계산하는 순간 잠시 생겼다가 사라지는 임시 값이다. 우리가 어느 상자에 담아둔 값으로 취급할 수 없다.

비유로 말하면,

- **변수 (`x`)**: 주소가 있는 집
- **값 (`10`, `x+1`)**: 그때그때 생기는 숫자(집이 아님)


## 11.3 포인터 변수 만들기: `int *p;`를 읽는 법

### 11.3.1 포인터란?
포인터(pointer)를 한 문장으로 말하면 이거다.

**주소를 담는 변수**

비유를 해보자면, 값이 들어있는 집이 아니라, 그 집으로 가는 **주소를 적어둔 상자**다.

### 11.3.2 포인터 선언: `int *p;`

```c
int *p;
```

이 선언은 이렇게 읽으면 된다.

"`p`는 `int`가 들어있는 상자의 주소를 담는다."

Q. 그냥 주소만 담으면 되는데, 왜 굳이 `int`를 앞에 붙일까?

10장에서 배웠듯이, 메모리 주소만 가지고는 "여기서부터 몇 칸을 읽어야 하는지" 알 수 없기 때문이다.

- `int *p`: "p가 가리키는 주소로 가서 값을 읽고 쓸 때는 `int` 규칙에 따르겠다는 약속."

타입은 주소에 도착해서 데이터를 어떻게 다룰지에 대한 해석 규칙이기 때문에 필요하다.

> [!TIP]
> 별의 위치는 상관 없다. `int *p;`, `int* p;`, `int * p;` 모두 똑같은 의미다.
> 그런데 초보자는 다음 함정에 자주 빠진다.
> ```c
> int* p, q;     /* q는 포인터가 아니다! q는 int 다 */
> ```
> 그래서 포인터는 한 줄에 하나씩 선언하는 습관이 안전하다.
> ```c
> int *p;
> int *q;
> ```

### 11.3.3 기본 연결: `p = &x;`

이제 포인터 변수 `p`와 실제 변수 `x`를 연결해보자. 

```c
int x = 10;    /* 정수형 변수 x 생성. (값 10 저장) */
int *p;        /* 포인터 변수 p 생성. (아직 값이 없다.)

p = &x;        /* x의 주소를 p에 대입 (연결!)
```

이제 `p` 안에는 `x`가 사는 집 주소가 들어 있다. 말로 표현하면 "`p`가 `x`를 가리킨다(point)"라고 한다. 

그림으로 보면 관계가 더 명확해진다. 

**메모리 상태 시뮬레이션 (가정)**
* `x`가 **100번지**에 살고 있다고 가정하자.
* `p`가 **200번지**에 살고 있다고 가정하자.

| 변수 이름 | 메모리 주소 | 들어있는 값 | 비고 |
| :--- | :--- | :--- | :--- |
| **x** | 100 | **10** | 실제 데이터 |
| **p** | 200 | **100** | x의 주소 |

**여기서 놓치면 안 되는 핵심:**
1. **`p`도 변수다:** `p` 또한 메모리 어딘가(200번지)에 자기 자리를 차지하고 있다.
2. **`p`의 값은 주소다:** `p`의 상자를 열어보면 `10`이 아니라 `100`(`x`의 주소)가 들어 있다.


## 11.4 역참조 연산자 `*`: "그 주소로 가서 값을 꺼낸다"

포인터 변수에 주소를 담는 것까지 성공했다. (`p = &x`)
이제 포인터의 존재 이유인 **주소를 이용해 건너편의 값을 조작하는 방법**을 배울 차례다.

이때 사용하는 연산자가 바로 `*`(별표)이며, 이를 **역참조(Dereference) 연산자**라고 부른다.
말이 어렵다면 이렇게 기억하자.

`*p`는 "`p`에 적힌 주소로 가서, 거기에 있는 값을 다룬다"는 뜻이다. 


### 11.4.1 `*p`의 의미 (읽기)

`p` 자체는 "주소"다. 
`*p`는 그 주소로 가서 만나는 "데이터"다.

```c
int x = 10;
int *p = &x;  // p가 x를 가리킴

int y = *p;   // "p에 적힌 주소로 가서 값을 가져와라"
              // 결과: y에는 10이 저장됨
```

메모리 그림 (주소 숫자는 예시다)

```
주소 1000:  x의 자리  [ 10 ]
주소 2000:  p의 자리  [1000]  ← p는 x의 주소(1000)를 들고 있다
```

여기서 `y = *p;`는 이런 느낌이다. 
- `p`를 열어본다 ... `1000 번지`
- `1000 번지`로 간다 ... 그 안의 값 `10`
- 그 `10`을 `y`에 저장한다

### 11.4.2 `*p`는 읽기만 하는게 아니다: "쓰기"도 된다 (중요!)

포인터가 진짜 강력해지는(그리고 위험해지는) 순간은 바로 **원본을 직접 바꿀 때**다. 

```c
int x = 10;
int *p = &x;

*p = 20;    /* "p가 가리키는 곳(x)으로 가서 20을 적어라" */
```

이 코드가 실행되면 변수 `x`의 이름은 한 번도 부르지 않았지만, `x`의 값은 20으로 바뀐다. 포인터의 마법, 원격 제어다. 

비유:
- `p`는 TV 리모컨이다.
- `*p`는 리모컨으로 조작하는 TV 화면이다.
- 리모컨(`p`)를 통해 TV 화면(`x`)를 바꿀 수 있다.

> [!WARNING]
> 역참조는 "전제조건"이 있다
>
> `*p`를 쓰려면, `p`가 반드시 유효한 대상의 주소를 가지고 있어야 한다.
>
> 다음 코드는 이면지를 찢어서 거기 적힌 주소로 가라는 말이라서 결과가 보장되지 않는다. (미정의 동작)
>
> ```c
> int *p;
> *p = 10; /* 위험: p가 어디를 가리키는지 모른다. */
> ```

### 11.4.3 [주의] 선언에서의 `*` vs 동작에서의 `*`

초보자가 가장 많이 혼란스러워하는 것이 바로 이 `*` 기호다.
**선언할 때**와 **사용할 때**의 의미가 완전히 다르니 꼭 구분해야 한다.

| 상황 | 코드 | 의미 | 역할 |
| :--- | :--- | :--- | :--- |
| **만들 때 (선언)** | `int *p;` | "나는 포인터 변수입니다." | **신분 표시** (변수 타입의 일부) |
| **쓸 때 (동작)** | `*p = 20;` | "주소를 타고 가세요." | **이동 명령** (역참조 연산자) |

비유하자면 이렇다.
* **선언할 때의 `*`**는 **경찰 뱃지**다. ("나 경찰이야"라고 신분을 밝힘)
* **사용할 때의 `*`**는 경찰이 **실제로 권한을 행사**하는 것이다. ("거기 멈춰!"라고 명령함)

---

### 11.4.4 `p`와 `*p` 헷갈리지 말기

마지막으로 한 번 더 정리하자.

* **`p` (주소):** 집의 주소. 이걸 바꾸면 가리키는 집(대상)이 바뀐다.
* **`*p` (값):** 집 안의 가구. 이걸 바꾸면 그 집의 내용물(원본 변수)이 바뀐다.

```c
int main(void)
{
    int x;
    int y;
    int *p;

    x = 10;
    y = 30;

    p = &x;     /* p에 저장된 주소: x */
    *p = 11;    /* p에 저장된 주소에 저장된 값: x를 11로 변경 */

    p = &y;     /* p에 저장된 주소: y */
    *p = 31;    /* p에 저장된 주소에 저장된 값: y를 31로 변경 */

    return 0;
}
```

## 11.5 포인터의 초기화: 가장 흔한 사고 3종 세트

포인터는 강력한 만큼, **안전장치가 거의 없다**.
정수 변수는 실수로 이상한 값을 넣으면 계산이 틀리고 말지만, 포인터는 실수하면 프로그램이 강제로 종료되거나, 메모리를 망가뜨리는 대형 사고로 이어진다.

초보자가 반드시 피해야 할 **포인터 사고 3가지**를 미리 확인하고 가자.

---

### 11.5.1 초기화하지 않은 포인터: "눈 가리고 총 쏘기"

변수를 선언만 하고 초기화하지 않으면 그 안에는 **알 수 없는 값**이 들어있다고 배웠다.
포인터도 똑같다.

```c
int *p;   /* p 안에는 알 수 없는 주소가 들어있다 */

*p = 10;  /* 으악! 어디에 10을 적는 거지? */
```
이 상태의 포인터를 **와일드 포인터(Wild Pointer)** 라고 부른다. 배열 범위 초과와 비슷하다.

- 내가 뭘 건드린 것 같긴 한데
- 어딘지 모르고 아무데나 낙서했다. 

초기화되지 않은 포인터 `p`는 값을 읽는 것도 위험하기 때문에 어떤 상태인지 확인할 방법도 없다. 

### 11.5.2 NULL 포인터: "가리키는 곳이 없음"

포인터가 당장 가리킬 대상이 없다면, **지금은 아무것도 가리키지 않는다**라고 명찰을 달아줘야 한다. C언어에서는 이를 `NULL` (또는 0)으로 표현한다.

포인터에 항상 적절한 주소나 `NULL`을 저장되어 있게 프로그래밍을 했다면, 포인터가 `NULL`이 아닌지만 확인하면, 적절한 주소가 저장되어 있음을 확신할 수 있다. 

참고로, `NULL`을 역참조(`*p`)하는 것은 미정의 동작이다. 대부분의 환경에서는 바로 프로그램 종료로 이어지지만, 반드시 그렇게 되어야 한다고 보장해주지 않는다.

```c
#include <stddef.h> /* 여기에 NULL이 무엇인지 정의되어 있다 */

int main()
{
    int *p = NULL;   /* "나는 아무것도 안 가리킨다"라고 명시 */
    
    /* 안전하게 사용하는 법 */
    if (p != NULL) {
        *p = 10;     /* 가리키는 대상이 있을 때만 접근한다 */
    }
}
```

핵심 규칙:
1. 포인터를 만들면, 정상적인 주소나 `NULL`이나 둘 중 하나로 반드시 초기화를 한다.
2. 포인터를 쓸 때는 `NULL`인지 아닌지 검사한다.

참고로, `NULL`에 접근해서 오류가 발생하는 것은 다행이다. (버그를 바로 찾을 수 있기 때문이다). 제일 무서운 건 1번 사고(와일드 포인터)처럼 엉뚱한 곳을 건드리고 조용히 넘어가는 것이다.

### 11.5.3 댕글링(Dangling): "철거된 집의 열쇠"

10장에서 **블록 `{ }`이 끝나면 그 안의 변수는 사라진다(반납된다)** 고 했다. 그런데 포인터가 그 사라진 변수의 주소를 계속 기억하고 있다면?

```c
#include <stddef.h>

int main()
{
    int *p;
    
    {
        int x = 10;
        p = &x;     /* p는 x의 주소를 저장 */
    } /* 여기서 x는 메모리에서 사라진다! */

    if (p != NULL) {    
        *p = 20;        /* 위험! 이미 사라진 x의 자리에 접근 시도 */
    }

    return 0;
}
```

이것을 **댕글링 포인터(Dangling Pointer)** 라고 한다. 마치 **철거된 집의 주소**를 들고 찾아가는 꼴이다.

그 자리에 이미 다른 변수가 입주했을 수도 있다.

`*p = 20`은 남의 집에 무단 침입해서 가구를 부수는 범죄(메모리 오염)가 된다.

그럼 어떻게 고쳐야 할까?

```c
#include <stddef.h>

int main()
{
    int *p;
    
    {
        int x = 10;
        p = &x;     /* p는 x의 주소를 저장 */
        /* ... */
        p = NULL;   /* p에서 x 주소 정보를 제거한다 */
    } /* 여기서 x는 메모리에서 사라진다! */

    p = NULL;       /* 여기서라도 p에서 x 주소 정보를 제거한다 */

    if (p != NULL) {    
        *p = 20;        /* 위험! 이미 사라진 x의 자리에 접근 시도 */
    }

    return 0;
}
```

집이 철거되기 전이나, 늦어도 철거된 직후에는 열쇠를 버린다. 애초에 열쇠를 가지고 나오지 않는 것도 방법이다. 

### 11.5.4 안전 수칙

선언과 동시에 초기화하라:

- 가리킬 곳이 있으면 `int *p = &x;`
- 가리킬 곳이 아직 없으면 `int *p = NULL;`

쓰기 전에 검사하라:

- `p != NULL` 확인은 최소 안전벨트다.
- 단, `p`가 `NULL`로 초기화되어있지 않았다면 검사도 위험할 수 있다.

없어진 주소는 잊어라:

- 블록/함수가 끝나면 지역 변수는 사라진다.
- 지역 변수의 주소를 블록 밖으로 유출하지 말자.


## 11.6 함수에 포인터 넘기기: 원본을 바꾸는 기술

이제 11장의 하이라이트다. 포인터를 배웠으니, 9장에서 해결하지 못했던 문제를 해결할 시간이다.

**주소를 넘기면, 함수가 내 허락 없이도(사실은 허락한 거지만) 내 방에 들어와서 가구를 바꿀 수 있다.**

이것을 전문 용어로 참조에 의한 호출(Call by Reference) **효과**라고 한다. (엄밀히 말하면 C는 항상 '값을 복사해서 전달'하지만, 그 값이 주소(포인터)일 때, 함수가 원본을 바꾸는 *참조 호출처럼 보이는 효과*가 생긴다!) 

### 11.6.1 진짜 swap: `swap_int(int *a, int *b)`

주소를 받아서 원본을 바꾸는 제대로 된 `swap` 함수를 만들어보자.

```c
/* 매개변수가 포인터(int*)다. 즉, 주소를 받겠다는 뜻이다. */
void swap_int(int *a, int *b)
{
    int tmp;

    tmp = *a;   /* 1. a가 가리키는 곳(x)의 값을 읽어온다 */
    *a = *b;    /* 2. b가 가리키는 값(y)을 a가 가리키는 곳(x)에 쓴다 */
    *b = tmp;   /* 3. tmp 값을 b가 가리키는 곳(y)에 쓴다 */
}

int main()
{
    int x = 1;
    int y = 2;

    /* 값(1, 2)이 아니라 주소(&x, &y)를 넘긴다 */
    swap_int(&x, &y);

    /* 잘못된 호출: swap_int(x, y); 인자의 타입이 틀리다. */

    /* 성공! x=2, y=1 */
    return 0;
}
```

**성공의 핵심:**
* `swap_int`는 `x`, `y`라는 변수 이름은 모른다.
* 하지만 `&x`(주소)를 `a`라는 리모컨에 담아왔다.
* `*a`를 건드리는 순간, 메인 함수에 있는 `x`가 바뀐다.

### [값 변화 추적]

| 단계 | main x | main y | a (가리키는 곳) | b (가리키는 곳) | 동작 |
| :--- | :---: | :---: | :---: | :---: | :--- |
| **호출 직후** | 1 | 2 | &x (1000번지) | &y (1004번지) | 주소 전달 완료 |
| **함수 내부** | **2** | **1** | &x | &y | `*a`, `*b`를 통해 원본 교체 |
| **리턴 후** | **2** | **1** | (사라짐) | (사라짐) | **원본이 바뀌어 있음!** |


### 11.6.2 출력 인자(Output Parameter): "결과를 담아오세요"

함수는 `return`으로 값을 하나만 반환할 수 있다는 한계가 있다.
하지만 포인터를 쓰면 **여러 개의 결과**를 얻어낼 수 있다.

> **"빈 그릇(변수)의 주소를 줄 테니, 여기에 결과를 담아줘."** 패턴이다.

#### 예제: 몫과 나머지를 한 번에 구하기 `divmod`

```c
#include <stddef.h>    

/*
 * 반환값(int): 성공하면 0, 0으로 나누면 -1 (에러 코드 역할)
 * 결과값: 포인터 q(몫)와 r(나머지)에 채워 넣음
 */
int divmod(int a, int b, int *q, int *r)
{
    if (b == 0) return -1; // 0으로 나누기 방어, 에러 코드 -1

    if (q != NULL) *q = a / b; // q라는 주소를 줬다면 몫을 쓴다
    if (r != NULL) *r = a % b; // r이라는 주소를 줬다면 나머지를 쓴다

    return 0; // 성공
}

int main()
{
    int mok, nameoji, ok;

    ok = divmod(10, 3, &mok, &nameoji);

    /*
     * ok에는 나누기 성공을 의미하는 0이 저장되어 있다.
     * mok에는 10 / 3의 결과인 3이 저장되어 있다.
     * nameoji에는 10 % 3의 결과인 1이 저장되어 있따.
     */

    return 0;
}
```

### 11.6.3 NULL 체크의 진짜 매력: "필요 없는 건 무시하기"

위의 `divmod` 코드에서 `if (q != NULL)` 체크를 넣은 것은 단순히 오류를 방지하기 위함만이 아니다.
이 덕분에 **함수를 훨씬 유연하게 쓸 수 있다.**

만약 나는 "몫"만 필요하고 "나머지"는 필요 없다면?

```c
int mok;
/* 나머지가 들어갈 자리에 NULL을 넣어버린다 */
divmod(10, 3, &mok, NULL);
```

함수 내부에서 `r`이 `NULL`이므로 `*r = ...` 부분은 실행되지 않고 안전하게 넘어간다.
이처럼 포인터 인자는 **옵션(선택 사항)** 을 처리할 때도 매우 유용하다.



## 11.7 배열과 포인터의 관계: 배열 이름은 왜 포인터처럼 보이나?

10장의 결론을 다시 꺼내자.

> **배열의 이름은 대부분의 식에서 자동으로 첫 번째 칸의 시작 주소처럼 사용된다.**

이 사실 때문에 배열을 함수에 넘기면, 마치 복사되지 않고 원본이 넘어가는 것처럼 보였다.
사실은 **배열의 시작 주소**를 복사해준 것이기 때문이다.

### 11.7.1 함수 매개변수: `int a[]`는 사실 `int *a`다

함수의 매개변수 자리에서는 다음 두 표현이 **완전히 똑같다.**

```c
void func(int a[]); /* "나는 배열을 받을 거야" (사람을 위한 힌트 / 가장 흔한 표기) */
void func(int a[5]); /* "나는 배열을 받을 거야" (구체적인 배열 / 거의 쓰이지 않음) */
void func(int *a);  /* "나는 주소를 받을 거야" (실제 컴파일러의 해석) */
```

컴파일러 입장에서 매개변수 자리에 있는 `int a[]`는 `int *a`를 배열처럼 보이게 써주는 표기다.
함수를 호출할 때도 `func(arr)`처럼 배열 이름을 던져주면 첫 번째 칸의 주소로 자동 변환되어 문제 없이 동작한다.

다음과 같은 코드로 간단하게 확인해볼 수 있다.
```c
void func(int a[5])
{
    sizeof a; /* 이 식을 계산한 결과는 포인터의 크기가 된다. */
}
```

### 11.7.2 가장 큰 차이점: 저장된 값을 바꿀 수 있는지 여부

"배열 이름도 주소고, 포인터도 주소라면 둘은 같은 건가?"
비슷하지만 **결정적인 차이**가 있다.

* **포인터 변수 (`int *p`):** 주소를 적은 **포스트잇**. 언제든 떼서 다른 주소를 적을 수 있다.
* **배열 이름 (`int arr[10]`):** 건물의 **머릿돌**. 태어날 때 그 메모리 위치로 고정된다. 절대 바꿀 수 없다.

```c
int arr[5];
int arr2[5];
int *p;

p = arr;    /* (O) 포스트잇(p)에 주소를 적는 건 자유 */
arr = arr2; /* (X) 머릿돌(arr)을 뽑아서 다른 곳에 옮길 수 없다 (컴파일 에러) */
```

즉, 배열 이름은 "값을 바꿀 수 없는 상수 포인터(Constant Pointer)" 처럼 행동한다.

추가적으로, 10장에서 확인한 바와 같이 `sizeof` 연산을 했을 때도 배열은 원소 하나 크기와 배열의 길이를 곱한 값이 나오고, 포인터는 주소의 크기가 나온다.

## 11.8 포인터 산술(Pointer Arithmetic): “더하기 1”의 진짜 의미

`int *p` 상태에서 `p + 1`을 하면 주소값이 1만큼 늘어날까?
**아니다.** C언어에서 포인터의 덧셈은 단순한 산수가 아니라 **"이동"**이다.

> **`p + 1` : 다음 칸(원소)으로 이동하라.**

포인터는 자신이 가리키는 대상의 **크기(타입)**를 알고 있기 때문에, 알아서 그 크기만큼 건너뛴다.

---

### 11.8.1 그림으로 이해하기: "보폭(Stride)"이 다르다

메모리 번지수가 1000번지부터 시작한다고 가정해보자.

* `char *cp` (1바이트): 한 칸 가면 **1001번지** (+1)
* `int *ip` (4바이트): 한 칸 가면 **1004번지** (+4)
* `double *dp` (8바이트): 한 칸 가면 **1008번지** (+8)



**공식으로 보면 이렇다:**
> **이동할 주소 = 현재 주소 + (이동할 칸 수 × 자료형의 크기)**

우리는 그저 "한 칸 옆(`+1`)"이라고 명령하지만, 컴퓨터는 내부적으로 "자료형 크기만큼 곱해서" 점프한다. 이것이 포인터에 타입(`int*`, `char*`)이 반드시 필요한 이유다.

---

### 11.8.2 포인터로 배열 합 구하기

이제 인덱스 변수 `i` 없이, 포인터만으로 배열을 훑는 코드를 짜보자.

```c
int main()
{
    int a[5] = {10, 20, 30, 40, 50};
    int sum = 0;
    int *p;

    p = a; /* p는 첫 번째 칸(&a[0])을 가리킨다 */

    for (int i = 0; i < 5; i++) {
        sum = sum + *p;  /* 1. 현재 p가 가리키는 값을 더한다 */
        p = p + 1;       /* 2. p를 다음 칸으로 이동시킨다 (4바이트 점프) */
    }
    
    /* Tip: 실무에서는 p = p + 1 대신 'p++'를 더 많이 쓴다. 의미는 같다. */

    return 0;
}
```

### 11.8.3 끝 포인터(End Pointer) 패턴: "문턱"을 기준으로 멈춘다

한 단계 더 나아가 보자. `i`라는 카운터 변수조차 없애버릴 수 있다.
바로 **"배열의 끝 위치"**를 미리 계산해두고, 포인터가 거기에 도달하면 멈추는 방식이다.

```c
int main()
{
    int a[5] = { 10, 20, 30, 40, 50 };
    int sum = 0;
    
    int *p = a;         /* 시작점: a[0] */
    int *end = a + 5;   /* 끝점(문턱): a[5]의 위치 (범위 밖!) */

    /* p가 end보다 작은 동안 계속 전진 */
    for ( ; p < end; p++) {
        sum += *p;
    }

    return 0;
}
```

**여기서 중요한 규칙 (Fence Post Rule):**

1.  **`end`는 "마지막 원소의 다음 칸"이다.**
    * 배열이 5칸이면 `a[5]`의 주소가 `end`다.
    * 이 주소는 유효한 데이터 범위 밖이다.
2.  **`end` 주소를 가지는 건 괜찮지만, `*end`를 열어보면 안 된다.**
    * `end`는 "여기까지 오면 멈춰라"는 표지판(Sentinel) 역할일 뿐, 실제 데이터가 아니다.
    * 문턱은 밟지 말고, 바라보기만 해야 한다.

## 11.9 `a[i]`는 결국 무엇인가: `[]`는 사실 거짓말이다

우리가 지금까지 아무 의심 없이 써왔던 배열의 대괄호 `[]`.
사실 이것은 C언어가 제공하는 **"문법적 설탕(Syntactic Sugar)"**이다.

컴퓨터(CPU)는 인덱스(`[]`)라는 개념을 모른다. 오직 **주소와 이동**만 알 뿐이다.
그래서 컴파일러는 코드를 기계어로 바꿀 때, `[]`를 다음과 같이 몰래 변환한다.

> **`a[i]` $\rightarrow$ `*(a + i)`**

* **`a + i`**: 시작 주소 `a`에서 `i`칸만큼 옆으로 이동해라.
* **`*`**: 그곳의 값을 꺼내라.

즉, 배열 인덱싱은 **"주소 연산 + 역참조"**의 줄임말일 뿐이다.



---

### 11.9.1 같은 일을 두 방식으로 쓰기

이 원리를 알면, 배열을 다루는 두 가지 방식이 **완벽하게 똑같다**는 것을 알 수 있다.

```c
int main()
{
    int a[3] = { 10, 20, 30 };
    int *p = a;

    /* 1. 익숙한 인덱스 방식 */
    printf("%d\n", a[1]);      // 20 출력

    /* 2. 포인터 연산 방식 (컴파일러의 본심) */
    printf("%d\n", *(a + 1));  // 20 출력

    return 0;
}
```

### 11.9.2 재미있는 사실: 포인터도 `[]`를 쓸 수 있다

많은 초보자가 "**배열에만 `[]`를 쓸 수 있다**"고 착각한다.
하지만 `[]`는 그저 `*( )`의 다른 표기법일 뿐이므로, **포인터 변수에도 똑같이 쓸 수 있다.**

```c
int x = 10;
int *p = &x;

p[0] = 20;  /* *(p + 0) = 20; 과 같다. 즉, *p = 20; */
```

이 성질 덕분에 나중에 배울 **동적 할당(malloc)** 메모리도 마치 배열인 것처럼 편하게(`p[i]`) 다룰 수 있는 것이다.

### 11.9.3 [충격 주의] `i[a]`도 된다?

이 원리를 극한까지 밀어붙여 보자.
덧셈은 **교환 법칙**이 성립한다. 즉, `a + i`나 `i + a`나 결과는 같다.

그렇다면... `a[i]` 대신 `i[a]`라고 써도 될까?

```c
int a[3] = { 10, 20, 30 };

printf("%d", 1[a]); // ???
```

**놀랍게도 컴파일이 되고, 정상적으로 20이 출력된다.**
컴파일러 입장에서는 `1[a]` $\rightarrow$ `*(1 + a)` $\rightarrow$ `*(a + 1)` 이므로 논리적으로 완벽하기 때문이다.

(물론, 동료들에게 욕을 먹고 싶지 않다면 실무에서는 절대 쓰지 말자. 그냥 **원리가 그렇다는 뜻**이다.)


## 11.10 포인터와 미정의 동작: C가 진짜 위험해지는 지점

10장에서 “C는 메모리 안전장치가 없다”고 했다. 포인터는 그 위험의 최전선이다.
포인터를 잘못 쓰면 컴파일러는 경고를 줄지언정, 실행 자체를 막지는 않는다.

하지만 실행하는 순간 프로그램은 비명횡사한다.
여러분이 앞으로 가장 많이 보게 될 에러, **Segmentation Fault (세그멘테이션 폴트)**의 원인들을 정리한다.

---

### 11.10.1 0 (NULL) 포인터 역참조

가장 흔한 실수다. "없는 번지"를 찾아가라고 시키는 것이다.

```c
int *p = NULL; // 0번지 (접근 금지 구역)

*p = 10;  /* 쾅! 프로그램 즉시 종료 (Segmentation Fault) */
```
**해결책:** `*p`를 하기 전에 반드시 `if (p != NULL)`을 확인한다.

### 11.10.2 초기화 안 된 포인터 (야생 포인터)
```c
int *p;   /* 쓰레기 값(랜덤한 주소)이 들어있다 */

*p = 10;  /* 운 좋으면 에러, 운 나쁘면 중요한 데이터를 조용히 망가뜨림 */
```

이 경우가 `NULL` 포인터보다 더 무섭다. 에러 없이 넘어가다가 나중에 엉뚱한 곳에서 터지기 때문이다.

### 11.10.3 범위를 벗어난 포인터 (메모리 절벽)

```c
int a[3] = { 1, 2, 3 };
int *p = a;

/* p+0, p+1, p+2 까지는 안전한 땅이다 */
*(p + 3) = 10;  /* 낭떠러지! 남의 메모리를 침범한다 */
```

배열의 크기를 넘어서는 포인터 접근은 **버퍼 오버플로우(Buffer Overflow)** 라고도 부르며, 보안 취약점의 주범이다.

### 11.10.4 사라진 변수의 주소 (댕글링 포인터)

11.5.3에서 본 "철거된 집의 열쇠" 상황이다. 함수나 블록`{}`이 끝나서 사라진 지역 변수의 주소를 계속 들고 있으면 안 된다.

### 11.10.5 타입이 안 맞는 포인터: "코끼리를 냉장고에 넣으려 하지 마라"

포인터 타입은 **"메모리를 읽는 안경"**이다.

* `int *`: 4바이트씩 읽겠다.
* `char *`: 1바이트씩 읽겠다.

만약 `int` 변수의 주소를 `char *` 포인터에 억지로 넣고 읽으면?

```c
int x = 123456;
char *p = (char*)&x; // 억지로 타입 변환 (캐스팅)

/* x의 값 전체가 아니라, 일부분(1바이트)만 읽혀서 엉뚱한 숫자가 된다 */
```
지금은 이것만 기억하자.

> **"포인터 타입은 장식이 아니다. 가리키는 대상과 포인터의 타입은 항상 일치시켜라."**
