# 11. 포인터: 값이 있는 곳을 가리키기

10장에서 우리는 **"값이 공중에 둥둥 떠 있는 게 아니다"**라는 사실을 확실히 알았다.
모든 데이터는 메모리라는 거대한 아파트의 **특정 호수(주소, address)** 칸에 저장된다.

하지만 10장까지는 여기서 멈췄다.

* 데이터에 주소가 있다는 **이론**은 알았지만,
* 그 주소를 **코드에서 직접 다루는 문법**은 배우지 않았다.
    (마치 맛집 주소는 알지만, 정작 찾아가는 길은 모르는 상태와 같다.)

11장에서는 드디어 그 '찾아가는 문법'을 배운다. 핵심은 이것이다.

> **"주소도 결국은 숫자 데이터(값)이다."**
> **그리고 그 주소 값을 저장하기 위해 만든 변수가 바로 포인터(pointer)다.**

포인터를 장착하면, 그동안 "그냥 외우세요"라고 했던 의문들이 한 번에 풀린다.

1.  함수에 `int`를 넘기면 왜 원본이 안 바뀌는가? (주소가 아니라 **값만 복사**해줬으니까)
2.  배열을 넘기면 왜 원본이 바뀌는가? (배열은 태생적으로 **주소를 전달**하니까)
3.  왜 C언어가 강력하면서도 위험한가? (메모리의 **정확한 주소**를 콕 집어서 조작할 수 있기 때문)

이제 메모리의 주소를 손에 쥐고 흔드는 C언어의 진짜 힘, 포인터의 세계로 들어가 보자.

## 11.0 이 장의 목표

이 장의 목표는 단순히 `*`나 `&` 같은 기호를 어디에 적는지 문법을 외우는 것이 아니다.
여러분의 머릿속에 **메모리 지도를 그리고, 자유자재로 이동할 수 있는 능력**을 만드는 것이 진짜 목표다.

코드를 볼 때 더 이상 글자만 보지 않고, 메모리 상자의 연결 관계가 그려져야 한다.

우리는 이 장을 통해 다음 단계들을 정복할 것이다.

**1. 도구 익히기: 주소를 다루는 새로운 문법**
* **주소 추출:** 변수가 살고 있는 위치를 알아내는 `&` 연산자
* **포인터 선언:** 그 주소를 저장하기 위한 전용 변수 `int *p`
* **간접 접근:** 주소를 타고 가서 실제 값을 읽고 쓰는 `*` 연산자

**2. 실전 응용: 한계를 돌파하기**
* **원격 제어:** 포인터를 이용해 함수 안에서 **외부 변수(원본)를 수정**하는 방법 (Swap 함수 완성)
* **배열의 정체:** 배열의 이름이 사실상 포인터처럼 행동하는 이유

**3. 안전하게 사용하기**
* **위험성 인지:** 포인터를 잘못 썼을 때 프로그램이 어떻게 망가지는지(미정의 동작)를 이해하고 예방하기

포인터를 이해하면 C언어의 절반을 넘은 것이다. 이제 시작해보자.

