# 17. 비트 연산자와 플래그: 변수 하나에 스위치 여러 개 담기

지금까지 우리는 프로그램의 흐름을 제어하기 위해

- `if`, `switch`로 갈림길을 만들고
- `for`, `while`, `do-while`로 반복을 만들고
- `&&`, `||`, `!`로 조건을 조립하는 방법

을 다뤘다.

여기까지 오면 프로그램이 무엇을 해야 하는지(논리)는 꽤 잘 표현할 수 있다.
그런데 현실의 코드에서는 "논리" 말고도 자주 등장하는 것이 하나 더 있다.

**상태(ON/OFF)를 여러개 저장해야 하는 상황이 있다.**

## 17.1 왜 필요한가: 스위치가 너무 많아졌다

예를 들어 스마트홈과 IoT 컨트롤러를 만든다고 상상해보자. 
집 안에는 상태를 관리하고 제어해야 할 수많은 가전제품과 센서들이 있다.

* 거실 불(Light)가 켜져 있는가?
* 현관문(Door)가 잠겨 있는가??
* 보일러(Heater)가 가동 중인가?
* 창문(Window)가 열려 있는가?
* 보안 경보(Alarm)이 활성화되어 있는가?

초보자 시절에는 보통 이렇게 변수를 하나씩 선언하며 시작한다.

```c
int is_living_room_light_on;
int is_door_locked;
int is_heater_active;
int is_window_open;
int is_alarm_working;
/* ... 모든 방, 전등, 창문마다 추가되고 가전제품도 계속 추가됨 ... */
```

그리고 로직을 짤 때마다 하나씩 제어한다.

```c
/* 외출 모드: 창문이 열려있으면 경고 */
if (is_window_open == 1) { send_alert("거실 왼쪽 창문이 열려있어요!"); }

/* 귀가 모드: 문을 열고 거실 불을 켜기 */
if (users_first_just_arrived == 1) {
	unlock(DOOR);
	light_on(LIGHT_LIVING_ROOM);
}
```

문법적으로는 아무런 문제가 없다. 기능도 잘 동작한다.

하지만 프로젝트 규모가 커지고 상태가 5개에서 30개, 60개로 늘어나면 하드웨어(메모리와 CPU)의 낭비가 눈에 띄기 시작한다.

우리가 쓰는 `int`는 보통 4바이트(32비트) 크기다.
그런데 '독 상태인가?'를 저장하는 데는 사실 단 1비트(0 또는 1)면 충분하다.
겨우 1비트 정보를 담기 위해 32비트짜리 상자를 통째로 쓰는 셈이다. 

또한 현대 CPU는 태생적으로 한 번의 명령(Cycle)으로 32비트(혹은 64비트)를 동시에 계산하도록 설계되어 있다. 
다른 말로 하면 CPU는 `int` 하나를 처리할 때 32개의 0과 1을 한꺼번에 훑어볼 수 있는 능력이 있다.
그래서 비트 플래그로 묶어서 처리하면 CPU는 단 한 번의 연산으로 32개의 상태를 동시에 검사하거나 변경할 수 있다. 
하지만 변수를 따로 만들면 CPU에게 32번 명령을 내려야 한다.

비유하자면 마치 32인승 버스를 대절해서 승객 1명만 태우고 운행하는 것과 같다. 
심지어 이 버스는 승객 32명을 동시에 목적지에 내려줄 수 있는 능력이 있는데, 
굳이 한 명 태우고 갔다 오고, 다시 한 명 태우고 갔다 오고를 반복하는 꼴이다.

단순한 메모리 낭비를 넘어, 캐시 효율 저하와 명령어 병목 현상을 일으켜 게임 성능 저하의 주범이 된다.

그래서 프로그래머들은 `int` 변수 안에 0/1 스위치를 꽉 채워서 쓰는 문법과 프로그래밍 패턴을 개발했다. 

변수 하나를 '숫자'가 아닌 '32개의 스위치가 달린 제어 패널'로 다루는 법을 배워보자.

# 17.2 비트라는 재료: 0과 1의 칸

우리가 요리를 하려면 재료를 알아야 하듯, 비트 연산을 하려면 컴퓨터의 가장 밑바닥 재료인 비트와 바이트를 구분할 줄 알아야 한다.

비트(Bit)는 "스위치 하나"다. 정보의 가장 작은 단위로 값은 오직 0 또는 1만 가질 수 있다. 
비유하자면, 전구 하나, 동전의 앞뒤, 작은 스위치 하나라고 할 수 있다.

바이트(Byte)는 "스위치 묶음"이다. 메모리 주소를 매기는 가장 작은 단위로 보통 8개의 비트가 모여 1바이트가 된다.
비유하자면, 계란 8개가 들어가는 계란 판, 8개 호실이 있는 건물 한 층이라고 할 수 있다.

여기서 핵심은, CPU가 메모리에서 데이터를 가져올 때, 비트 하나만 쏙 빼올 수 없다는 것이다.
최소한 바이트 단위(계란 판 단위)로 가져와야 한.
그래서 우리는 일단 바이트(또는 int)를 통째로 가져온 뒤, 그 안에서 비트 연산자라는 핀셋을 이용해 특정 비트만 건드리는 것이다.

**정수(`int`)의 실체: "비트가 32개가 이어진 긴 줄"**

우리가 코드에 `int a = 5;`라고 쓰면, 우리는 이것을 숫자 '5'라고 생각한다.
하지만 컴퓨터 메모리 내부에서는 전혀 다른 풍경이 펼쳐진다.

컴퓨터는 이 `int`를 32개의 비트가 일렬로 늘어선 긴 줄로 저장한다. (일반적인 32비트 시스템 기준)

숫자 5의 실제 모습:
```
		00000000 00000000 00000000 00000101
		↑                                 ↑
		31번 비트                       0번 비트
```
* 대부분은 `0`으로 채워져 있고, 맨 끝에 `101`(4+1)만 켜져 있는 상태다.
* 우리는 지금까지 이 전체를 합쳐서 "오! 5구나"라고 값(Value)으로만 해석했다.

**관점의 전환: 계산에서 조작으로**

비트 연산을 시작한다는 것은, 이 `int` 변수를 더 이상 '숫자 5'로 보지 않겠다는 말이다.
대신 "32개의 스위치가 달린 제어 패널"로 보겠다는 뜻이다.

* **산술 연산(`+`, `-`, `*`, `/`):**
    * 전체 비트를 하나의 **'값(양)'**으로 취급한다.
    * 예: `5 + 1` = `6` (양이 늘어남)

* **비트 연산(`&`, `|`, `^`, `~`, `<<`):**
    * 값을 무시하고, 비트 한 칸 한 칸의 **'모양(패턴)'**을 직접 만진다.
    * 예: "오른쪽에서 3번째 스위치를 켜라", "모든 스위치를 반대로 뒤집어라"

이제부터 `int flags;` 변수를 볼 때는 "이 안에 어떤 숫자가 들어있지?"라고 묻지 말자.
"이 안에 몇 번 스위치가 켜져 있지?"라고 묻는 것이 비트 연산의 출발점이다.

## 17.3 비트 마스크(Bit Mask): 원하는 스위치만 골라내는 "구멍 뚫린 종이"

우리는 이제 `int` 변수를 32개의 스위치 패널로 보기로 했다.
그런데 막상 코드를 짜려고 보니 문제가 하나 있다.

"3번 스위치만 켜고 싶은데, 어떻게 '3번'을 콕 집어 말하지?"

`flags`라는 스위치 패널의 0번 스위치를 켜기 위해 `flags = 1;` 이라고 하면 0번 스위치는 켜지는데 나머지가 다 꺼집니다.
우리는 다른 스위치는 건드리지 않고, 딱 원하는 위치의 스위치만 변경하고 싶다.

여기서 필요한 것이 바로 비트 마스크(Bit Mask)다.

**마스크의 원리: 스텐실(Stencil)**

마스크는 비트의 세계에서 "스텐실(구멍 뚫린 종이)" 역할을 한다.

- **1 (구멍 뚫림):** "여기는 내가 조작할 거야." (관심 영역)
- **0 (막혀 있음):** "여기는 건드리지 마." (보호 영역)

예를 들어, **"2번 스위치"**를 조작하고 싶다면, 2번 자리에만 구멍(1)을 뚫고 나머지는 다 막아버린(0) 종이를 준비하면 된다.

```
		... 0 0 0 0 0 1 0 0 
		              ↑
		            (2번 스위치)
```

이 `...000100`이라는 숫자 자체가 바로 **'2번 비트 마스크'**가 된다.

**비트 번호 매기기 (주의!)**

마스크를 만들 때 가장 중요한 것은 번호의 순서다.
컴퓨터의 비트 번호는 오른쪽 끝에서 0번으로 시작해서 왼쪽으로 갈수록 커진다.

```
		[ ... 7 6 5 4 3 2 1 0 ]
		                    ↑
		                  Start
```

- **0번 비트:** 맨 오른쪽 (1번째 칸)
- **1번 비트:** 오른쪽에서 두 번째 칸
- **31번 비트:** 맨 왼쪽 (32번째 칸)

초보자들은 흔히 왼쪽부터 세거나 1번부터 세는 실수를 한다. 오른쪽 0번 시작을 절대 잊지 말자.

**마스크 만드는 법: 시프트 연산자(`<<`)**

그럼 "2번 비트 마스크(`00...00100`)"를 코드로는 어떻게 만들까요?
10진수(`4`)를 계산해서 넣는 거나 C23 표준부터 적용된 이진수(`0b00100`)를 직접 타이핑하는 것은 너무 번거롭다.

그래서 프로그래머들은 "1을 왼쪽으로 민다"는 뜻의 시프트 연산자(`<<`)를 사용한다.

```
		1 << n
		(숫자 1의 비트를 왼쪽으로 n칸 밀어라)
```

이 문법 하나면 모든 위치의 마스크를 즉석에서 만들 수 있다.

- **`1 << 0`** : `000...0001` (0번 마스크)
- **`1 << 1`** : `000...0010` (1번 마스크)
- **`1 << 5`** : `000...00100000` (5번 마스크)

> [!NOTE]
> 구멍을 여러 개 뚫을 순 없을까?
> 
> 당연히 된다! 2번과 5번을 동시에 가리키는 마스크도 만들 수 있다.
> 마스크 여러 개를 합치려면 접착제 역할을 하는 연산자가 필요하다.
> 바로 다음 장에서 배울 `|` (OR) 연산자가 그 역할을 해줄 것이다.

우리는 이제 스위치 패널(변수)와 구멍 뚫린 종이(마스크)를 모두 손에 넣었다.
실제로 스위치를 켜고 끄는 6가지 연산 도구를 배워보자. 

## 17.4 비트 논리 연산자: 마스크로 스위치 조작하기 (`&`, `|`, `^`)

가장 핵심이 되는 3가지 연산자다. 제공된 마스크를 가지고 실제로 스위치를 조작하는 역할을 한다.
`&`와 `||`의 경우에는 `&&`, `||`와 비슷해 보이지만, 비트 단위로 개별적으로 작동한다는 점이 다르다.

### 17.4.1 `&` (AND): 엄격한 관리자, "모두 켜져야 켠다"

**동작:** 두 비트가 모두 1일 때만 1이 된다. 하나라도 0이면 가차 없이 0으로 만들어버린다.

**핵심 성질:**
- `1`과 만나면? 원래 값을 그대로 통과시킨다. (Keep)
- `0`과 만나면? 무조건 0으로 지워버린다. (Clear)

그렇기 때문에 `&`는 주로 검사 또는 끄기 용도로 쓰인다.

**검사 (Check): "거기 켜져 있어?"**
  
특정 위치의 스위치가 켜져 있는지 확인하고 싶을 때 사용한다.
마스크를 씌우면, 관심 있는 비트만 쏙 뽑아내고 나머지는 다 0으로 지워버리기 때문이다.

* `flags & MASK`의 결과가 `0`이면? 해당 플래그가 비활성화된 상태
* `flags & MASK`의 결과가 `0`이 아니면? 해당 플래그가 활성화된 상태

```
  0 1 0 1 0 1  (flags: 원본 값)
  0 0 0 1 0 0  (MASK: "2번 비트만 볼래")
  -----------  (&)
  0 0 0 1 0 0  (결과: 2번만 통과, 나머지는 삭제됨)
```

결과가 0이 아니므로, 2번 비트는 켜져 있었음을 알 수 있다!

**끄기 (Force Off): "거기만 0으로 지워!"**

특정 비트만 강제로 끄고 싶을 때 사용한다.
"끄고 싶은 곳은 0, 남기고 싶은 곳은 1"로 채운 패턴과 `&` 연산을 하면 된다.

* 패턴에서 0인 위치: 0으로 지워짐 (Off)
* 패턴에서 1인 위치: 원래 값 유지 (Safe)

```
  0 1 0 1 0 1  (flags: 원본 값)
  1 1 1 0 1 1  (패턴: "2번 비트를 끌래")
  -----------  (&)
  0 1 0 0 0 1  (결과: 2번은 비활성화됨, 나머지는 그대로 유지)
```

> [!NOTE]
> **저 패턴은 어떻게 만들지?**
>
> 일일이 1과 0을 타이핑해서 만들지 않는다.
> 뒤에서 배울 `~` (비트 NOT) 연산자를 쓰면, 일반 마스크(`000100`)을 뒤집어서 만들 수 있다.  

### 17.4.2 `|` (OR): 관대한 합병자 "하나라도 켜지면 켠다"

* **동작:** 두 비트 중 하나라도 1이면 1이 된다.
  둘 다 0일 때만 0이 된다.

* **핵심 성질:**
  * `0`과 만나면? 원래 값을 그대로 통과시킨다. (Keep)
  * `1`과 만나면? 무조건 1로 켜버린다. (Force On)

그렇기 때문에 `|`는 주로 여러 설정을 하나로 뭉치거나 스위치를 켜는 용도로 쓰인다.

**합치기 (Combine): "옵션 A랑 B랑 다 주세요"**
여러 개의 마스크(옵션)을 하나의 변수에 담아 전달할 때 사용한다.
흔히 라이브러리 함수를 쓸 때 많이 보게 되는 패턴이다.

```c
/* 예: 윈도우 창을 만드는데, "제목 표시줄"도 있고 "닫기 버튼"도 있게 해줘. */
int styles = WS_CAPTION | WS_SYSMENU;
```

비트를 하나씩 적어보면 다음과 같다. 

```
		  0 0 0 1  (옵션 A)
		  0 0 1 0  (옵션 B)
		  -------  (|)
		  0 0 1 1  (결과: A와 B가 합쳐진 복합 상태)
```

A나 B 중 어디라도 1이 있으면 결과에서도 1이 된다. 두 옵션이 모두 활성화된다.

> [!NOTE]
> 그냥 덧셈(`+`)으로 합치면?
>
> 결과가 같을 때도 있겠지만, 위험하다.
> 만약 실수로 이미 켜져 있는 스위치를 또 더하면 어떻게 될까?
>
> - **덧셈(`+`):** $0001 + 0001 = 0010$ (값이 2배가 되면서 옆 비트를 건드려서 자리 올림 버그 발생)
> - **OR(`|`):** $0001 | 0001 = 0001$ (이미 켜져 있으면 그대로 둬서 안전)
>
> 둘 다 1인 비트에서도 정상적으로 안전하게 동작해야 하기 때문에 상태를 합칠 때는 덧셈이 아니라 반드시 OR(`|`) 연산을 써야 한다.

**켜기 (Force On): "스위치 올려!"**

기존에 다른 스위치가 켜져 있든 말든 상관없이, 내가 원하는 특정 비트를 켤 때 사용한다.

```c
		flags = flags | MASK;
```

* 마스크에서 0인 위치: 원래 값 유지 (Safe)
* 마스크에서 1인 위치: 1로 설정됨 (On)

비트가 계산되는 과정을 보면 이렇다.

```
		  1 0 0 0 1 0  (flags: 원래 값)
		  0 0 0 1 0 0  (MASK: "2번 켤래")
		  -----------  (|)
		  1 0 0 1 1 0  (결과: 원래 값은 유지되고, 2번만 켜짐)
```

이미 2번이 켜져 있었더라도 `1 | 1 = 1`이므로 그대로 켜진 상태가 유지된다. (안전함)

> [!NOTE]
> **왜 마스크(MASK)만 대문자로 쓰나?**
>
> 문법적으로는 소문자(`mask`)로 써도 전혀 문제가 없다.
> 하지만 C언어 개발자들 사이에는 "변하지 않는 값(상수)는 무조건 대문자로 쓴다"는 강력한 약속(Convention)이 있다.
>
> - **소문자 (예: `flags`, `hp`, `score`):** 프로그램 실행 중에 값이 계속 변하는 **변수**
> - **대문자 (예: `MASK`, `POISON`, `MAX_SPEED`):** 프로그램 시작부터 끝까지 절대 변하지 않는 **상수**
>
> 코드에 `POISON`이라고 적혀 있다면, 이는 읽는 사람에게 "이 값은 고정된 설계도이니 절대 값을 바꾸지 말라"는 시각적인 표지판 역할을 한다.

## 17.4.3 `^` (XOR): 틀린 그림 찾기, "서로 다르면 켠다"

* **동작:** 두 비트가 서로 다를 때만 1, 같으면 0이 된다.
* **핵심 성질:**
  * `0`과 만나면? 원래 값을 그대로 통과시킨다. (**Keep**)
  * `1`과 만나면? 무조건 반대로 뒤집는다. (**Flip**)

`Flip` 성질 덕분에 `^`는 켜진 건 끄고, 꺼진 건 켜는 토글(Toggle) 기능이나, 데이터를 숨기는 암호화(encryption)에 사용된다.

**토글(Toggle): "상태 뒤집기"**

특정 위치의 스위치를 반전시키고 싶을 때 사용한다.
마스크를 쓰면, 관심 있는 비트들은 바꾸고, 나머지는 그대로 유지할 수 있다.

```c
		flags = flags ^ MASK;
```

* 마스크에서 0인 위치: 원래 값 유지 (**Safe**)
* 마스크에서 1인 위치: 다른 값으로 반전 (**Flip**)

```
		  1 0 0 0 0 0  (flags: 원래 값)
		  0 0 0 1 0 0  (MASK: "2번 뒤집어라")
		  -----------  (^)
		  1 0 0 1 0 0  (결과: 2번 값이 바뀜)
```

한 번 더 실행하면 어떻게 될까?

```
		  1 0 0 1 0 0  (flags: 현재 켜져 있음)
		  0 0 0 1 0 0  (MASK: "2번 뒤집어라")
		  -----------  (^)
		  1 0 0 0 0 0  (결과: 2번 값이 바뀌어서 다시 비활성화 됨)
```

**암호화 (Encryption): "패턴을 바꿨다가 원상복구하기"**

`^`에는 마법 같은 성질이 있다. 같은 마스크로 두 번 `^` 하면 원래 비트들이 나온다.
그래서 간단한 암호화에도 쓸 수 있다.

```
		  1 0 1 0 1 0  (original: 원래 값)
		  0 1 1 1 0 0  (key: 원래 값에서 반전시킬 위치)
		  -----------  (^)
		  1 1 0 1 0 0  (결과: 원래 값을 알아볼 수 없다)
```

똑같은 키로 `^`를 한 번 더 실행하면 원래 값을 찾을 수 있다.

```
		  1 1 0 1 0 0  (encrypted: 복호화 할 패턴)
		  0 1 1 1 0 0  (key: 다시 반전시킬 위치)
		  -----------  (^)
		  1 0 1 0 1 0  (결과: 원래 값을 되찾았다)
```

## 17.5 비트 반전 연산자: 모든 비트 뒤집기 (`~`)

- **동작:** `0`은 `1`로, `1`은 `0`으로 모조리 뒤집는다. (단항 연산자)
- **별명:** **보수 연산자 (Complement)**

단순해 보이지만, 이 연산자는 지우개(OFF 마스크)를 만들 때 없어서는 안 될 필수 도구다.

**용도: 끄기 전용 마스크 만들기**

`&` 연산자에서, 다음과 같이 특정 비트를 끄려면 그 자리만 0이고 나머지는 1인 마스크가 필요하다고 했다.

```c
flags = flags & ~MASK; /* flags의 값 중에서 MASK 자리에 있는 비트만 끄고(0), 나머지는 유지해라. */
```

그런데 `11111011` 같은 숫자를 사람이 직접 계산해서 적는 건 너무 힘들다.

여기서 `~`를 사용하면 아주 우아하게 해결된다.

1.  켜고 싶은 마스크를 먼저 만든다. (`00000100`)
2.  모든 비트를 뒤집는다(`~`). (`11111011`)
3.  이제 `&` 연산을 하면 그 비트만 깔끔하게 0이 된다.

**원하는 비트만 0인 마스크 만들기**
```c
0 0 0 0 0 1 0 0  (MASK: 2번 자리)
---------------  (~)
1 1 1 1 1 0 1 1  (~MASK: 2번만 0, 나머지 1 -> 지우개 준비 완료)
```

**제작한 마스크로 원하는 비트를 끄기**
```
1 0 1 0 1 1 1 1  (flags: 원래 값)
1 1 1 1 1 0 1 1  (~MASK: 지우개)
---------------  (&)
1 0 1 0 1 0 1 1  (결과: 다른 건 그대로이고, 2번만 끔)
```

> [!CAUTION]
> **주의: "부호의 배신"**
> 
> `~` 연산자는 가장 왼쪽의 부호 비트까지 가차 없이 뒤집어버린다.
> 그래서 양수가 갑자기 음수로 변하는 일이 발생한다.
>
> ```
> 		  0 0 ... 0 0 0 0  (0: 양수)
> 		  ---------------  (~)
> 		  1 1 ... 1 1 1 1  (-1: 음수)
> ```
> 단순히 비트 패턴만 필요할 때는 상관없지만, 이 값을 숫자로 계산하려고 하면 버그가 생길 수 있다.

> [!TIP]
> **팁: `~0`은 무엇일까?**
>
> 프로그래밍을 하다 보면 `~0`이라는 코드를 종종 보게 된다.
> `0`은 모든 비트가 `0`인 상태다. 그걸 뒤집으면? "모든 비트가 1인 상태"가 된다.
>
> - 숫자로는: `-1` (signed int 기준)
> - 용도로는: "모든 스위치를 다 켜라" 또는 "비트가 꽉 찬 마스크를 만들라"가 가능하다.

## 17.6 비트 이동 연산자: 마스크 공장 (`<<`, `>>`)

앞서 배운 논리 연산자(`&`, `|`, `^`)를 쓰려면 `00001000` 같은 마스크가 있어야 한다.
비트 이동 연산자는 그 마스크를 즉석에서 찍어내는 공장이자, 데이터를 운반하는 컨베이어 벨트다.

### 17.6.1 `<<` (Left Shift): 왼쪽으로 밀기

- **동작:** 비트들을 왼쪽으로 n칸 민다. 오른쪽 끝의 빈자리는 무조건 `0`으로 채워진다. (Padding)
- **수학적 의미:** 2의 n승을 곱하는 효과 ($x \times 2^n$)

`<<`는 주로 특정 위치만 1인 마스크를 만들거나 2의 거듭제곱을 곱하는 데에 쓴다. 

**마스크 제작 (Fabrication): "1을 n번째 위치로!"**
우리가 `<<`를 쓰는 이유의 99%는 이진수를 직접 계산하기 귀찮아서다.
숫자 1은 비트로 표현하면 0번째 위치의 비트만 1이고 나머지 비트는 0이기 때문에, 
`1 << n`을 하면, n번째 비트만 1이고 나머지 비트는 0이 된다. 

- "3번 스위치를 켜는 마스크가 필요해?" `1 << 3`
- "5번 스위치를 켜는 마스크가 필요해?" `1 << 5`

```
		0 0 0 0 0 0 0 1  (1)
		<< 3             (왼쪽으로 3칸 밀기)
		---------------
		0 0 0 0 1 0 0 0  (8: 3번 비트만 켜짐)
```

> [!CAUTION]
> 넘침 현상(Overflow): "벼랑 끝 조심"
>
> `int` 타입은 크기가 무한하지 않다(보통 32비트).
> 비트를 왼쪽으로 계속 밀어서 변수의 크기를 벗어나면 어떻게 될까?
> `unsigned`와 `signed`의 운명은 완전히 갈린다.
>
> **`unsigned`의 경우: "비트 버림"**
> 
> 부호 없는 정수(`unsigned`)에서 범위를 벗어난 비트는 그냥 버려진다. (수학적으로는 $2^n$으로 나눈 나머지)
>
> 실행 결과는 예측 가능하고 안전하다.
> 비유하자면, 아날로그 시계의 분침이 59분을 지나면 60분이 되는 게 아니라, 다시 00분으로 돌아오는 것과 같다.
> 
> ```c
>		unsigned int u = 0x80000000; /* (1000...0000) */
>		u = u << 1;                  /* (0000...0000) - 맨 앞의 1이 버려짐 */
>		/* u에 저장된 값: 0 (문제없음, 의도된 동작) */
> ```
> 
> **`signed`의 경우: "정의되지 않음" (Undefined Behavior)**
> 
> 부호 있는 정수(`int`)에서 값이 표현 범위를 벗어나는 시프트 연산은 C 언어 표준에서 금지된 행위다.
>
> 흔히 부호 비트가 건드려져서 부호가 바뀐다고 착각하기 쉽지만, 그것은 특정 CPU에서의 우연한 결과일 뿐이다.
> 표준 문서는 이를 "정의되지 않은 동작(Undefined Behavior)"이라고 규정한다.
> 컴파일러가 이 코드를 무시하거나, 프로그램이 오동작하거나, 비정상 종료되어도 할 말이 없다.
> 그래서 결론은 예측할 수 없으므로 절대 하지 말아야 한다.
>
> ```c
>		int s = 2147483647; // (0111...1111) 양수 최대값
>		s = s << 1;         // (1111...1110) 
>		/* 결과: Undefined Behavior! (음수가 될지, 에러가 날지 보장 못 함) */
> ```

> [!NOTE]
> **`&`, `|`, `^`도 연산 결과 부호 비트가 바뀌면 위험할까?**
>
> 결론부터 말하면 프로그램은 터지지 않는다. 
> 시프트(`<<`)는 본질적으로 곱하기(산술 연산)이기 때문이기 때문에,
> 숫자가 표현 범위를 넘어서면 수학적으로 틀린 것이므로 위험한 동작으로 간주한다.
> 반면 비트 논리 연산(`&`, `|`, `^`)의 경우에는 본질적으로 비트 패턴을 조작하는 것이기 때문에 부호 비트를 바꾸는 것도 허용된다. 
>
> 컴퓨터가 에러를 내지 않는다고 하더라도, 부호 비트가 바뀌면 값의 의미는 상식과 다를 수 있다.
> 1. **`&` (끄기):** 음수(`1...`)의 부호를 끄면? 갑자기 거대한 양수가 된다.
> 2. **`|` (켜기):** 양수(`0...`)의 부호를 켜면? 갑자기 거대한 음수가 된다.
> 3. **`^` (반전):** 부호 비트를 토글하면? 양수와 음수 사이에서 널뛰기를 한다.

### 17.6.2 `>>` (Right Shift): 오른쪽으로 밀기

- **동작:** 비트들을 오른쪽으로 n칸 민다. 음이 아닌 정수들은 왼쪽이 0으로 채워지고, 수학적으로 2의 거듭제곱으로 나눈 몫과 동일하다. 음수의 경우에는 구현마다 다르다. 

`>>`는 주로 n번째 이상 비트들의 정보를 추출하거나 2의 거듭제곱으로 나누기를 하기 위해서 쓴다. 

**왼쪽 비트 정보 추출하기**

왼쪽에 모여 있는 데이터들을 0번 자리(1의 자리)로 끌고 내려와서 값을 읽을 때 사용한다.
예를 들어, 8비트 데이터 중 5번~7번 자리(가장 왼쪽 3개)에 필요한 정보가 있다고 가정해보자.

- 목표: 5번 자리에 있는 비트를 0번 자리로 옮겨야 한다. 그래서 5칸을 이동한다.
```
    Index:    [7][6][5][4] [3][2][1][0]
    Original:  1  1  1  0   1  0  1  0   (0xEA)
               |  |  |
                       ↘ ↘ ↘           (5칸 밀기)
                               |  |  |
    >> 5:      0  0  0  0   0  1  1  1   (0x07)
    -------------------------------------------
    결과: 7 (왼쪽 비트 111을 숫자 7로 읽음)
```

**2의 거듭제곱으로 나누기**

오른쪽으로 1칸 밀 때마다 값은 절반(1/2)이 된다.
즉, `>>` $n$ 연산은 정수를 $2^n$으로 나눈 몫을 구하는 것과 같다.

* **장점:** 일반 나눗셈 연산자(`/`)보다 CPU 처리 속도가 훨씬 빠르다.
  (최신 컴파일러는 $2^n$으로 나누는 코드를 보면 자동으로 시프트 연산으로 최적화해준다.)

- 99를 8로 나누기 
```
    Index:    [7][6][5][4] [3][2][1][0]
    Original:  0  1  1  0   0  0  1  1   (99)
               |  |  |  |   |
                     ↘ ↘ ↘ ↘ ↘       (5칸 밀기)
                        |   |  |  |  |
    >> 2:      0  0  0  0   1  1  0  0   (12)
    -------------------------------------------
    결과: 12 (99 / 8의 결과와 동일)
```

> [!NOTE]
> **구현은 보통 음수의 오른쪽 시프트를 어떻게 구현할까?**
>
> 대부분의 현대 CPU는 오른쪽 시프트 명령어를 두 가지 버전으로 나누어 제공한다.
> 
> 1. **논리 시프트 (Logical Shift):** 비는 자리를 무조건 `0`으로 채운다.
>    - 컴파일러들은 `unsigned` 타입에 대해 이 명령어를 쓴다.
> 2. **산술 시프트 (Arithmetic Shift):** 비는 자리에 부호 비트를 복사해서 채운다. 
>    - 대부분의 컴파일러는 `signed` 타입에 대해 주로 이 명령어를 쓴다.
>    - 음수일 때 부호 비트가 1이므로, 1이 채워진다. 
>
> **결론:**
> - 양수: 비는 자리가 항상 0으로 채워진다.
> - 음수: 컴파일러마다 다른 것이 허용되지만, 대다수 시스템은 부호를 유지하기 위해 비는 자리를 1로 채운다.

> [!WARNING]
> **음수 칸 이동과 과도한 이동 금지**
>
> C 표준은 다음의 경우를 정의되지 않은 동작으로 규정한다. 즉, 프로그램이 멈추거나 엉뚱한 값을 내뱉을 수 있다.
> 1. **음수 칸 이동:** 이동할 비트 수(오른쪽 피연산자)가 음수일 때.
> 2. **과도한 이동:** 이동할 비트 수(오른쪽 피연산자)가 왼쪽 피연산자 타입의 비트 너비보다 크거나 같을 때.
>    - 32비트 `int` 변수를 `>> 32` 하거나 `>> 33` 하는 경우.
>
> **왜 정의되지 않은 동작으로 규정되었을까?**
>
> 1. **하드웨어의 현실:** CPU 최적화
> 대부분의 CPU는 시프트 속도를 높이기 위해, 이동할 횟수를 그대로 쓰지 않고 데이터 비트 수로 나눈 나머지만 본다.
> - 예시: 32비트 CPU에서는 이동 횟수의 오른쪽 5비트만 읽는다. (0부터 31까지 숫자 표현 가능)
> - 상황: `x >> 32`를 요청했을 때, 32를 이진수로 나타낸 `100000`이 이동 횟수로 입력된다.
> - 결과: CPU는 오른쪽 5비트인 `00000`만 보고 0칸 이동하라고 해석한다. 결국 값은 변하지 않는다.
>
> 2. **C 언어의 철학:** 성능 우선
> 만약 C 언어 표준에서 32칸 이상 밀면 무조건 0이 되게 하라고 강제했다면?
> 컴파일러들은 모든 시프트 연산에 이동 횟수가 32보다 큰가를 확인하는 `if`문 검사 코드를 추가해야 한다.
> - 그 결과 아주 단순하고 빠른 연산인 시프트가 검사 때문에 느려지게 된다 (오버헤드 발생).
> - C 언어는 프로그래머가 알아서 조심하고, 속도를 최대로 뽑아라는 주의기 때문에 안전장치를 포기하고 하드웨어 명령어를 그대로 실행하게 둔다.

## 17.7 여러 플래그 다루기

이번 장에서는 연산자들을 조합해서 플래그를 다루는 방법을 배운다.

### 17.7.1 플래그들을 조합해서 저장하고, 함수로 전달하기

앞에서 봤듯이, 여러 개의 옵션(플래그)을 동시에 켜고 싶을 때는 비트 OR 연산자(`|`)를 사용한다.

**상황: 스마트 센서 설정하기 (IoT 예시)**

IoT 디바이스는 메모리와 통신 대역폭이 제한적이다. 따라서 '온도 켜기', '와이파이 켜기' 명령을 따로 보내지 않고, 1바이트(8비트) 안에 꽉 채워서 한 번에 보낸다.

```c
/* 각 기능의 스위치 위치 정의 (비트 마스크) */
#define SENSOR_TEMP   (1 << 0)  /* 0000 0001 (온도) */
#define NETWORK_WIFI  (1 << 2)  /* 0000 0100 (와이파이) */
#define POWER_SAVING  (1 << 3)  /* 0000 1000 (절전 모드) */
```

**② 조합: 필요한 기능만 골라 담기 (`|` 연산)**

온도 센서와 와이파이만 켜고 싶다면, 두 플래그를 `|`로 연결한다.

    // 온도 센서(0x01)와 와이파이(0x04) 동시 활성화
    unsigned char config = SENSOR_TEMP | NETWORK_WIFI;

**[시각화: 비트가 합쳐지는 과정]**

    TEMP:        0 0 0 0   0 0 0 1   (0x01)
    WIFI:        0 0 0 0   0 1 0 0   (0x04)
    | (OR)      ------------------
    Config:      0 0 0 0   0 1 0 1   (0x05)

이렇게 만들어진 `0x05`라는 값 하나만 기기에 전송하면, 기기는 "아, 0번 비트랑 2번 비트가 켜졌으니 온도랑 와이파이를 켜야겠군" 하고 알아듣는다.

---

**③ 확장: 기존 설정에 기능 추가하기 (`|=`)**

이미 설정된 값(`config`)에 나중에 **"절전 모드"**를 추가하고 싶다면?
역시 `|` 연산자를 사용해 덮어씌운다. (복합 대입 연산자 `|=` 사용)

    config |= POWER_SAVING;

    Original:    0 0 0 0   0 1 0 1   (0x05)
    Saving:      0 0 0 0   1 0 0 0   (0x08)
    | (OR)      ------------------
    Result:      0 0 0 0   1 1 0 1   (0x0D) -> 온도, 와이파이, 절전 모두 ON

> **💡 [참고] 왜 덧셈(`+`)이 아니라 OR(`|`)를 쓸까?**
>
> 비트가 겹치지 않는다면 덧셈(`+`)을 해도 결과는 같다. 하지만 **이미 켜져 있는 비트를 또 켤 때** 문제가 생긴다.
>
> * **OR (`|`) 연산:** `0001 | 0001 = 0001` (그대로 유지됨. 안전함)
> * **덧셈 (`+`) 연산:** `0001 + 0001 = 0010` (값이 변하고 윗자리로 올림수가 발생함. 위험함)
>
> 따라서 **플래그를 조합할 때는 무조건 `|` 연산자를 사용하는 것이 원칙**이다.


단일 비트가 아닌, 여러 개의 비트(플래그) 상태를 한 번에 검사해야 할 때가 있다.
그럴 때는 검사하려는 비트들을 `|` (OR) 연산으로 묶어서 조합 마스크(Combination Mask)를 만든 뒤 연산한다.

가장 중요한 질문은 이것이다: **"이 중에서 하나라도 켜져 있으면 되는가? 아니면 전부 다 켜져 있어야 하는가?"**

### 17.7.1 조합 마스크 만들기

여러 개의 옵션(플래그)을 동시에 켜고 싶을 때는 **비트 OR 연산자(`|`)**를 사용한다.
`|` 연산자는 **"어느 한쪽이라도 1이면 결과도 1"**이 되는 성질이 있어, 비트들을 덮어쓰지 않고 **합치는(Merge)** 역할을 한다.

**① 상황: 스마트 센서 설정하기 (IoT 예시)**

IoT 디바이스는 메모리와 통신 대역폭이 제한적이다. 따라서 '온도 켜기', '와이파이 켜기' 명령을 따로 보내지 않고, **1바이트(8비트) 안에 꽉 채워서 한 번에** 보낸다.

    // 각 기능의 스위치 위치 정의 (비트 마스크)
    #define SENSOR_TEMP   (1 << 0)  // 0000 0001 (온도)
    #define NETWORK_WIFI  (1 << 2)  // 0000 0100 (와이파이)
    #define POWER_SAVING  (1 << 3)  // 0000 1000 (절전 모드)

**② 조합: 필요한 기능만 골라 담기 (`|` 연산)**

온도 센서와 와이파이만 켜고 싶다면, 두 플래그를 `|`로 연결한다.

    // 온도 센서(0x01)와 와이파이(0x04) 동시 활성화
    unsigned char config = SENSOR_TEMP | NETWORK_WIFI;

**[시각화: 비트가 합쳐지는 과정]**

    TEMP:        0 0 0 0   0 0 0 1   (0x01)
    WIFI:        0 0 0 0   0 1 0 0   (0x04)
    | (OR)      ------------------
    Config:      0 0 0 0   0 1 0 1   (0x05)

이렇게 만들어진 `0x05`라는 값 하나만 기기에 전송하면, 기기는 "아, 0번 비트랑 2번 비트가 켜졌으니 온도랑 와이파이를 켜야겠군" 하고 알아듣는다.

---

**③ 확장: 기존 설정에 기능 추가하기 (`|=`)**

이미 설정된 값(`config`)에 나중에 **"절전 모드"**를 추가하고 싶다면?
역시 `|` 연산자를 사용해 덮어씌운다. (복합 대입 연산자 `|=` 사용)

    config |= POWER_SAVING;

    Original:    0 0 0 0   0 1 0 1   (0x05)
    Saving:      0 0 0 0   1 0 0 0   (0x08)
    | (OR)      ------------------
    Result:      0 0 0 0   1 1 0 1   (0x0D) -> 온도, 와이파이, 절전 모두 ON

> **💡 [참고] 왜 덧셈(`+`)이 아니라 OR(`|`)를 쓸까?**
>
> 비트가 겹치지 않는다면 덧셈(`+`)을 해도 결과는 같다. 하지만 **이미 켜져 있는 비트를 또 켤 때** 문제가 생긴다.
>
> * **OR (`|`) 연산:** `0001 | 0001 = 0001` (그대로 유지됨. 안전함)
> * **덧셈 (`+`) 연산:** `0001 + 0001 = 0010` (값이 변하고 윗자리로 올림수가 발생함. 위험함)
>
> 따라서 **플래그를 조합할 때는 무조건 `|` 연산자를 사용하는 것이 원칙**이다.
> 
#### **0. 상황 설정**

예를 들어 키보드의 특수키(Modifier) 입력 상태를 확인한다고 가정하자.

    #define SHIFT  (1 << 0)  // 0000 0001
    #define CTRL   (1 << 1)  // 0000 0010
    #define ALT    (1 << 2)  // 0000 0100

    unsigned char keys = ...; // 현재 눌린 키 상태 변수

우리가 궁금한 것은 **"SHIFT와 CTRL"**에 대한 상태다.
검사할 조합 마스크: `MASK = SHIFT | CTRL` (즉, `0x03` 혹은 `0000 0011`)

---

#### **① "하나라도 켜져 있나?" (ANY)**

* **의미:** "SHIFT **또는** CTRL 중 하나라도 눌려 있으면 통과."
* **방법:** 마스크와 `&` 연산한 결과가 **0이 아니면** 된다.
* **코드:**
    ```c
    if (keys & (SHIFT | CTRL)) {
        // SHIFT만 눌려도 OK, CTRL만 눌려도 OK, 둘 다 눌려도 OK
    }
    ```

**[시각화: CTRL만 눌린 경우 (통과)]**
    Keys:    0 0 0 0  0 0 1 0   (CTRL 눌림)
    Mask:    0 0 0 0  0 0 1 1   (SHIFT | CTRL)
    &       -----------------
    Result:  0 0 0 0  0 0 1 0   (결과가 0이 아님 -> True)

---

#### **② "전부 켜져 있나?" (ALL)**

* **의미:** "SHIFT **그리고** CTRL이 둘 다 동시에 눌려 있어야 통과."
* **방법:** 마스크와 `&` 연산한 결과가 **마스크 값과 정확히 같아야** 한다.
* **코드:**
    ```c
    // 주의: 연산자 우선순위 때문에 괄호 필수!
    if ((keys & MASK) == MASK) {
        // 반드시 둘 다 눌려야 진입
    }
    ```

**[시각화: CTRL만 눌린 경우 (실패)]**
    Keys:    0 0 0 0  0 0 1 0   (CTRL 눌림)
    Mask:    0 0 0 0  0 0 1 1   (SHIFT | CTRL)
    &       -----------------
    Result:  0 0 0 0  0 0 1 0   (결과값 2)

    비교:    Result (2) != Mask (3) -> False (탈락)

---

#### **💡 요약**

| 구분 | 질문 | 코드 패턴 | 설명 |
| :--- | :--- | :--- | :--- |
| **ANY** | 하나라도 켜졌니? | `(vars & MASK)` | 결과가 `0`이 아니면 참 |
| **ALL** | 전부 다 켜졌니? | `(vars & MASK) == MASK` | 결과가 `MASK`와 같아야 참 |

> **⚠️ 주의: 연산자 우선순위 버그**
>
> C 언어에서 **비교 연산자(`==`)는 비트 연산자(`&`)보다 우선순위가 높다.**
> 따라서 괄호 없이 작성하면 치명적인 논리 오류가 발생한다.
>
> * **오답:** `flags & MASK == MASK`
>     * 해석: `flags & (MASK == MASK)` → `flags & 1` (완전히 다른 의미가 됨)
> * **정답:** `(flags & MASK) == MASK`
>     * **반드시 `&` 연산 부분을 괄호로 감싸야 한다.**
