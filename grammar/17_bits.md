# 17. 비트 연산자와 플래그: 변수 하나에 스위치 여러 개 담기

지금까지 우리는 프로그램의 흐름을 제어하기 위해

- `if`, `switch`로 갈림길을 만들고
- `for`, `while`, `do-while`로 반복을 만들고
- `&&`, `||`, `!`로 조건을 조립하는 방법

을 다뤘다.

여기까지 오면 프로그램이 무엇을 해야 하는지(논리)는 꽤 잘 표현할 수 있다.
그런데 현실의 코드에서는 "논리" 말고도 자주 등장하는 것이 하나 더 있다.

**상태(ON/OFF)를 여러개 저장해야 하는 상황이 있다.**

## 17.1 왜 필요한가: 스위치가 너무 많아졌다

예를 들어 스마트홈과 IoT 컨트롤러를 만든다고 상상해보자. 
집 안에는 상태를 관리하고 제어해야 할 수많은 가전제품과 센서들이 있다.

* 거실 불(Light)가 켜져 있는가?
* 현관문(Door)가 잠겨 있는가??
* 보일러(Heater)가 가동 중인가?
* 창문(Window)가 열려 있는가?
* 보안 경보(Alarm)이 활성화되어 있는가?

초보자 시절에는 보통 이렇게 변수를 하나씩 선언하며 시작한다.

```c
int is_living_room_light_on;
int is_door_locked;
int is_heater_active;
int is_window_open;
int is_alarm_working;
/* ... 모든 방, 전등, 창문마다 추가되고 가전제품도 계속 추가됨 ... */
```

그리고 로직을 짤 때마다 하나씩 제어한다.

```c
/* 외출 모드: 창문이 열려있으면 경고 */
if (is_window_open == 1) { send_alert("거실 왼쪽 창문이 열려있어요!"); }

/* 귀가 모드: 문을 열고 거실 불을 켜기 */
if (users_first_just_arrived == 1) {
	unlock(DOOR);
	light_on(LIGHT_LIVING_ROOM);
}
```

문법적으로는 아무런 문제가 없다. 기능도 잘 동작한다.

하지만 프로젝트 규모가 커지고 상태가 5개에서 30개, 60개로 늘어나면 하드웨어(메모리와 CPU)의 낭비가 눈에 띄기 시작한다.

우리가 쓰는 `int`는 보통 4바이트(32비트) 크기다.
그런데 '독 상태인가?'를 저장하는 데는 사실 단 1비트(0 또는 1)면 충분하다.
겨우 1비트 정보를 담기 위해 32비트짜리 상자를 통째로 쓰는 셈이다. 

또한 현대 CPU는 태생적으로 한 번의 명령(Cycle)으로 32비트(혹은 64비트)를 동시에 계산하도록 설계되어 있다. 
다른 말로 하면 CPU는 `int` 하나를 처리할 때 32개의 0과 1을 한꺼번에 훑어볼 수 있는 능력이 있다.
그래서 비트 플래그로 묶어서 처리하면 CPU는 단 한 번의 연산으로 32개의 상태를 동시에 검사하거나 변경할 수 있다. 
하지만 변수를 따로 만들면 CPU에게 32번 명령을 내려야 한다.

비유하자면 마치 32인승 버스를 대절해서 승객 1명만 태우고 운행하는 것과 같다. 
심지어 이 버스는 승객 32명을 동시에 목적지에 내려줄 수 있는 능력이 있는데, 
굳이 한 명 태우고 갔다 오고, 다시 한 명 태우고 갔다 오고를 반복하는 꼴이다.

단순한 메모리 낭비를 넘어, 캐시 효율 저하와 명령어 병목 현상을 일으켜 게임 성능 저하의 주범이 된다.

그래서 프로그래머들은 `int` 변수 안에 0/1 스위치를 꽉 채워서 쓰는 문법과 프로그래밍 패턴을 개발했다. 

변수 하나를 '숫자'가 아닌 '32개의 스위치가 달린 제어 패널'로 다루는 법을 배워보자.

# 17.2 비트라는 재료: 0과 1의 칸

우리가 요리를 하려면 재료를 알아야 하듯, 비트 연산을 하려면 컴퓨터의 가장 밑바닥 재료인 비트와 바이트를 구분할 줄 알아야 한다.

비트(Bit)는 "스위치 하나"다. 정보의 가장 작은 단위로 값은 오직 0 또는 1만 가질 수 있다. 
비유하자면, 전구 하나, 동전의 앞뒤, 작은 스위치 하나라고 할 수 있다.

바이트(Byte)는 "스위치 묶음"이다. 메모리 주소를 매기는 가장 작은 단위로 보통 8개의 비트가 모여 1바이트가 된다.
비유하자면, 계란 8개가 들어가는 계란 판, 8개 호실이 있는 건물 한 층이라고 할 수 있다.

여기서 핵심은, CPU가 메모리에서 데이터를 가져올 때, 비트 하나만 쏙 빼올 수 없다는 것이다.
최소한 바이트 단위(계란 판 단위)로 가져와야 한.
그래서 우리는 일단 바이트(또는 int)를 통째로 가져온 뒤, 그 안에서 비트 연산자라는 핀셋을 이용해 특정 비트만 건드리는 것이다.

**정수(`int`)의 실체: "비트가 32개가 이어진 긴 줄"**

우리가 코드에 `int a = 5;`라고 쓰면, 우리는 이것을 숫자 '5'라고 생각한다.
하지만 컴퓨터 메모리 내부에서는 전혀 다른 풍경이 펼쳐진다.

컴퓨터는 이 `int`를 32개의 비트가 일렬로 늘어선 긴 줄로 저장한다. (일반적인 32비트 시스템 기준)

숫자 5의 실제 모습:
```
		00000000 00000000 00000000 00000101
		↑                                 ↑
		31번 비트                       0번 비트
```
* 대부분은 `0`으로 채워져 있고, 맨 끝에 `101`(4+1)만 켜져 있는 상태다.
* 우리는 지금까지 이 전체를 합쳐서 "오! 5구나"라고 값(Value)으로만 해석했다.

**관점의 전환: 계산에서 조작으로**

비트 연산을 시작한다는 것은, 이 `int` 변수를 더 이상 '숫자 5'로 보지 않겠다는 말이다.
대신 "32개의 스위치가 달린 제어 패널"로 보겠다는 뜻이다.

* **산술 연산(`+`, `-`, `*`, `/`):**
    * 전체 비트를 하나의 **'값(양)'**으로 취급한다.
    * 예: `5 + 1` = `6` (양이 늘어남)

* **비트 연산(`&`, `|`, `^`, `~`, `<<`):**
    * 값을 무시하고, 비트 한 칸 한 칸의 **'모양(패턴)'**을 직접 만진다.
    * 예: "오른쪽에서 3번째 스위치를 켜라", "모든 스위치를 반대로 뒤집어라"

이제부터 `int flags;` 변수를 볼 때는 "이 안에 어떤 숫자가 들어있지?"라고 묻지 말자.
"이 안에 몇 번 스위치가 켜져 있지?"라고 묻는 것이 비트 연산의 출발점이다.

## 17.3 비트 마스크(Bit Mask): 원하는 스위치만 골라내는 "구멍 뚫린 종이"

우리는 이제 `int` 변수를 32개의 스위치 패널로 보기로 했다.
그런데 막상 코드를 짜려고 보니 문제가 하나 있다.

"3번 스위치만 켜고 싶은데, 어떻게 '3번'을 콕 집어 말하지?"

`flags`라는 스위치 패널의 0번 스위치를 켜기 위해 `flags = 1;` 이라고 하면 0번 스위치는 켜지는데 나머지가 다 꺼집니다.
우리는 다른 스위치는 건드리지 않고, 딱 원하는 위치의 스위치만 변경하고 싶다.

여기서 필요한 것이 바로 비트 마스크(Bit Mask)다.

**마스크의 원리: 스텐실(Stencil)**

마스크는 비트의 세계에서 "스텐실(구멍 뚫린 종이)" 역할을 한다.

- **1 (구멍 뚫림):** "여기는 내가 조작할 거야." (관심 영역)
- **0 (막혀 있음):** "여기는 건드리지 마." (보호 영역)

예를 들어, **"2번 스위치"**를 조작하고 싶다면, 2번 자리에만 구멍(1)을 뚫고 나머지는 다 막아버린(0) 종이를 준비하면 된다.

```
		... 0 0 0 0 0 1 0 0 
		              ↑
		            (2번 스위치)
```

이 `...000100`이라는 숫자 자체가 바로 **'2번 비트 마스크'**가 된다.

**비트 번호 매기기 (주의!)**

마스크를 만들 때 가장 중요한 것은 번호의 순서다.
컴퓨터의 비트 번호는 오른쪽 끝에서 0번으로 시작해서 왼쪽으로 갈수록 커진다.

```
		[ ... 7 6 5 4 3 2 1 0 ]
		                    ↑
		                  Start
```

- **0번 비트:** 맨 오른쪽 (1번째 칸)
- **1번 비트:** 오른쪽에서 두 번째 칸
- **31번 비트:** 맨 왼쪽 (32번째 칸)

초보자들은 흔히 왼쪽부터 세거나 1번부터 세는 실수를 한다. 오른쪽 0번 시작을 절대 잊지 말자.

**마스크 만드는 법: 시프트 연산자(`<<`)**

그럼 "2번 비트 마스크(`00...00100`)"를 코드로는 어떻게 만들까요?
10진수(`4`)를 계산해서 넣는 거나 C23 표준부터 적용된 이진수(`0b00100`)를 직접 타이핑하는 것은 너무 번거롭다.

그래서 프로그래머들은 "1을 왼쪽으로 민다"는 뜻의 시프트 연산자(`<<`)를 사용한다.

```
		1 << n
		(숫자 1의 비트를 왼쪽으로 n칸 밀어라)
```

이 문법 하나면 모든 위치의 마스크를 즉석에서 만들 수 있다.

- **`1 << 0`** : `000...0001` (0번 마스크)
- **`1 << 1`** : `000...0010` (1번 마스크)
- **`1 << 5`** : `000...00100000` (5번 마스크)

> [!NOTE]
> 구멍을 여러 개 뚫을 순 없을까?
> 
> 당연히 된다! 2번과 5번을 동시에 가리키는 마스크도 만들 수 있다.
> 마스크 여러 개를 합치려면 접착제 역할을 하는 연산자가 필요하다.
> 바로 다음 장에서 배울 `|` (OR) 연산자가 그 역할을 해줄 것이다.

우리는 이제 스위치 패널(변수)와 구멍 뚫린 종이(마스크)를 모두 손에 넣었다.
실제로 스위치를 켜고 끄는 6가지 연산 도구를 배워보자. 

## 17.4 비트 논리 연산자: 마스크로 스위치 조작하기 (`&`, `|`, `^`)

가장 핵심이 되는 3가지 연산자다. 제공된 마스크를 가지고 실제로 스위치를 조작하는 역할을 한다.
`&`와 `||`의 경우에는 `&&`, `||`와 비슷해 보이지만, 비트 단위로 개별적으로 작동한다는 점이 다르다.

### 17.4.1 `&` (AND): 엄격한 관리자, "모두 켜져야 켠다"

**동작:** 두 비트가 모두 1일 때만 1이 된다. 하나라도 0이면 가차 없이 0으로 만들어버린다.

**핵심 성질:**
- `1`과 만나면? 원래 값을 그대로 통과시킨다. (Keep)
- `0`과 만나면? 무조건 0으로 지워버린다. (Clear)

그렇기 때문에 `&`는 주로 검사 또는 끄기 용도로 쓰인다.

**검사 (Check): "거기 켜져 있어?"**
  
특정 위치의 스위치가 켜져 있는지 확인하고 싶을 때 사용한다.
마스크를 씌우면, 관심 있는 비트만 쏙 뽑아내고 나머지는 다 0으로 지워버리기 때문이다.

* `flags & MASK`의 결과가 `0`이면? 해당 플래그가 비활성화된 상태
* `flags & MASK`의 결과가 `0`이 아니면? 해당 플래그가 활성화된 상태

```
  0 1 0 1 0 1  (flags: 원본 값)
  0 0 0 1 0 0  (MASK: "2번 비트만 볼래")
  -----------  (&)
  0 0 0 1 0 0  (결과: 2번만 통과, 나머지는 삭제됨)
```

결과가 0이 아니므로, 2번 비트는 켜져 있었음을 알 수 있다!

**끄기 (Force Off): "거기만 0으로 지워!"**

특정 비트만 강제로 끄고 싶을 때 사용한다.
"끄고 싶은 곳은 0, 남기고 싶은 곳은 1"로 채운 패턴과 `&` 연산을 하면 된다.

* 패턴에서 0인 위치: 0으로 지워짐 (Off)
* 패턴에서 1인 위치: 원래 값 유지 (Safe)

```
  0 1 0 1 0 1  (flags: 원본 값)
  1 1 1 0 1 1  (패턴: "2번 비트를 끌래")
  -----------  (&)
  0 1 0 0 0 1  (결과: 2번은 비활성화됨, 나머지는 그대로 유지)
```

> [!NOTE]
> **저 패턴은 어떻게 만들지?**
>
> 일일이 1과 0을 타이핑해서 만들지 않는다.
> 뒤에서 배울 `~` (비트 NOT) 연산자를 쓰면, 일반 마스크(`000100`)을 뒤집어서 만들 수 있다.  

### 17.4.2 `|` (OR): 관대한 합병자 "하나라도 켜지면 켠다"

* **동작:** 두 비트 중 하나라도 1이면 1이 된다.
  둘 다 0일 때만 0이 된다.

* **핵심 성질:**
  * `0`과 만나면? 원래 값을 그대로 통과시킨다. (Keep)
  * `1`과 만나면? 무조건 1로 켜버린다. (Force On)

그렇기 때문에 `|`는 주로 여러 설정을 하나로 뭉치거나 스위치를 켜는 용도로 쓰인다.

**합치기 (Combine): "옵션 A랑 B랑 다 주세요"**
여러 개의 마스크(옵션)을 하나의 변수에 담아 전달할 때 사용한다.
흔히 라이브러리 함수를 쓸 때 많이 보게 되는 패턴이다.

```c
/* 예: 윈도우 창을 만드는데, "제목 표시줄"도 있고 "닫기 버튼"도 있게 해줘. */
int styles = WS_CAPTION | WS_SYSMENU;
```

비트를 하나씩 적어보면 다음과 같다. 

```
		  0 0 0 1  (옵션 A)
		  0 0 1 0  (옵션 B)
		  -------  (|)
		  0 0 1 1  (결과: A와 B가 합쳐진 복합 상태)
```

A나 B 중 어디라도 1이 있으면 결과에서도 1이 된다. 두 옵션이 모두 활성화된다.

> [!NOTE]
> 그냥 덧셈(`+`)으로 합치면?
>
> 결과가 같을 때도 있겠지만, 위험하다.
> 만약 실수로 이미 켜져 있는 스위치를 또 더하면 어떻게 될까?
>
> - **덧셈(`+`):** $0001 + 0001 = 0010$ (값이 2배가 되면서 옆 비트를 건드려서 자리 올림 버그 발생)
> - **OR(`|`):** $0001 | 0001 = 0001$ (이미 켜져 있으면 그대로 둬서 안전)
>
> 둘 다 1인 비트에서도 정상적으로 안전하게 동작해야 하기 때문에 상태를 합칠 때는 덧셈이 아니라 반드시 OR(`|`) 연산을 써야 한다.

**켜기 (Force On): "스위치 올려!"**

기존에 다른 스위치가 켜져 있든 말든 상관없이, 내가 원하는 특정 비트를 켤 때 사용한다.

```c
		flags = flags | MASK;
```

* 마스크에서 0인 위치: 원래 값 유지 (Safe)
* 마스크에서 1인 위치: 1로 설정됨 (On)

비트가 계산되는 과정을 보면 이렇다.

```
		  1 0 0 0 1 0  (flags: 원래 값)
		  0 0 0 1 0 0  (MASK: "2번 켤래")
		  -----------  (|)
		  1 0 0 1 1 0  (결과: 원래 값은 유지되고, 2번만 켜짐)
```

이미 2번이 켜져 있었더라도 `1 | 1 = 1`이므로 그대로 켜진 상태가 유지된다. (안전함)

> [!NOTE]
> **왜 마스크(MASK)만 대문자로 쓰나?**
>
> 문법적으로는 소문자(`mask`)로 써도 전혀 문제가 없다.
> 하지만 C언어 개발자들 사이에는 "변하지 않는 값(상수)는 무조건 대문자로 쓴다"는 강력한 약속(Convention)이 있다.
>
> - **소문자 (예: `flags`, `hp`, `score`):** 프로그램 실행 중에 값이 계속 변하는 **변수**
> - **대문자 (예: `MASK`, `POISON`, `MAX_SPEED`):** 프로그램 시작부터 끝까지 절대 변하지 않는 **상수**
>
> 코드에 `POISON`이라고 적혀 있다면, 이는 읽는 사람에게 "이 값은 고정된 설계도이니 절대 값을 바꾸지 말라"는 시각적인 표지판 역할을 한다.

## 17.4.3 `^` (XOR): 틀린 그림 찾기, "서로 다르면 켠다"

* **동작:** 두 비트가 서로 다를 때만 1, 같으면 0이 된다.
* **핵심 성질:**
  * `0`과 만나면? 원래 값을 그대로 통과시킨다. (**Keep**)
  * `1`과 만나면? 무조건 반대로 뒤집는다. (**Flip**)

`Flip` 성질 덕분에 `^`는 켜진 건 끄고, 꺼진 건 켜는 토글(Toggle) 기능이나, 데이터를 숨기는 암호화(encryption)에 사용된다.

**토글(Toggle): "상태 뒤집기"**

특정 위치의 스위치를 반전시키고 싶을 때 사용한다.
마스크를 쓰면, 관심 있는 비트들은 바꾸고, 나머지는 그대로 유지할 수 있다.

```c
		flags = flags ^ MASK;
```

* 마스크에서 0인 위치: 원래 값 유지 (**Safe**)
* 마스크에서 1인 위치: 다른 값으로 반전 (**Flip**)

```
		  1 0 0 0 0 0  (flags: 원래 값)
		  0 0 0 1 0 0  (MASK: "2번 뒤집어라")
		  -----------  (^)
		  1 0 0 1 0 0  (결과: 2번 값이 바뀜)
```

한 번 더 실행하면 어떻게 될까?

```
		  1 0 0 1 0 0  (flags: 현재 켜져 있음)
		  0 0 0 1 0 0  (MASK: "2번 뒤집어라")
		  -----------  (^)
		  1 0 0 0 0 0  (결과: 2번 값이 바뀌어서 다시 비활성화 됨)
```

**암호화 (Encryption): "패턴을 바꿨다가 원상복구하기"**

`^`에는 마법 같은 성질이 있다. 같은 마스크로 두 번 `^` 하면 원래 비트들이 나온다.
그래서 간단한 암호화에도 쓸 수 있다.

```
		  1 0 1 0 1 0  (original: 원래 값)
		  0 1 1 1 0 0  (key: 원래 값에서 반전시킬 위치)
		  -----------  (^)
		  1 1 0 1 0 0  (결과: 원래 값을 알아볼 수 없다)
```

똑같은 키로 `^`를 한 번 더 실행하면 원래 값을 찾을 수 있다.

```
		  1 1 0 1 0 0  (encrypted: 복호화 할 패턴)
		  0 1 1 1 0 0  (key: 다시 반전시킬 위치)
		  -----------  (^)
		  1 0 1 0 1 0  (결과: 원래 값을 되찾았다)
```

## 17.5 비트 반전 연산자: 모든 비트 뒤집기 (`~`)

- **동작:** `0`은 `1`로, `1`은 `0`으로 모조리 뒤집는다. (단항 연산자)
- **별명:** **보수 연산자 (Complement)**

단순해 보이지만, 이 연산자는 지우개(OFF 마스크)를 만들 때 없어서는 안 될 필수 도구다.

**용도: 끄기 전용 마스크 만들기**

`&` 연산자에서, 다음과 같이 특정 비트를 끄려면 그 자리만 0이고 나머지는 1인 마스크가 필요하다고 했다.

```c
flags = flags & ~MASK; /* flags의 값 중에서 MASK 자리에 있는 비트만 끄고(0), 나머지는 유지해라. */
```

그런데 `11111011` 같은 숫자를 사람이 직접 계산해서 적는 건 너무 힘들다.

여기서 `~`를 사용하면 아주 우아하게 해결된다.

1.  켜고 싶은 마스크를 먼저 만든다. (`00000100`)
2.  모든 비트를 뒤집는다(`~`). (`11111011`)
3.  이제 `&` 연산을 하면 그 비트만 깔끔하게 0이 된다.

**원하는 비트만 0인 마스크 만들기**
```c
0 0 0 0 0 1 0 0  (MASK: 2번 자리)
---------------  (~)
1 1 1 1 1 0 1 1  (~MASK: 2번만 0, 나머지 1 -> 지우개 준비 완료)
```

**제작한 마스크로 원하는 비트를 끄기**
```
1 0 1 0 1 1 1 1  (flags: 원래 값)
1 1 1 1 1 0 1 1  (~MASK: 지우개)
---------------  (&)
1 0 1 0 1 0 1 1  (결과: 다른 건 그대로이고, 2번만 끔)
```

> [!CAUTION]
> **주의: "부호의 배신"**
> 
> `~` 연산자는 가장 왼쪽의 부호 비트까지 가차 없이 뒤집어버린다.
> 그래서 양수가 갑자기 음수로 변하는 일이 발생한다.
>
> ```
> 		  0 0 ... 0 0 0 0  (0: 양수)
> 		  ---------------  (~)
> 		  1 1 ... 1 1 1 1  (-1: 음수)
> ```
> 단순히 비트 패턴만 필요할 때는 상관없지만, 이 값을 숫자로 계산하려고 하면 버그가 생길 수 있다.

> [!TIP]
> **팁: `~0`은 무엇일까?**
>
> 프로그래밍을 하다 보면 `~0`이라는 코드를 종종 보게 된다.
> `0`은 모든 비트가 `0`인 상태다. 그걸 뒤집으면? 모든 비트가 1인 상태가 된다.
>
> * **비트 패턴:** `1111...1111` (비트 너비에 상관없이 꽉 찬 비트)
> * **숫자 값 (`signed`):**
>     * **2의 보수 시스템:** `-1` (대부분의 현대 컴퓨터)
>     * **1의 보수 시스템 (C23 전까지 허용):** `-0` (일부 구형 아키텍처)
> * **핵심 용도:**
>     숫자가 `-1`이냐 `-0`이냐를 따지기보다는, "모든 스위치를 다 켜라" 또는 "기종에 상관없이 비트가 꽉 찬 마스크를 만들라"는 의미로 쓰인다.
>     (예: `unsigned int max = ~0;`)

## 17.6 비트 이동 연산자: 마스크 공장 (`<<`, `>>`)

앞서 배운 논리 연산자(`&`, `|`, `^`)를 쓰려면 `00001000` 같은 마스크가 있어야 한다.
비트 이동 연산자는 그 마스크를 즉석에서 찍어내는 공장이자, 데이터를 운반하는 컨베이어 벨트다.

### 17.6.1 `<<` (Left Shift): 왼쪽으로 밀기

- **동작:** 비트들을 왼쪽으로 n칸 민다. 오른쪽 끝의 빈자리는 무조건 `0`으로 채워진다. (Padding)
- **수학적 의미:** 2의 n승을 곱하는 효과 ($x \times 2^n$)

`<<`는 주로 특정 위치만 1인 마스크를 만들거나 2의 거듭제곱을 곱하는 데에 쓴다. 

**마스크 제작 (Fabrication): "1을 n번째 위치로!"**
우리가 `<<`를 쓰는 이유의 99%는 이진수를 직접 계산하기 귀찮아서다.
숫자 1은 비트로 표현하면 0번째 위치의 비트만 1이고 나머지 비트는 0이기 때문에, 
`1 << n`을 하면, n번째 비트만 1이고 나머지 비트는 0이 된다. 

- "3번 스위치를 켜는 마스크가 필요해?" `1 << 3`
- "5번 스위치를 켜는 마스크가 필요해?" `1 << 5`

```
		0 0 0 0 0 0 0 1  (1)
		<< 3             (왼쪽으로 3칸 밀기)
		---------------
		0 0 0 0 1 0 0 0  (8: 3번 비트만 켜짐)
```

> [!CAUTION]
> 넘침 현상(Overflow): "벼랑 끝 조심"
>
> `int` 타입은 크기가 무한하지 않다(보통 32비트).
> 비트를 왼쪽으로 계속 밀어서 변수의 크기를 벗어나면 어떻게 될까?
> `unsigned`와 `signed`의 운명은 완전히 갈린다.
>
> **`unsigned`의 경우: "비트 버림"**
> 
> 부호 없는 정수(`unsigned`)에서 범위를 벗어난 비트는 그냥 버려진다. (수학적으로는 $2^n$으로 나눈 나머지)
>
> 실행 결과는 예측 가능하고 안전하다.
> 비유하자면, 아날로그 시계의 분침이 59분을 지나면 60분이 되는 게 아니라, 다시 00분으로 돌아오는 것과 같다.
> 
> ```c
>		unsigned int u = 0x80000000; /* (1000...0000) */
>		u = u << 1;                  /* (0000...0000) - 맨 앞의 1이 버려짐 */
>		/* u에 저장된 값: 0 (문제없음, 의도된 동작) */
> ```
> 
> **`signed`의 경우: "정의되지 않음" (Undefined Behavior)**
> 
> 부호 있는 정수(`int`)에서 값이 표현 범위를 벗어나는 시프트 연산은 C 언어 표준에서 금지된 행위다.
>
> 흔히 부호 비트가 건드려져서 부호가 바뀐다고 착각하기 쉽지만, 그것은 특정 CPU에서의 우연한 결과일 뿐이다.
> 표준 문서는 이를 "정의되지 않은 동작(Undefined Behavior)"이라고 규정한다.
> 컴파일러가 이 코드를 무시하거나, 프로그램이 오동작하거나, 비정상 종료되어도 할 말이 없다.
> 그래서 결론은 예측할 수 없으므로 절대 하지 말아야 한다.
>
> ```c
>		int s = 2147483647; // (0111...1111) 양수 최대값
>		s = s << 1;         // (1111...1110) 
>		/* 결과: Undefined Behavior! (음수가 될지, 에러가 날지 보장 못 함) */
> ```

> [!NOTE]
> **`&`, `|`, `^`도 연산 결과 부호 비트가 바뀌면 위험할까?**
>
> 결론부터 말하면 연산 자체는 합법이고 프로그램은 터지지 않는다. 하지만 값의 해석이 뒤집히는 것이 진짜 위험이다.
>
> - **시프트(`<<`)와의 차이**
>   `<<`는 사실상 2의 거듭제곱 곱셈이라서, `signed`에서 결과가 표현 범위를 벗어나면 미정의 동작이 된다.
>   반면 `&`, `|`, `^`는 비트 패턴 편집에 가까워서, 부호 비트를 건드린 것만으로 미정의 동작이 되지는 않는다.
>   
> - **그런데 조심해야 하는 이유는? (논리적 위험)**
>   `signed` 정수는 가장 왼쪽 비트가 부호에 관여한다.
>   그래서 그 비트를 바꾸면 숫자의 의미가 통째로 뒤집힌다.
>   1. **`&` (끄기):** 음수(`1...`)의 부호를 끄면? 갑자기 거대한 양수가 된다.
>   2. **`|` (켜기):** 양수(`0...`)의 부호를 켜면? 갑자기 거대한 음수가 된다.
>   3. **`^` (반전):** 부호 비트를 토글하면? 양수와 음수 사이에서 널뛰기를 한다.
> 
> - **실전 안전 규칙**
>   숫자가 아니라 비트 패턴을 다루는 용도라면 처음부터 `unsigned`로 저장하고 편집하는 습관이 가장 안전하다.
>   마스크도 `1u << n`처럼 `u`를 붙여 `unsigned`로 만들면 더 안전하다. 


### 17.6.2 `>>` (Right Shift): 오른쪽으로 밀기

- **동작:** 비트들을 오른쪽으로 n칸 민다. 음이 아닌 정수들은 왼쪽이 0으로 채워지고, 수학적으로 2의 거듭제곱으로 나눈 몫과 동일하다. 음수의 경우에는 구현마다 다르다. 

`>>`는 주로 n번째 이상 비트들의 정보를 추출하거나 2의 거듭제곱으로 나누기를 하기 위해서 쓴다. 

**왼쪽 비트 정보 추출하기**

왼쪽에 모여 있는 데이터들을 0번 자리(1의 자리)로 끌고 내려와서 값을 읽을 때 사용한다.
예를 들어, 8비트 데이터 중 5번~7번 자리(가장 왼쪽 3개)에 필요한 정보가 있다고 가정해보자.

- 목표: 5번 자리에 있는 비트를 0번 자리로 옮겨야 한다. 그래서 5칸을 이동한다.
```
    Index:    [7][6][5][4] [3][2][1][0]
    Original:  1  1  1  0   1  0  1  0   (0xEA)
               |  |  |
                       ↘ ↘ ↘           (5칸 밀기)
                               |  |  |
    >> 5:      0  0  0  0   0  1  1  1   (0x07)
    -------------------------------------------
    결과: 7 (왼쪽 비트 111을 숫자 7로 읽음)
```

**2의 거듭제곱으로 나누기**

오른쪽으로 1칸 밀 때마다 값은 절반(1/2)이 된다.
즉, `>>` $n$ 연산은 정수를 $2^n$으로 나눈 몫을 구하는 것과 같다.

* **장점:** 일반 나눗셈 연산자(`/`)보다 CPU 처리 속도가 훨씬 빠르다.
  (최신 컴파일러는 $2^n$으로 나누는 코드를 보면 자동으로 시프트 연산으로 최적화해준다.)

- 99를 8로 나누기 
```
    Index:    [7][6][5][4] [3][2][1][0]
    Original:  0  1  1  0   0  0  1  1   (99)
               |  |  |  |   |
                     ↘ ↘ ↘ ↘ ↘       (5칸 밀기)
                        |   |  |  |  |
    >> 2:      0  0  0  0   1  1  0  0   (12)
    -------------------------------------------
    결과: 12 (99 / 8의 결과와 동일)
```

> [!NOTE]
> **구현은 보통 음수의 오른쪽 시프트를 어떻게 구현할까?**
>
> 대부분의 현대 CPU는 오른쪽 시프트 명령어를 두 가지 버전으로 나누어 제공한다.
> 
> 1. **논리 시프트 (Logical Shift):** 비는 자리를 무조건 `0`으로 채운다.
>    - 컴파일러들은 `unsigned` 타입에 대해 이 명령어를 쓴다.
> 2. **산술 시프트 (Arithmetic Shift):** 비는 자리에 부호 비트를 복사해서 채운다. 
>    - 대부분의 컴파일러는 `signed` 타입에 대해 주로 이 명령어를 쓴다.
>    - 음수일 때 부호 비트가 1이므로, 1이 채워진다. 
>
> **결론:**
> - 양수: 비는 자리가 항상 0으로 채워진다.
> - 음수: 컴파일러마다 다른 것이 허용되지만, 대다수 시스템은 부호를 유지하기 위해 비는 자리를 1로 채운다.

> [!WARNING]
> **음수 칸 이동과 과도한 이동 금지**
>
> C 표준은 다음의 경우를 정의되지 않은 동작으로 규정한다. 즉, 프로그램이 멈추거나 엉뚱한 값을 내뱉을 수 있다.
> 1. **음수 칸 이동:** 이동할 비트 수(오른쪽 피연산자)가 음수일 때.
> 2. **과도한 이동:** 이동할 비트 수(오른쪽 피연산자)가 왼쪽 피연산자 타입의 비트 너비보다 크거나 같을 때.
>    - 32비트 `int` 변수를 `>> 32` 하거나 `>> 33` 하는 경우.
>
> **왜 정의되지 않은 동작으로 규정되었을까?**
>
> 1. **하드웨어의 현실:** CPU 최적화
> 많은 CPU는 시프트 속도를 높이기 위해, 이동할 횟수를 그대로 쓰지 않고 데이터 비트 수로 나눈 나머지만 본다.
> - 예시: 32비트 CPU에서는 이동 횟수의 오른쪽 5비트만 읽는다. (0부터 31까지 숫자 표현 가능)
> - 상황: `x >> 32`를 요청했을 때, 32를 이진수로 나타낸 `100000`이 이동 횟수로 입력된다.
> - 결과: CPU는 오른쪽 5비트인 `00000`만 보고 0칸 이동하라고 해석한다. 결국 값은 변하지 않는다.
>
> 2. **C 언어의 철학:** 성능 우선
> 만약 C 언어 표준에서 32칸 이상 밀면 무조건 0이 되게 하라고 강제했다면?
> 컴파일러들은 모든 시프트 연산에 이동 횟수가 32보다 큰가를 확인하는 `if`문 검사 코드를 추가해야 한다.
> - 그 결과 아주 단순하고 빠른 연산인 시프트가 검사 때문에 느려지게 된다 (오버헤드 발생).
> - C 언어는 프로그래머가 알아서 조심하고, 속도를 최대로 뽑아라는 주의기 때문에 안전장치를 포기하고 하드웨어 명령어를 그대로 실행하게 둔다.
>
> **안전한 범위 체크(표준식)**
> 비트 폭은 다음처럼 구할 수 있다.
>
> ```c
> #include <limits.h> /* CHAR_BIT */
> 
> /* 폭 = (바이트 크기) * (1바이트의 비트 수) */
> /* 예: unsigned int면 sizeof(unsigned int) * CHAR_BIT */
> ```
>
> 시프트하기 전에 0 <= n < 비트폭을 보장하자.

## 17.7 여러 플래그 조합해서 다루기

### 17.7.1 플래그 값을 함수로 전달/리턴하는 패턴 (옵션, 상태, 기능)

마스크와 비트 연산자들은 여러 플래그들을 함수 인자로 전달하거나 함수 실행 결과로 리턴받을 때도 유용하게 쓰인다. 

**함수의 설정 인자: 인자 지옥 탈출**
센서를 초기화하거나 설정을 변경하는 함수를 만든다고 가정해보자. 
옵션이 늘어날수록 함수의 매개변수도 계속 늘어나는 문제가 생긴다.

나쁜 예: 참/거짓 변수의 나열
```c
/* 센서 설정: 활성화? 고정밀도? 인터럽트 사용? 저전력 모드? ... */
void init_sensor(int is_active, int high_precision, int use_interrupt, int low_power, int auto_reset);

/* 호출할 때: 도대체 저 0과 1이 무슨 뜻인지 알 수가 없다. */
init_sensor(1, 0, 1, 1, 0);
```

이렇게 인자가 주렁주렁 달리는 현상을 인자 폭발(Parameter Explosion)이라고 부른다. 
가독성이 떨어지고, 옵션이 하나 추가될 때마다 함수 원형을 뜯어고쳐야 한다.

해결책은, 모든 옵션을 비트 플래그로 정의하고, `config` 인자 하나만 받는 것이다.

좋은 예: 플래그 하나로 통합
```c
/* 설정 옵션 정의 */
#define CFG_ENABLE       (1 << 0)  /* 0000 0001 센서 활성화 */
#define CFG_HIGH_PREC    (1 << 1)  /* 0000 0010 고정밀 모드 */
#define CFG_INTERRUPT    (1 << 2)  /* 0000 0100 데이터 준비시 알림 */
#define CFG_LOW_POWER    (1 << 3)  /* 0000 1000 저전력 모드 */

/* 함수 정의: 인자가 깔끔해졌다 */
void init_sensor(unsigned int config) {
    /* 내부에서 비트 연산으로 옵션 확인 */
    if (config & CFG_ENABLE) { /* 센서 켜기 */ }
    if (config & CFG_HIGH_PREC) { /* 정밀도 높이기 */ }
    /* ... */
}

/* 호출할 때: 의도가 명확하게 보인다 (가독성 UP) */
init_sensor(CFG_ENABLE | CFG_INTERRUPT | CFG_LOW_POWER);
```
만약 아무 옵션도 주고 싶지 않다면? 그냥 `0`을 넘기면 된다.

**기능 명세(Capabilities): "난 이걸 할 수 있어"**

스마트홈 허브(서버) 입장에서, 연결된 장치가 어떤 기능을 가지고 있는지 파악해야 할 때가 있다. 
장치는 자신의 능력(Capability)을 비트 마스크로 묶어서 서버에 보고한다.

```c
#define CAP_TEMP     (1 << 0)	/* 0000 0001 온도 측정 가능 */
#define CAP_HUMID    (1 << 1)	/* 0000 0010 습도 측정 가능 */
#define CAP_DISPLAY  (1 << 2)	/* 0000 0100 화면 표시 가능 */

/* 예: 온습도 센서인데 화면은 없는 장치 */
const unsigned int my_caps = CAP_TEMP | CAP_HUMID;

unsigned int report_caps()
{
	return my_caps;
}
```

### 17.7.2 상태 검사하기: "하나라도?" vs "전부 다?"

함수 내부에서 `config`나 `status` 값을 전달받았다고 가정해보자. 이제 우리는 이 변수 안에 특정 옵션 스위치가 켜져 있는지 확인해야 한다.

단일 플래그 검사는 `if (status & FLAG)`로 간단하다.
하지만 "A와 B가 동시에 켜져 있는가?" 또는 "A나 B 중 하나라도 켜져 있는가?"를 물어볼 때는 방법이 갈린다.

**"하나라도 켜져 있나?" (ANY)**

- **상황:** "배터리가 부족하거나(LOW_BATTERY) 혹은 센서 에러(ERROR)가 있나요?" (시스템 경고등 점등 조건)
- **논리:** 마스크와 `&` 연산한 결과가 0이 아니면 된다.

```c
#define STATUS_LOW_BAT   (1 << 0)	/* 0000 0001 배터리 부족 상태 */
#define STATUS_ERROR     (1 << 1)	/* 0000 0010 센서 에러 상태 */

unsigned int status = get_status_from_device();
unsigned int mask = STATUS_LOW_BAT | STATUS_ERROR;

/* 마스크에 해당하는 비트가 하나라도 1이면 결과는 0이 아니다 */
if (status & mask) {
	/* 점검이 필요한 상태 알림 로직 */
}
```

**"전부 켜져 있나?" (ALL)**

- **상황:** "와이파이가 연결되어 있고(WIFI), 동시에 전원도 연결되어 있나요(POWER)?" (펌웨어 업데이트 조건)
- **논리:** 마스크와 `&` 연산한 결과가 마스크 값과 정확히 같아야 한다.
- **주의:** 단순히 `&`만 하면, 둘 중 하나만 켜져 있어도 참이 되기 때문에 엄격한 검사가 안 된다.

```c
#define STATUS_WIFI      (1 << 2)
#define STATUS_POWER     (1 << 3)

unsigned int mask = STATUS_WIFI | STATUS_POWER;

/* (status & mask)의 결과가 mask(원형)와 똑같은지 비교해야 한다 */
if ((status & mask) == mask) {
	/* 펌웨어 업데이트 실행 로직 */
}
```

> [!WARNING]
> **치명적인 함정: 연산자 우선순위**
>
> C 언어 초심자가 가장 많이 겪는, 찾기 힘든 버그 1순위다.
> **비교 연산자(`==`)는 비트 연산자(`&`)보다 우선순위가 높다.**
> ```c
> if (status & mask == mask)  /* 절대 이렇게 쓰면 안 된다! */
> ```
> 컴파일러는 이것을 `status & (mask == mask)`로 해석한다.
> `(mask == mask)`는 참이므로 `1`이 되고, 결국 `if (status & 1)`이라는 엉뚱한 코드가 되어버린다.
>
> **해결책:** 비트 연산에는 습관적으로 괄호를 치는 것이 좋다.
> `if ((status & mask) == mask)`

## 17.8 안전 수칙 (매우 중요)

비트 연산자는 컴퓨터의 가장 밑바닥을 건드리는 강력한 도구다.
하지만 C 언어는 프로그래머를 믿는다는 철학 하에 안전장치를 거의 두지 않았기 때문에,
자칫하면 프로그램이 멈추거나, 특정 CPU에서만 다르게 동작하는 심각한 버그를 만들 수 있다.

반드시 지켜야 할 4가지 안전 수칙을 정리한다.

### 17.8.1 왜 보통 `unsigned`로 비트 연산을 하라고 할까?

비트 연산 관련 코드를 보면 대부분 `unsigned int`나 `unsigned char`를 사용하는 것을 볼 수 있다.
단순히 습관이 아니다. `signed` 타입(부호 있는 정수)에는 산술적 의미가 섞여 있기 때문이다.

우리가 비트 연산을 하는 목적은 데이터를 숫자로 보는 것이 아니라 비트 패턴(0과 1의 조합)으로 다루기 위함이다.
그런데 `signed` 타입은 맨 앞 비트(MSB)를 '부호'로 해석하기 때문에 다음과 같은 문제가 발생한다.

**1. 오른쪽 시프트(`>>`)의 모호함**
음수를 오른쪽으로 밀 때, 빈자리를 `0`으로 채울지(논리 시프트), `1`로 채울지(산술 시프트)는 C 표준에서 구현 정의(컴파일러 마음)로 남겨두었다.
그래서 내 컴퓨터에서는 잘 돌아가던 코드가 다른 컴퓨터에서는 오동작할 수 있다.
반면 `unsigned`는 무조건 `0`으로 채워짐이 보장된다.

**2. 의도치 않은 값의 변화**
`signed int`에서 가장 왼쪽 비트를 건드리는 것은 곧 양수를 음수로, 음수를 양수로 바꾸는 행위다.
이는 나눗셈이나 곱셈 등 이후의 연산에서 예기치 않은 버그를 만든다.

비트 연산을 할 때는 변수를 선언할 때부터 `unsigned`를 쓰거나, 연산 시점에 `(unsigned int)`로 캐스팅(타입 변환)해서 사용하는 것이 원칙이다.

### 17.8.2 시프트 위험 구간

시프트 연산(`<<`, `>>`)은 빠르지만, 입력값의 범위에 매우 민감하다.
다음 3가지 경우는 정의되지 않은 동작(Undefined Behavior)이거나 치명적인 오류를 유발한다.

**음수 시프트 (Negative Shift)**

이동할 비트 수(오른쪽 피연산자)가 음수면 안 된다.
"왼쪽으로 -3칸 밀어라"는 "오른쪽으로 3칸 밀어라"와 같지 않다. CPU는 이를 이해하지 못한다.

```c
int x = 10;
x = x << -3;  /* (X) 프로그램이 터지거나 잘못된 값이 나옴 */
```

**과도한 시프트 (Excessive Shift)**

이동할 비트 수가 데이터 타입의 너비보다 크거나 같으면 안 된다.
32비트 정수를 32칸 밀면 0이 될 것 같지만, 실제 하드웨어는 시프트 횟수를 `masking` 하기 때문에 아무 일도 안 일어나거나 엉뚱한 결과가 나온다.

```c
int x = 10;
x = x << 32;  /* (X) 32비트 환경에서 UB 발생 */
x = x << 33;  /* (X) */
```

**부호 비트 침범 (Sign Bit Overflow)**

`signed` 타입에서 `<<` 연산을 하다가 `1`이 최상위 비트(부호 비트)를 건드리면 값이 음수로 변한다.
C 언어 표준(특히 C99 이전)에서는 `signed` 정수의 오버플로우를 "정의되지 않은 동작"으로 간주한다.

```
int x = 0x7FFFFFFF; /* 양수 최댓값 */
x = x << 1;         /* (X) 부호 비트를 건드려 음수가 됨 (오버플로우) */
```

### 17.8.3 우선순위 함정과 괄호 습관

C 언어의 연산자 우선순위 중 가장 헷갈리고 위험한 부분이 바로 비트 연산자와 비교 연산자의 순서다.

**함정: `==`, `!=`가 `&`, `|`, `^`보다 우선순위가 높다.**

다음 코드를 보자. 2번 비트가 켜져 있는지 확인하고 싶었다.

```c
if (flags & MASK == MASK)  /* 버그 발생! */
```

프로그래머의 의도는 `(flags & MASK) == MASK`였겠지만,
컴파일러는 `flags & (MASK == MASK)`로 해석한다.

1. `(MASK == MASK)`가 먼저 실행되어 `1`(True)이 된다.
2. 결국 `if (flags & 1)`이 되어, 엉뚱하게 0번 비트를 검사하게 된다.

비트 연산자가 다른 연산자(비교, 산술 등)와 섞여 있다면, 무조건 괄호 `()`로 감싸는 습관을 들여야 한다. 과한 괄호는 죄가 아니지만, 부족한 괄호는 재앙이다.

### 17.8.4 매크로로 마스크 만들 때 괄호를 왜 꼭 치나

비트 마스크는 편리함을 위해 매크로 함수(`define`)로 만들어 쓰는 경우가 많다.
이때 괄호를 아끼면 "매크로 확장" 과정에서 연산자 우선순위가 깨지는 대참사가 일어난다.

**나쁜 예**
```c
#define BIT(n)  1 << n

int val = BIT(0) + 5; /* 1 + 5 = 6을 기대함 */
```
우리는 `1 << 3` (즉, 8)을 기대한다. 하지만 전처리기는 이를 기계적으로 치환한다.

```c
int val = 1 << 0 + 5;
```

덧셈(`+`)이 우선순위가 높으므로 `1 << (0 + 5)`가 되어 `1 << 5` (32)가 나온다.
완전히 틀린 값이다.

**좋은 예**

매크로를 만들 때는 **인자**와 **전체 식**을 모두 괄호로 감싸야 한다.
```c
#define BIT(n)  (1 << (n))
```

이렇게 하면 `BIT(0) + 5`는 `(1 << (0)) + 5`가 되어 안전하다.
