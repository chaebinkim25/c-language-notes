# 2장. C 프로그램의 기본 구조

## 2.1 프로그램과 C 언어

본격적인 코드를 작성하기 전에, 우리가 지금 무엇을 하려는 것인지 잠시 짚고 넘어가자. 
우리는 프로그래밍을 배우려고 한다. 그렇다면 프로그램이란 도대체 무엇일까?

**프로그램(program)이란 무엇인가?**

컴퓨터는 스스로 생각해서 움직이는 기계가 아니다. 
누군가 "무엇을, 어떻게 해라"라고 아주 구체적으로 시키지 않으면 아무것도 할 수 없는, 
그저 전기가 흐르는 고성능 깡통에 불과하다.

프로그램이란 이 융통성 없는 컴퓨터에게 "어떤 일을 어떤 순서로 처리해라"라고 적어 놓은 작업 지시서다.

- 요리사가 **레시피**를 보고 요리를 하듯,
- 연주자가 **악보**를 보고 연주를 하듯,
- 컴퓨터는 **프로그램**을 보고 일을 한다.

즉, 우리가 프로그램을 짠다는 것은 컴퓨터에게 건네줄 작업 지시서를 작성하는 행위다.

> [!NOTE]
> **보안 관점: 융통성이 없다는 것의 의미**
>
> 컴퓨터는 "아, 주인이 실수했구나, 이건 실행하면 안 되겠다"라고 판단하지 않는다.
> "바이러스를 다운로드해서 실행해"라고 적혀있으면, 컴퓨터는 그 명령이 자신을 파괴할지라도 군말 없이 실행한다.
> 그래서 우리는 프로그래밍을 할 때 정확성과 보안을 항상 고민해야 한다. 

**프로그래밍 언어란 무엇인가?**

문제는 컴퓨터와 우리가 쓰는 언어가 근본적으로 다르다는 점이다. 
컴퓨터는 전압이 높다(1), 낮다(0)라는 전기 신호로 이루어진 기계어를 쓴다.
반면 사람은 한국어나 영어 같은 자연어를 쓴다.

컴퓨터에게 건네줄 작업 지시서를 0과 1로된 기계어로 직접 작성하는 일은 사람에게 너무나 고통스럽고 비효율적이다.
그렇다고 "대충 알아서 해줘"라고 한국어로 말하면, 융통성이 없는 컴퓨터는 알아듣지 못한다. 
사람의 말은 상황에 따라 뜻이 달라지는 모호성이 있기 때문이다.

그래서 타협점이 필요하다.
사람에게도 어느 정도 익숙하면서, 기계어로 번역하기에도 명확한 중간 단계의 언어가 필요하다.
그 역할을 하는 것이 프로그래밍 언어다.

- 소스 코드(Source Code): 우리가 프로그래밍 언어 문법에 맞춰 작성한 지시서
- 컴파일러(Compiler): 이 지시서를 컴퓨터가 이해할 수 있는 기계어(0, 1)로 완벽하게 번역해주는 통역사

우리는 C 언어라는 약속된 문법으로 소스 코드를 짜고, 컴파일러에게 "번역해!"라고 시키면, 컴퓨터가 실행할 수 있는 프로그램이 완성되는 것이다.

**왜 하필 C 언어인가?**

세상에는 파이썬, 자바, C++ 등 수천 가지의 프로그래밍 언어가 존재한다. 그중에서 우리는 왜 하필 1972년에 태어난 오래된 C 언어를 가장 먼저 배울까?

그 이유는 C 언어가 컴퓨터의 가장 깊은 곳(운영체제, 하드웨어 제어)에 있어서 만큼은 여전히 가장 강력한 언어이기 때문이다.

자동차에 비유해보자. 요즘 유행하는 파이썬이나 자바가 자율 주행 기능이 달린 최신 세단이라면, C 언어는 그 자동차의 엔진과 바퀴를 직접 조립하는 기술에 가깝다. 자율 주행 차는 운전하기 편하지만, 차가 고장나거나 내부 구조를 튜닝하고 싶을 때는 본넷을 열어 엔진을 볼 줄 알아야 한다. 

특히 보안을 공부하는 우리에게 C 언어는 선택이 아닌 필수다. 해커들은 시스템의 편리한 겉모습이 아니라, 감춰진 메모리와 하드웨어의 약점을 파고든다.  파이썬은 이 복잡한 메모리 관리를 자동으로 처리해 숨겨버리지만, C 언어는 메모리의 날것 그대로를 보여준다. 컴퓨터가 실제로 어떻게 작동하는지, 그리고 어디서 보안 구멍이 뚫리는지를 배우기에 가장 적합한 언어다.

## 2.2 C 프로그램의 시작, `main`

다시 처음 질문으로 돌아가서, C 언어로 작업 지시서(프로그램)를 만들 때 가장 중요한 규칙은 무엇일까?

C 프로그램은 수많은 명령어들로 이루어져 있지만, 컴퓨터는 항상 정해진 한 지점부터 읽기 시작한다.

그 시작점의 이름이 바로 `main`이다.

**프로그램의 시작 버튼**

우리가 기계를 작동시킬 때 전원 버튼이나 시작 버튼을 가장 먼저 누르듯이, 컴퓨터도 프로그램을 실행할 때 무조건 `main`이라는 이름을 찾는다.

- 컴퓨터는 `main`을 찾아서,
- 그 안에 적힌 명령어들을 차례대로 실행한다.

그래서 어떤 C 프로그램이든 반드시 `main`이라는 작업 단위가 하나는 있어야 하며, 이것이 없으면 컴퓨터는 어디서 시작해야 할지 몰라 헤매게 된다.

## 2.3 `main`의 생김새: 소괄호와 중괄호

C 프로그램의 시작점인 `main`은 보통 다음과 같이 생겼다.
왜 이름 뒤에 `()`가 붙고, 그 아래에는 `{}`가 있을까?

```c
int main(void)
{
        /* 컴퓨터가 수행할 명령들... */
}
```

이것은 기계를 작동시키는 원리와 똑같다.

**소괄호 `()` : 시작할 때 필요한 준비물**

세탁기를 돌린다고 상상해 보자. 시작 버튼을 누르기 전에 준비물인 세제를 넣거나, 표준 세탁인지 이불 세탁인지 설정을 알려줘야 한다.

`main` 뒤에 붙은 소괄호 `()`가 바로 이 준비물에 해당하는 입력을 넣는 투입구다.

- `main(재료)`: "이 재료를 가지고 시작해!"
- `main(void)`: 여기서 `void`는 '비어있다'는 뜻이다. "아무런 준비물 없이 그냥 시작 버튼만 누르면 돼"라는 의미다.

**중괄호 `{ }` : 기계가 수행할 '할 일 목록'**

시작 버튼을 누르면 기계는 내부적으로 복잡한 일들을 처리한다. 물을 채우고, 세제를 가져와서 세탁을 하고, 헹구고, 탈수를 한다.

중괄호 `{ }`는 이 프로그램이 수행해야 할 구체적인 작업 지시서(명령어)들을 하나로 묶어주는 역할을 한다.

- `{` (열기): "자, 여기서부터 작업 목록 시작이다!"
- `}` (닫기): "여기까지가 끝이다. 작업 종료!"

결국 우리가 코드를 짠다는 것은, `{`와 `}` 사이에 컴퓨터가 해야 할 일들을 순서대로 적어주는 것이다. 컴퓨터는 이 중괄호 안의 세상에서만 움직인다.

> [!TIP]
> **함수(Function): 명령어 묶음**
> 
> C 언어에서는 이렇게 특정 작업을 수행하는 명령어 묶음을 함수(Function)라고 부른다. 수학 시간에 배운 함수와는 조금 다르니, 지금은 "아, C에서는 작업 단위를 함수라고 부르는구나" 정도만 알아두자.

## 2.3 가장 단순한 C 프로그램

이번에는 실제로 C 프로그램이 어떻게 생겼는지, 가장 단순한 예제 하나를 살펴보자.

```c
int main(void)
{
        return 0;
}
```

이 코드는 아무 일도 하지 않고 바로 끝나는 썰렁한 C 프로그램이다.
하지만 놀랍게도 C 프로그램의 모든 핵심 구조가 이 안에 들어 있다.

**`int main(void)`: 입구와 출구**

- **`main`:** 프로그램의 시작점이다. 컴퓨터는 항상 여기서부터 실행을 시작한다.
- **`(void)`:** '비어 있음'을 뜻한다. 시작할 때 아무런 준비물도 필요 없다는 뜻이다.
- **`int`:** '정수(Integer)'의 약자다. 이 프로그램이 끝날 때, 운영체제에게 정수 값 하나를 보고(반환)한다는 약속이다.

**`{ ... }`: 작업 영역**

- **`{ }`:** 중괄호는 "여기부터 여기까지가 `main`이 할 일이다"라는 구역 표시다. 컴퓨터는 이 안의 내용만 실행한다.

**`return 0;`: 보고와 종료**

- **`return 0`:** 프로그램을 끝내면서 운영체제에게 `0`이라는 값을 던져준다.
- **`0`:** 컴퓨터 세계에서 0은 보통 에러 없음을 의미한다. (반대로 1이나 -1은 에러 발생을 뜻한다.)
- **`;`:** C 언어에서 명령어가 끝날 때는 반드시 세미콜론을 찍어야 한다. 한국어의 마침표와 같다. `;`를 빼먹으면 컴퓨터는 문장이 안 끝난 줄 알고 에러를 낸다.

**정리: 이 프로그램의 실행 흐름**

1. 운영체제가 `main`을 찾아 실행을 시작한다.
2. (할 일이 없으므로) 특별한 작업은 하지 않는다.
3. `return 0;`을 만나 운영체제에게 "문제 없이 끝났음(`0`)"을 보고하고 종료된다.

앞으로 우리가 만들 거대한 프로그램들도, 결국 이 기본 뼈대 안에 내용을 하나씩 덧붙여 나가는 것뿐이다.

## 2.4 문장과 실행 순서

지금까지 C 프로그램이 어디서 시작하는지(`main`), 어떤 범위가 함께 묶이는지(`{ }`)를 봤다.
이번에는 `{ }` 안에 적힌 내용이 어떤 순서로 실행되는지를 알아보자.

**문장(Statement)과 세미콜론(`;`)**

우리가 친구에게 생각을 전할 때 문장으로 말하듯이, 컴퓨터에게 명령을 내릴 때도 문장을 사용한다.

C 프로그램 안에는 "이것을 계산해라", "화면에 결과를 보여줘라"와 같이 구체적인 행동을 지시하는 명령들이 들어 있다. 이러한 실행 지시 하나하나를 문장(statement)이라고 부른다.

**중요한 규칙: 문장 끝에 `;`**

우리가 글을 쓸 때 문장 끝에 마침표(.)를 찍듯이, C 언어에서는 **문장이 끝날 때마다 반드시 세미콜론(`;`)을 찍어야 한다.**

```c
return 0;                  /* 문장이 끝났으므로 ;를 붙인다. */
/* 화면에_표시해라(); */    /* 나중에 배울 명령들도 끝에는 무조건 ;를 붙인다. */
```

`;`를 빼먹으면 컴퓨터는 문장이 아직 안 끝난 줄 알고 뒷내용과 억지로 이으려다 에러를 낸다.

**실행 순서: 적힌 순서대로**

우리가 책을 읽을 때 첫 번째 줄부터 차례대로 읽어 내려가듯이, 컴퓨터도 코드를 읽을 때 첫 번째 문장부터 차례대로 읽고 실행한다.

컴퓨터에게 일을 시키는 실행 문장들은 모두 중괄호 `{ }` 안에 들어간다. 그리고 이 문장들은 적힌 순서가 매우 중요하다.

```c
int main(void)
{
        물_끓이기();    /* 1. 가장 먼저 실행 */
        라면_넣기();    /* 2. 1번이 끝나면 실행 */
        3분_기다리기(); /* 3. 2번이 끝나면 실행 */
        return 0;
}
```

컴퓨터는 이 코드를 절대 뒤죽박죽 실행하지 않는다.

1. 가장 위에 있는 1번 문장을 먼저 처리하고,
2. 그 작업이 완전히 끝나면 2번 문장으로 넘어가며,
3. 마지막으로 3번 문장을 실행한다.

즉, 프로그래머가 작성한 순서가 곧 실행 순서가 된다.

**실행 순서가 바뀔 때 (제어 흐름)**

시냇물이 흐르다가 바위를 만나면 갈라지거나, 웅덩이에서 잠시 머무는 것처럼 프로그램의 실행 순서도 바뀔 때가 있다.

프로그램을 작성하다 보면 무조건 아래로만 가는 게 아니라, 다음과 같은 상황이 꼭 필요하기 때문이다.

- **갈림길 (조건문):** 비가 오면 우산을 쓰고, 안 오면 그냥 간다.
- **제자리 돌기 (반복문):** 운동장을 10바퀴 뛸 때까지 계속 돈다.

나중에 배우겠지만, 흐름을 제어하는 특별한 문장을 쓰면 물길을 트듯이 실행 순서를 바꿀 수 있다.

## 2.5 들여쓰기(Indentation)와 코드 읽기 규칙

책을 읽을 때 문단이 나뉘어 있지 않고 글자들이 빽빽하게 붙어 있다면 읽기 힘들 것이다. 코드도 마찬가지다.

```c
int main()
{
        어떤 문장;
        또 다른 문장;
}
```

이렇게 줄을 안쪽으로 밀어서 쓰는 것을 들여쓰기(Indentation)라고 한다.

**컴파일러는 들여쓰기를 모른다**

중요한 점부터 말하면, C 언어에서 들여쓰기는 문법 규칙이 아니다.

- 들여쓰기를 하지 않아도,
- 띄어쓰기를 여러 번 해도,
- 줄 바꿈을 하지 않고 한 줄에 다 써도,

프로그램의 동작이나 의미는 바뀌지 않는다. 컴파일러는 오직 세미콜론(`;`)과 중괄호(`{}`)만 볼 뿐, 빈칸이나 줄 바꿈은 공기 취급한다.

그래서 아래처럼 코드를 한 줄에 욱여넣어도 프로그램은 아무 문제 없이 완벽하게 돌아간다.

```c
int main(void){return 0;}
```

하지만 사람은 들여쓰기에 의존한다. 
우리가 꼬박꼬박 들여쓰기를 하는 이유는 오직 사람(동료와 미래의 자신)이 코드를 읽기 쉽게 만들기 위해서다.

**들여쓰기는 구조를 보여주는 시각적 장치다.**

앞서 본 것처럼 C 프로그램은 중괄호 `{ }`로 실행 범위를 나눈다. 들여쓰기는 이 구조를 눈으로 바로 알아볼 수 있게 해준다.

**나쁜 예 (들여쓰기 없음):** 구조가 눈에 안 들어온다.
```c
{
문장1;
{
문장2;
}
문장3;
}
```

- **좋은 예 (들여쓰기 적용):** 포함 관계가 명확하다.
```c
{
        문장1;
        {
                문장2;  // 아, 이건 안쪽 중괄호구나!
        }
        문장3;
}
```

**들여쓰기의 기본 규칙과 보안**

C 코드에서 가장 널리 쓰이는 들여쓰기 규칙은 다음과 같다.

- **규칙:** 중괄호 `{`가 열릴 때마다 한 단계씩 안으로 들어간다.
- **간격:** 보통 탭 1번 또는 스페이스 4칸 또는 스페이스 8칸을 사용한다. (팀마다 다르니 통일하는 게 중요하다.)

> [!NOTE]
> **보안 관점: 들여쓰기는 거짓말을 한다**
>
> 보안 전문가가 코드를 분석할 때 가장 조심해야 할 것이 바로 잘못된 들여쓰기다.
>
> 해커들은 가끔 고의로 들여쓰기를 엉망으로 해서,
> 실제로는 실행되지 않는 코드를 마치 실행되는 것처럼 보이게 속이기도 한다.
> (애플의 유명한 'goto fail' 보안 버그도 이런 실수에서 시작되었다.)
>
> 기억하자. 컴퓨터는 들여쓰기를 믿지 않는다. 오직 중괄호 `{}`만 믿는다. 우리도 그래야 한다.

## 2.7 빌드 (build): C 프로그램은 어떻게 실행 파일이 되는가

우리가 적은 C 코드는 그저 영어 단어들이 적힌 텍스트 파일일 뿐이다.
컴퓨터는 0과 1밖에 모르기 때문에, 이 영어 문장들을 당장 이해할 수 없다.

그럼, 우리가 작성한 텍스트 파일은 어떻게 실제로 실행되는 프로그램이 될까?

그 과정은 요리와 비슷하다. 크게 3단계로 나뉜다.

**전처리(Preprocessing): 재료 다듬기**

본격적인 처리(요리)를 하기 전에 코드를 깔끔하게 정리하는 단계다.

- **주석 제거:** 사람이 보려고 쓴 설명글(주석)은 컴퓨터에게 필요 없으니 모두 지워버린다.
- **도구 준비:** 만약 외부에서 가져와야 할 파일이나 도구가 있다면 이때 챙겨온다. 

전처리 과정이 끝나면 군더더기 없는 순수한 코드만 남는다.

**컴파일(Compiling) - 부품 만들기**

이제 정리된 코드를 컴퓨터가 이해할 수 있는 기계어(0과 1)로 번역한다.
번역 작업을 하는 프로그램을 컴파일러(Compiler)라고 한다.

- **문법 검사:** 오타나 문법 오류가 있는지 깐깐하게 체크한다. (에러가 나면 여기서 멈춘다.)
- **오브젝트 파일(.obj) 생성:** 문법이 맞다면 기계어로 번역해 부품(Object File)을 만든다.

하지만 아직 실행할 수는 없다. 이것은 자동차로 치면 엔진만 만든 상태이기 때문이다. 바퀴나 핸들이 없어서 달릴 수 없다.

**3단계: 링크(Linking) - 조립하기**

우리가 만든 부품(오브젝트 파일)과, 시스템에서 제공되는 기본 부품들(라이브러리) 중 우리의 코드에서 쓰이는 부분들을 하나로 합치는 단계다.

- **부품 조립:** 흩어져 있는 기계어 코드들을 하나로 연결한다.
- **실행 파일(.exe) 생성:** 최종적으로 실행 가능한 파일(Windows에서는 .exe 파일)을 만든다.

합치는 작업을 하는 프로그램을 링커(Linker)라고 한다.

> [!NOTE]
> **보안 관점: 리버스 엔지니어링(Reverse Engineering)**
>
> 해커들은 종종 이 과정을 거꾸로 수행한다.
> 완성된 실행 파일(.exe)을 분해해서, 기계어를 읽고, 원래의 C 코드가 무엇이었는지 추측해 낸다.
> 리버스 엔지니어링(Reverse Engineering)이라고 부르며, 악성코드를 분석하거나 게임의 치트키를 만들 때 주로 사용된다.


