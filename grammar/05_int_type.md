# 5장. `int`: C 언어의 기본 정수 타입

앞장에서 우리는 데이터가 생성되고, 계산되고, 저장되고, 사용되고, 사라지는 흐름을 다뤘다. 
그 흐름을 머릿속 상상이 아닌 실제 코드로 구현해 볼 차례가 되었다. 

컴퓨터는 이름 그대로 계산하는 기계다. 
계산하려면 가장 먼저 필요한 것이 무엇일까? 
요리사에게 식재료가 중요하듯, 계산에는 숫자 데이터가 필수다.

C 언어에는 숫자를 다루는 여러 가지 방법(타입)이 있지만, 우리는 가장 기본이 되는 정수 타입 `int`부터 다룬다. 

## 5.0 이 장의 목표

이 장의 목표는 명확하다. 
6장의 조건문(`if`), 그리고 7장의 반복문(`for`)으로 넘어가기 위한 기초 체력을 다지는 것이다.

- **`int` 타입 변수 선언과 초기화:** 선언을 통해 정수를 담을 메모리 공간을 확보하고, 초기화를 통해 처음 저장할 값을 정한다.

- **계산하기 (산술 연산):** 더하고(`+`) 빼고(`-`) 곱하고(`*`) 나누는(`/`) 법을 배운다. 나머지 연산자(`%`)의 의미와 활용을 이해한다.

> [!TIP]
> **왜 `int`가 주인공일까?**
>
> `int`는 *integer*(정수)의 줄임말이다.
> C 언어에는 여러 정수 타입이 있지만, `int`는 가장 기본이 되는 정수 타입이다.
>
> `int`는 해당 시스템에서 가장 자연스럽게 처리되는 기본 정수 타입으로 정의되어 있다.
> 구체적인 크기는 시스템에 따라 다를 수 있다.
>
> 특별한 이유가 없다면 정수 계산에는 `int`를 사용하는 경우가 많다.

## 5.1 왜 하필 `int`부터 시작하나?

많은 입문자가 "나는 수학 계산 프로그램을 만들 것도 아닌데 왜 숫자부터 배우지?"라고 생각한다.
하지만 이것은 오해다. `int`는 단순히 계산을 위한 도구가 아니라, 프로그램의 흐름을 지휘하는 지휘봉이기 때문이다.

우리가 프로그램을 만들 때 가장 빈번하게 수행하는 작업들을 보자.

- **세기 (*counting*):** "하나, 둘, 셋..." 숫자를 센다. `count + 1`
- **반복 (*iteration*):** "이 작업을 10번만 해라." `i < 10`
- **순서 (*indexing*):** "첫 번째 데이터..." 데이터에 번호표를 붙인다. `data[0]`
- **분기 (*condition*):** "값이 0보다 크면 실행해라." `value > 0`
- **상태 (*state*):** "성공이면 0을 반환해라." `return 0;`

이 작업들의 공통점은 대부분 딱 떨어지는 정수의 계산과 비교로 이루어진다는 점이다.

소수점이 있는 실수(`3.14`)나 문자열(`"Hello"`)은 데이터의 내용을 담당하지만, 프로그램이 어디로 갈지, 몇 번 반복할지, 언제 멈출지를 결정하는 핵심 도구는 `int`다.

결국 흐름 제어는 값을 비교하는 문제로 귀결된다.

특히 C 언어에서는 참과 거짓조차도, `0`을 거짓, `0`이 아닌 값을 참으로 취급한다.
그래서 `int`를 알면 프로그램의 흐름을 제어하는 6장의 `if`와 7장의 `for`를 이해하는 데에도 도움이 된다.

## 5.2 `int`란 무엇인가?

`int`는 *integer*(정수)의 줄임말로, C 언어에서 가장 기본이 되는 데이터 타입이다.

**정수 규칙을 따른다.**

`int`는 소수점이 없는 정수만을 다룬다.

가장 큰 특징은 나눗셈 결과에 수학적으로 소수 부분이 생기더라도 이를 잘라낸다는 점이다. 여기서 자른다는 것의 의미는 0을 향해 자른다는 것이다 (*truncate toward zero*).

```c
5 / 2;    /* 결과: 2 (2.5에서 .5를 버림) */
-5 / 2;   /* 결과: -2 (-2.5에서 .5를 버림) */
```

> [!NOTE]
> **음수 나눗셈의 변화**
>
> C89 표준에서는 음수 나눗셈(`-5 / 2`)의 결과가 시스템마다 달랐다 (`-2` 또는 `-3`).
> 하지만 C99 표준 이후로는 0을 향해 자른다고 정의되었다.

**크기는 시스템에 따라 다르다**

`int`가 메모리에서 몇 바이트를 차지하는지는 사용하는 시스템과 컴파일러에 따라 다를 수 있다.

하지만 C 언어 표준은 적어도 이 정도는 보장하라는 최소 조건을 정해두었다.

- **최소 보장:** 16비트 이상이며, 적어도 -32,767부터 +32,767 이상의 범위를 표현할 수 있다.
- **현실적 크기:** 현대의 PC 환경에서는 보통 32비트 크기를 사용하는 경우가 많다. 약 ±21억 정도의 범위를 표현할 수 있다.

지금 단계에서는 일상적으로 사용하는 범위의 숫자는 충분히 표현할 수 있다고 이해하면 된다. 

> [!WARNING]
> **넘침 현상 (*overflow*)**
>
> 컵에 물을 계속 부으면 넘치듯이, `int`가 담을 수 있는 한계를 넘으면 오버플로우 (*overflow*)가 발생한다.
> 그 결과 프로그램이 멈추거나, 양수가 갑자기 음수로 변하는 등 예측할 수 없는 오류가 발생하므로 주의해야 한다.
> 아주 큰 수는 나중에 배울 `long long`등을 써야 한다. 

> [!TIP]
> **유연한 습관 기르기**
>
> C 언어는 슈퍼컴퓨터부터 아주 작은 센서(임베디드)까지 다양한 컴퓨터에서 동작하도록 설계되었다.
> 따라서 `int`는 항상 4바이트라고 가정하기보다는,
> 시스템이 정한 기본 크기를 따른다고 유연하게 생각하는 습관이 중요하다.

## 5.3 `int` 값을 코드에 적는 방법: 정수 리터럴
코드에 값 자체를 직접 적은 것을 리터럴(*literal*)이라고 부른다. C 언어에서 정수 리터럴은 우리가 아는 숫자를 쓰는 방식과 같이 적으면 된다.

```c
0
1
10
-3    /* 정수 리터럴 3 앞에 부호를 바꾸는 단항 연산자 -가 있다 */
2026
```

> [!WARNING]
> **정수 리터럴 앞 `0`의 의미**
>
> C 언어에서 `0`으로 시작하는 정수 리터럴은 8진수를 의미한다.
> 그래서 `012`라는 정수 리터럴의 값은 8진수를 10진수로 변환해보면 10이 된다.
>
> 숫자 `0` 하나만 쓰면, 8진수의 값이나 10진수의 값이나 똑같기 때문에 원래 의도한대로 0이다. 
>
> 10진수를 쓰려고 할 때는 앞에 0을 붙이지 말자. 

> [!WARNING]
> **정수 리터럴에서 `,`나 `_` 금지**
>
> C 언어에서 쉼표 `,`는 연산자로도 쓰이고, 값들을 구분하는 기호로도 쓰이기 때문에 정수 리터럴의 일부로 쓸 수 없다.
>
> 파이썬이나 자바에서처럼 정수 리터럴에 `_`를 써서 자릿수를 구분하는 방법도 C 언어에서는 금지다.
>
> ```c
> 1000000     /* OK */
> 1,000,000   /* ❌ 정수 리터럴이 아니다 */
> 1_000_000   /* ❌ C에서는 허용되지 않는다 */
> ```

> [!TIP]
> **작은 따옴표 `'`: 최신 표준 C23의 변화**
>
> 최신 표준인 C23부터는 숫자 가독성을 위해 작은 따옴표 `'`를 자릿수 구분 기호로 허용하기 시작했다.
> ```c
> 1'000'000   /* C23에서는 허용 */
> ```
> 아직 이 표준을 지원하지 않는 구형 컴파일러가 많으므로, 현업에서는 사용에 주의해야 한다. 

## 5.4 `int` 변수 (*variable*): 이름 붙인 `int` 상자

이전에 데이터를 상자에 담고 이름을 붙인다고 했다. 
C 언어에서 그 이름 붙은 상자가 바로 변수다 (*variable*).

### 5.4.1 선언 (*declaration*): 변수 만들기

상자를 만드는 행위를 선언이라고 한다. 
선언을 할 때는 타입과 이름을 적어주면 된다. 

```c
int x;
```
- **`int` (타입):** 이 상자는 `int` 타입으로 선언되어 해당하는 타입에 맞는 크기의 메모리가 할당된다. 저장된 값은 정수 규칙에 따라 해석되고 계산된다. 
- **`x` (이름):** 이 상자의 이름표는 x다.

> [!TIP]
> **한 번에 변수 여러개 만들기**
>
> 같은 타입의 변수가 여러 개 필요하다면 쉼표(`,`)로 구분해서 한 줄에 선언할 수도 있다.
>
> ```c
> int width, height;   /* 두 변수 모두 int 타입 */
> ```

> [!TIP]
> **변수 이름 짓기 규칙 (*naming rule*)**
>
> - 영어 대소문자(`a-z`, `A-Z`), 숫자(`0-9`), 밑줄(`_`)만 쓴다. (C89 기준 한글 ❌, 공백 ❌, 특수문자 ❌)
> - **숫자로 시작할 수 없다.** (`1st_player` ❌, `player1` ⭕)
> - **예약어는 사용할 수 없다.** (`int`, `return` 등)
> 
> **Q. 최신 C 언어는 한글 변수 이름도 된다던데?**
>
> A. 최신 표준(C23)부터 가능하지만, 추천하지 않는다.
> 일부 환경에서는 정상적으로 표시되지 않거나, 호환성 문제가 발생할 수 있다. 전 세계 공용어인 영어를 쓰자.


### 5.4.2 선언 위치: 무조건 맨 위에! (C89 규칙)

우리가 따르는 C89 표준에는 다음과 같은 규칙이 있다. 
변수 선언은 반드시 `{ }` 블록의 맨 처음에 몰아서 해야 한다.

요리를 시작하기 전에 필요한 재료(변수)를 조리대 위에 다 꺼내놓고 시작하는 방식이다.

```c
int main()
{
    /* [선언부] 변수는 여기서 모두 선언한다 */
    int i;
    int sum;

    /* [실행부] 실제 동작(대입, 계산)은 그 뒤에 한다 */
    
    /* 중간에 int k; 라고 선언하는 것은 C89에서는 허용하지 않는다 */

    return 0;
}
```

> [!NOTE]
> **선언 위치 관련 표준의 역사**
>
> 최신 C99부터는 중간중간 변수를 선언하는 것이 가능하다.
> 
> 하지만 우리는 입문자 입장에서 코드에서 쓰이는 변수 이름을 확실히 구분하기 위해 C89의 맨 위 선언 규칙을 따른다.

### 5.4.3 초기화 (*initialization*): 선언과 동시에 값 저장하기

변수(상자)를 만들면서 동시에 값을 저장하는 초기화 (*initialization*) 문법이 제공된다.

```c
int x = 10;    /* x에는 처음에 10이라는 값이 저장된다 */
```

> [!WARNING]
> **초기화의 함정: 모두 다 넣어주세요**
>
> ```c
> int a, b = 10, c;
> ```
>
> 위 코드를 보면 `a`와 `b` 모두 10으로 초기화될 것 같지만, C 언어는 그렇지 않다.
> 쉼표로 구분된 각각의 변수는 독립적으로 초기화된다. 
> `b`만 10이 되고, `a`와 `c`는 초기화되지 않는다!
> 모두 초기화하려면 `int a = 10, b = 10, c = 10;` 처럼 각각 적어줘야 한다. 

> [!CAUTION]
> **쓰레기 값 (*garbage value*) 주의보**
>
> 초기화를 하지 않고 `int x;`만 하면, 상자 안에 무엇이 들어있을까?
> 0이 들어있을 것 같지만, 실제로는 알 수 없는 값이 들어있다.
> 
> 왜 그럴까? (설거지 안 된 컵)
> 
> 컴퓨터는 메모리를 재활용하기 때문에, 이전에 사용되었던 메모리 내용이 그대로 남아있을 수 있다.
> (마치 식당 컵을 설거지 안 하고 그대로 쓰는 것과 같다!)
>
> 알 수 없는 값을 읽으면 정의되지 않은 동작이 발생할 수 있다 (*undefined behavior*). 
> 변수를 만들 때는 가능하면 초기화를 하거나, 사용하기 직전에 반드시 값을 대입해야 한다.


## 5.5 대입 (*assignment*): `int` 값을 바꾸는 가장 기본 동작

변수(상자)를 만들었으니, 이제 그 안에 값을 넣거나 바꿀 차례다.

### 5.5.1 `=`: 대입 연산자 (*assignment operator*)

```c
int main()
{
    int x;
    
    x = 10;    /* x 상자에 10을 저장한다. */
    x = 20;    /* x 상자에 20을 저장한다 (기존 10은 사라진다). */

    return 0;
}
```

여기서 사용된 `=` 기호를 대입 연산자라고 부른다. 

수학 시간의 기억 때문에 헷갈리기 쉽지만, 프로그래밍에서는 의미가 완전히 다르다.

- **`=` (대입):** 오른쪽의 계산 결과를 왼쪽 변수에 저장하고, 그 값 자체가 이 식의 결과가 된다.
- **`==` (비교):** 양쪽이 서로 같은지 비교하여 참(`1`) 또는 거짓(`0`)을 결과값으로 낸다. (나중에 배움)

***lvalue*와 *rvalue*: `=`의 왼쪽과 오른쪽의 엄격한 역할**

대입 연산자 `=`는 왼쪽과 오른쪽의 역할이 다르게 정해져 있다.

- **왼쪽 피연산자:** 값을 저장할 수 있는 대상만 올 수 있다 (*lvalue*, left value에서 유래). 
- **오른쪽 피연산자:** 어떤 값이든 올 수 있다 (*rvalue*, right value에서 유래).

```c
int x;
x = 10;      /* OK: 변수 x에 값 10을 대입한다. */
/* 10 = x;      Error: 10 이라는 숫자는 값을 담을 수 있는 상자가 아니다. */
```

**덮어쓰기 (*overwrite*):** 과거는 묻지 마세요

위 코드에서 `x = 10;`을 실행한 뒤 `x = 20;`을 실행하면 어떻게 될까?

변수 상자는 한 번에 하나의 값만 담을 수 있다. 
따라서 새로운 값 `20`이 들어오는 순간, 기존에 있던 값인 `10`은 더 이상 저장되어 있지 않다. 

**`=`의 계산 결과**

모든 수식은 계산한 후 결과가 있다. `=` 연산에서도 마찬가지다. 
`=` 연산의 계산 결과는 대입되는 값이다. 

```c
int x;
x = 10;      /* 변수 x에 값 10이 대입되고, 이 식의 계산 결과도 10이다. */
```

> [!TIP]
> **`=` 코드를 읽는 요령**
>
> 코드 `x = 10`을 "x는 10이다"라고 읽으면 수학과 헷갈린다.
> "x에 10을 대입한다" 또는 "x가 10이 된다"라고 동작 중심으로 읽는 습관을 들이는 것이 좋다.

### 5.5.2 `=`의 결합 방향 (*associativity*)

만약 `=` 연산자 두 개를 연달아 쓰면 어떻게 될까?

```c
int x, y;
x = y = 10;   /* y에 10을 대입하고, 그 값을 다시 x에도 대입한다. */
```

대입 연산자 `=`의 특징은 흐름이 오른쪽에서 왼쪽이라는 점이다 (*right associative*). 
`x = (y = 10)`과 같이 오른쪽에 있는 `=`이 먼저 실행되고, 그 다음에 왼쪽에 있는 `=`이 실행된다.

1. **`y = 10` 실행:** 먼저 `y` 상자에 `10`이 대입된다.
2. **결과 전달:** `y = 10`이라는 수식의 결과값인 `10`이 왼쪽으로 전달된다.
3. **`x = ...` 실행:** 전달받은 `10`이 `x` 상자에 대입된다.

결과적으로 `x`와 `y` 모두에 10이 저장되어 있게 된다.

### 5.5.3 `=`의 우선순위 (*precedence*)

`=`의 우선순위는 쉼표 `,`를 제외한 모든 연산자 중에서 가장 낮다. 
쉽게 말해, `+`같은 연산이 먼저 계산되고, 마지막에 `=`로 저장된다.

```c
int x;
x = 1 + 1;    /* x에 1 + 1의 계산 결과를 대입한다. */
```

여기서 `x = 1 + 1`은 다음과 같은 순서로 실행된다.

1. **더하기 (`+`):** `1 + 1`이 실행되어 결과값이 `2`가 된다.
2. **대입 (`=`):** 모든 계산이 끝나고 결과값 `2`를 `x`에 대입한다.

### 5.5.4 `x = x + 1`: 가장 중요한 패턴

변수의 이름과 같이 데이터가 저장된 상자를 가리키는 수식을 *lvalue*라고 부른다.
lvalue는 저장 가능한 대상을 의미하며, 값이 필요한 맥락에서는 저장된 값으로 평가된다. 

```c
int x = 1, y;    
y = x + 1;      /* 여기서 y는 값을 저장할 상자를 의미하고, x는 저장된 값을 의미한다.*/
```

만약 하나의 수식에서 값을 대입할 상자와 계산할 값이 저장된 상자를 같은 상자로 쓰면 어떻게 될까?

```c
int x = 1;
x = x + 1;      /* x + 1을 할 때 x의 값은 대입되기 전의 값이다. 수식이 실행된 후에 x에는 2가 저장된다. */
```

이 코드는 다음과 같은 순서로 실행된다.

1. **읽기 (rvalue):** 오른쪽의 x 상자에서 현재 값 1을 꺼낸다.

2. **계산:** 꺼낸 값에 1을 더해 2를 만든다.

3. **쓰기 (lvalue):** 결과값 2를 왼쪽의 x 상자에 덮어쓴다.

비슷한 패턴이 앞으로 숫자를 세거나, 합계를 구할 때 많이 사용될 것이다. 

> [!CAUTION]
> **위험! 한 번에 두탕 뛰지 마세요 (*undefined behavior*)**
>
> C 언어에서는 실행 순서가 정해져 있지 않은 상황에서 같은 변수를 두 번 수정하거나, 수정과 읽기를 함께 하면 안 된다.
> 만약 이를 어기면 그 결과는 표준에서 보장되지 않으며, 정의되지 않은 동작이 된다 (*undefined behavior*).
>
> ```c
> int x = 0, y = 0;
> y = x + (x = 1);    /* 위험! */
> ```
>
> 위 코드에서 `x`의 값을 읽을 때 `x = 1`을 해서 `1`을 저장한 후에 읽을지,
> 아니면 저장하기 전에 먼저 읽어서 `0`으로 읽을지는 표준에 정해져 있지 않다 (*unsequenced*).
> 
> **해결책:** 욕심부리지 말고 한 줄에 하나씩 명확하게 적자.
>
> ```c
> x = 1;       /* x를 먼저 확실히 1로 만든다. */
> y = x + x;   /* 그 다음 계산한다. 순서가 명확하다. */
> ```

> [!NOTE]
> ***sequenced after:* `x = x + 1`이 합법적인 이유**
>
> 대입 연산 `=`에서 값을 저장하는 부수 효과는 (*side effect*),
> 피연산자들의 값 계산이 끝난 이후에 발생한다 (*sequenced after*, C11 이후 용어). 
>
> `x = x + 1`에 이 규칙을 적용해보면,
> 
> 1. **값 계산:**
>    - 왼쪽 `x`가 가리키는 저장 위치를 결정한다.
>    - 오른쪽 `x + 1`의 값을 계산한다. 여기서 `x`이 값을 읽는다.
> 2. **부수 효과 :**
>    -  계산된 값을 `x`에 저장한다.
>
> `x`에 대한 읽기(1단계)와 쓰기(2단계)의 실행이 분리되어 있기 때문에, `x = x + 1`은 언제나 안전하다.

## 5.6 산술 연산자: 딱 5개만 알면 된다

C 언어에는 수많은 연산자가 있지만, 계산을 위해 당장 필요한 건 두 개의 값을 가지고 계산하는 산술 연산자 5개다.

| 연산자 | 뜻 | 설명 | 예시 (`a=10, b=3`) | 결과 |
| :---: | :---: | :--- | :--- | :---: |
| **`+`** | 더하기 | 값을 더한다. | `a + b` | `13` |
| **`-`** | 빼기 | 값을 뺀다. | `a - b` | `7` |
| **`*`** | 곱하기 | 값을 곱한다. (`x`가 아님에 주의) | `a * b` | `30` |
| **`/`** | **나누기 (몫)** | **몫만 구한다.** (소수점 버림) | `a / b` | **`3`** |
| **`%`** | **나머지** | 나눈 뒤 **나머지만 구한다.** | `a % b` | **`1`** |

더하기 `+`, 빼기 `-`, 곱하기 `*`는 수학에서와 의미가 같다. 
나누기 `/`와 나머지 `%` 연산은 수학에서와 의미가 다른 경우도 있으니 조금 더 자세히 알아본다. 

### 5.6.1 피연산자 (*operand*): 연산자의 의미를 정하다

연산자가 어떻게 계산을 수행할지와 결과값이 어떤 모양(타입)일지는 연산을 할 값들인 피연산자 (*operand*)의 타입이 결정한다.

가장 중요한 규칙은, `int`끼리 연산하면 결과도 `int` 타입이라는 것이다.

### 5.6.2 `int`의 나눗셈 `/`: 0을 향해 잘라내라

`int`끼리의 나눗셈 `/`은 소수점 아래를 저장할 공간이 없으므로, 소수 부분을 버린다.
이때 버리는 방향이 중요한데, C 언어는 무조건 0을 향해 절삭(*truncate toward zero*)한다.

- **양수:** `10 / 3` → `3.33...` → **`3`**
- **음수:** `-10 / 3` → `-3.33...` → **`-3`**

| 수식 | 실제 값 | C 언어 결과 (`int`) | 설명 |
| :---: | :---: | :---: | :--- |
| **`10 / 3`** | `3.33...` | **`3`** | 소수점 버림 |
| **`10 / -3`** | `-3.33...` | **`-3`** | 0 방향으로 절삭 |
| **`-10 / 3`** | `-3.33...` | **`-3`** | 0 방향으로 절삭 |
| **`-10 / -3`** | `3.33...` | **`3`** | 음수끼리 나누면 양수 |

> [!WARNING]
> **역사: C89와 C99의 차이**
> 
> 1999년 이전에 만들어진 C89 표준에서는 음수 나눗셈의 결과가 구현 정의였다.
> `-10 / 3`이 `-3`이 될 수도 있고, `-4`(내림)가 될 수도 있었다(컴파일러 마음).
> 하지만 C99 표준부터는 무조건 0 쪽으로 절삭(truncate toward zero) 하도록 통일되었다.

### 5.6.3 `int`의 나머지 `%`: 왼쪽의 부호를 따라간다

`%` 연산자는 나눗셈의 짝꿍이다. 그런데 음수가 섞이면 나머지의 부호가 헷갈린다.
규칙은 간단하다. 나머지의 부호는 나누어지는 수(왼쪽 피연산자)의 부호를 따라간다.

| 수식 | 몫 (`/`) | 나머지 (`%`) | 검산 (`몫 * 제수 + 나머지`) |
| :---: | :---: | :---: | :--- |
| `10 % 3` | `3` | **`1`** | $3 \times 3 + 1 = 10$ |
| `-10 % 3` | `-3` | **`-1`** | $(-3) \times 3 + (-1) = -10$ |
| `10 % -3` | `-3` | **`1`** | $(-3) \times (-3) + 1 = 10$ |
| `-10 % -3` | `3` | **`-1`** | $(3) \times (-3) + (-1) = -10$ |

> [!TIP]
> **검산 공식: 나눗셈의 항등식**
>
> C 언어의 나눗셈과 나머지 연산은 항상 다음 수학 공식을 만족해야 한다.
> $$a = (a / b) \times b + (a \% b)$$
> 몫이 0 쪽으로 절삭되므로(`-3.33` -> `-3`), 나머지는 자연스럽게 왼쪽 수(`a`)의 부호를 따라가게 된다.

> [!WARNING]
> **실수에는 `%` 금지!**
>
> `%` 연산자는 오직 정수끼리만 쓸 수 있다.
> `3.14 % 2.0` 처럼 실수에 사용하면 컴파일 에러가 발생한다.

> [!WARNING]
> **역사: C89와 C99의 차이**
> 
> 1999년 이전에 만들어진 C89 표준에서도 나눗셈의 항등식은 항상 성립했다.
> 다만, 음수 나눗셈과 마찬가지로 음수 나머지의 결과도 구현 정의였다.
> 
> `-10 % 3`이 `-1`이 될 수도 있고, `2`가 될 수도 있었다(컴파일러 마음).
> 하지만 C99 표준부터는 왼쪽 피연산자의 부호를 따르도록 통일되었다.

### 5.6.4 산술 연산의 우선 순위: 곱셈 관련이 덧셈 관련보다 높다

수학 시간에도 덧셈보다 곱셈을 먼저 계산하라고 배웠다. C 언어의 계산 순서도 똑같다. 

곱셈과 관련된 `*`, `/`, `%` 연산자가 덧셈과 관련된 `+`, `-` 연산자보다 우선 순위가 높다.

```c
int x = 2 + 3 * 4;
/* 1. 곱셈(3 * 4)를 먼저 해서 12가 됨
   2. 덧셈(2 + 12)를 해서 14가 저장됨 */
```

`*`, `/`, `%` 연산자 끼리는 우선순위가 똑같다. `+`, `-` 연산자도 우선순위가 같다. 

> [!TIP]
> **괄호 `()`: 연산 순서를 바꾸는 방법**
>
> 수학에서와 마찬가지로 덧셈을 곱셈보다 먼저 해야될 때는 괄호 `()`를 치면 된다.
>
> ```c
> int y = (2 + 3) * 4;
> /* 1. 괄호 안(2 + 3)을 먼저 해서 5가 됨
>    2. 곱셈(5 * 4)를 해서 20이 저장됨 */
> ```

### 5.6.5 산술 연산의 결합 방향: 왼쪽에서 오른쪽으로

만약 우선순위가 같은 연산자가 겹치면 어떻게 될까?

```c
int result = 10 / 2 * 5;
```

곱하기(`*`)와 나누기(`/`)는 우선 순위가 같다. 

그럴 때는 우리가 글을 읽는 순서대로 왼쪽부터 차례대로 계산한다. 

1. **왼쪽:** `10 / 2`가 계산되어 `5`가 나온다.
2. **오른쪽:** `5 * 5`가 계산되어 `25`가 나온다.

(만약 오른쪽의 곱하기를 먼저 했다면 `10 / 10`이 계산되어 완전히 다른 답이 나왔을 것이다.)

### 5.6.6 단항 연산자 (*unary operator*): `+`, `-`

지금까지 본 더하기(`+`), 빼기(`-`)는 양옆에 숫자가 2개 필요한 이항 연산자(*binary operator*)였다.
하지만 `+`와 `-` 기호는 숫자 하나에만 붙어서 작동하기도 하는데, 이를 단항 연산자(*unary operator*)라고 부른다.

- **이항(binary):** `10 - 3` (숫자 2개 필요, "빼기")
- **단항(unary):** `-3` (숫자 1개 필요, "부호 바꾸기")

| 기호 | 이름 | 역할 | 예시 (`a=10`) | 결과 |
| :---: | :---: | :--- | :--- | :---: |
| **`-`** | **부호 연산자 (음수)** | 부호를 뒤집는다. (양수와 음수 바꾸기) | `-a` | `-10` |
| **`+`** | **부호 연산자 (양수)** | 아무 일도 안 한다. (강조용) | `+a` | `10` |

**단항 마이너스 `-`: 부호 뒤집기**

단항 연산자 `-`는 수학의 마이너스 부호와 똑같다. 양수를 음수로, 음수를 양수로 바꾼다.

```c
int x = 10;
int y = -x;   /* y는 -10이 된다 */
int z = -y;   /* z는 10이 된다 (-(-10) = 10) */
```

**단항 플러스 `+`: 아무것도 안 함**

`+3`은 그냥 `3`과 같다. 단항 `+`는 값을 바꾸지 않는다.
그런데 왜 있을까? 단순히 리터럴을 쓸 때 "이 수는 양수다!"라고 강조하거나, 단항 마이너스 연산자 `-`와의 대칭을 맞추기 위해 존재한다. 실제 코드에서는 거의 쓰이지 않는다.

**결합 방향: 오른쪽에서 왼쪽으로**

단항 연산자는 `+x`, `-x`처럼 피연산자의 왼쪽에 붙어 있다. 따라서 단항 연산자가 여러 개 겹쳐 있으면 피연산자와 가장 가까운 오른쪽 연산자부터 왼쪽으로 처리한다. `-+x`는 `-(+x)`로 묶인다.

```c
int x = - -10;
```

1. **오른쪽 `-`:** `-10`을 처리해서 음수로 만든다.
2. **왼쪽 `-`:** 그 결과값(`-10`)의 부호를 다시 뒤집어 `10`으로 만든다. 

> [!WARNING]
> **컴파일러의 욕심: `++`과 `--`**
>
> 부호를 두번 바꾸고 싶어서 `- -a`를 쓸 때, 띄어쓰기를 하지 않고 `--a`라고 쓰면 어떻게 될까?
>
> C 언어 컴파일러에는 가능한 긴 연산자를 먼저 만든다는 탐욕적인 규칙 (maximal munch)가 있다.
> 그래서 `-`가 두 개 붙어 있으면 빼기 두번이 아니라, 나중에 배울 감소 연산자 `--` 하나로 인식해버린다.
>
> `+`와 `-` 단항 연산자를 중첩해서 쓸 때는 공백(`- -a`)이나 괄호(`-(-a)`)로 구분해주자.

**우선순위: 이항 연산자보다 힘이 세다**

단항 연산자는 사칙연산(이항 연산자 `*`, `/`, `%`, `+`, `-`)보다 우선순위가 높다.
숫자에 달라붙어 있기 때문에 가장 먼저 처리된다.

```c
int x = -1 + 2;
```
위 코드는 어떻게 계산될까?

1. **단항 `-` (1등):** `1`에 붙어서 `-1`을 만든다.
2. **이항 `+` (2등):** `-1`과 `2`를 더한다.
3. **결과:** `1`이 저장된다.

만약 더하기가 먼저였다면 `-(1 + 2)`가 되어 `-3`이라는 결과를 얻었을 것이다.

> [!TIP]
> **부호 연산자와 뺄셈의 구별**
>
> 컴퓨터는 문맥을 보고 이 기호가 빼기인지 부호인지 기가 막히게 알아낸다.
>
> 		int x = 10 - -5;
>
> - **첫 번째 `-`:** 양옆에 숫자가 있으므로 빼기(이항)
> - **두 번째 `-`:** 뒤에만 숫자가 있으므로 부호(단항)
> - **해석:** `10 - (-5)` → `10 + 5` → `15`

### 5.6.7 우선 순위 총정리

지금까지 배운 연산자들의 우선순위를 정리해보자. 

1. **괄호:** `( )` (계산 순서 지정)
2. **단항 연산자:** `+`, `-`
3. **곱셈 관련 연산자:** `*`, `/`, `%`
4. **덧셈 관련 연산자:** `+`, `-`
5. **대입 연산자:** `=`

괄호 `()`가 우선 순위가 가장 높고, 대입 연산자 `=`가 우선 순위가 가장 낮다. 

그 사이에 단항 연산자, 곱셈 연산자, 덧셈 연산자가 우선 순위를 가지고 있다. 

## 5.7 아주 중요한 금지 사항 2개
정수 계산을 할 때, 문법적으로는 틀리지 않았지만 실행하는 순간 프로그램을 망가뜨리는 두 가지 치명적인 함정이 있다.

### 5.7.1 0으로 나누기 (*division by zero*)
수학에서 0으로 나누는 것이 정의되지 않듯이, 컴퓨터에서도 0으로 나누기는 금기다.

```c
int zero = 0;
/* int x = 10 / zero;    으악! 프로그램이 즉시 강제 종료됩니다. */
/* int y = 10 % 0;       나머지 연산도 똑같이 금지입니다. */
```

실수로라도 나누는 수(분모)가 0이 되면, 프로그램은 그 즉시 비정상 종료(*crash*) 되거나 예측할 수 없는 상태에 빠진다. 컴파일러가 미리 경고해 줄 때도 있지만, 변수에 0이 들어있는지 컴파일러가 모를 때가 더 많으므로 프로그래머가 항상 주의해야 한다.

### 5.7.2 `int` 범위를 넘는 계산 (*overflow*)
`int`라는 상자는 크기가 무한하지 않다. 컴퓨터 메모리의 한계 때문에 담을 수 있는 숫자의 최대치와 최소치가 정해져 있다.

```c
/* int가 담을 수 있는 범위를 넘어선다면? */
int huge = 2000000000 + 2000000000; 
/* 40억이 되어야 하지만, 결과는 엉뚱한 음수가 나오거나 잘려나간다. */
```

이것을 오버플로우(*overflow*)라고 부른다. 컵에 물을 계속 부으면 넘쳐흐르듯이, 변수가 감당할 수 있는 범위를 넘어서면 값이 깨져버린다.
