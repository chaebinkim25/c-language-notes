# 6. 조건에 따라 실행 흐름 바꾸기

**지금까지의 프로그램은 ‘폭포수’였다**.

5장까지 우리가 작성한 코드는 항상 위에서 아래로, 단 한 줄도 빠짐없이 차례대로 실행되었다. 
변수를 만들고(`int x`), 값을 넣고(`x = 10`), 계산하는(`x + 1`) 과정은 정해진 궤도를 달리는 기차처럼 일직선이었다.

하지만 현실의 문제는 그리 단순하지 않다. 
"점수가 60점 이상이면 합격, 아니면 불합격" 
"배터리가 10% 미만이면 절전 모드 실행"

상황에 따라 **실행할 코드를 선택**하거나, **건너뛰어야** 하는 순간이 반드시 옵니다. 
우리 프로그램에 **판단력**을 부여할 시간이 되었다.

6장에서는 프로그램의 실행 흐름을 바꾸는 가장 기초적이고 강력한 도구인 `if` 문을 배운다. 

> 목표: 7장에서 반복문을 배우기 전에,
> **비교(판단)** + **분기(if/else)**로 실행 흐름을 바꾸는 최소 기술을 확보한다.
> 그래서 6장에서는 `switch`, `&&`, `||`, `!`, `?:` 같은 것들은 일부러 미룬다.

## 6.1 계산만 하는 프로그램은 왜 부족한가?
지금까지 우리가 만든 프로그램은 마치 **브레이크가 없는 기차**와 같았다. 
출발(`main` 함수 시작)하면 종착역(`return 0;`)까지 멈추지도, 방향을 틀지도 못하고 무조건 직진만 했다.

계산만 할 줄 아는 프로그램은 그저 성능 좋은 '**계산기**'일 뿐이다. 
하지만 프로그램이 현실 세계에서 유용하게 쓰이려면, 상황에 맞춰 "**유연하게 대처하는 능력**"이 필요하다.

- 위험 방지: 입력받은 값이 0이라면, 나눗셈을 수행하지 않고 경고 메시지를 띄워야 한다.
- 기준 판단: 점수가 60점 이상이면 '합격', 아니면 '불합격'이라고 다르게 말해줘야 한다.
- 범위 보정: 게임 캐릭터의 체력이 100을 넘어가면 100으로 고정하고, 0보다 작아지면 0으로 잘라야 한다.
- 패턴 처리: 입력된 수가 홀수인지 짝수인지에 따라 다른 계산 공식을 적용해야 한다.

이 모든 상황의 공통점이 바로 "**판단(Decision)**"이다.

이전까지의 코드가 일직선(Linear)이었다면, 이제는 길이 나뉘는 갈림길(Branch)을 만들어야 한다.
컴퓨터에게 "**이 조건이 맞으면 저쪽 길로 가고, 아니면 이쪽 길로 가라**"고 명령해야 하는 것이다.

C 언어에서 이런 갈림길을 만드는 첫 번째 도구가 `if` 문이다. 
우리는 CPU에게 무조건적인 계산이 아니라, "**조건을 보고 행동을 결정하는 법**"을 가르치게 됩니다.

## 6.2 C에서 참/거짓은 어떻게 표현될까?
우리는 일상에서 "그건 참(True)이다", "그건 거짓(False)이다"라고 명확하게 말한다. 
하지만 초기 C 언어(C89)에는 `true`나 `false`라는 단어(키워드)가 아예 없었다.

대신 C는 아주 단순하고 기계적인 규칙 하나로 모든 상황을 판단한다. 

### ✅ C 언어의 판단 규칙
- 0 (Zero): 거짓 (False)
- 0이 아닌 모든 값 (Non-Zero): 참 (True)

즉, C 언어에서 "판단"이란 **어떤 정수 값이 0인지 아닌지를 검사하는 것**과 완전히 같다. 
100도 참이고, -5도 참이다.
오직 `0`만이 거짓이다.

예를 들어, 다음 코드에서처럼 어떤 값을 "조건용 값"이라고 생각해보면,

```c
int cond;

cond = 0;    /* 거짓 */
cond = 1;    /* 참 */
cond = -3;   /* 참 (0이 아니므로) */
```
가 된다. 

판단 규칙이 실제로 쓰이는 문법이 조건에 따라 다른 코드를 실행하는 `if` 문장이다. 

## 6.3 `if`의 기본 모양: "참이면 실행, 거짓이면 건너뜀"
이제 문법을 보자. C 언어에서 `if`문은 다음과 같이 구성된다.
```c
if (조건) {
    /* 조건이 참일 때만 실행되는 문장들 */
}
```

`if`문 구조는 크게 세 부분으로 나뉜다. 

1. `if`: "만약 ...면" 이라고 컴퓨터에게 신호를 주는 키워드다.
2. `(조건)`: 괄호 안에는 검사할 내용이 들어간다. 6.2에서 본 것처럼 조건이 **0이면 거짓, 0이 아니면 참**으로 해석된다.
3. `{ ... }`: **블록(Block)** 이라고 부른다. 조건이 참일 때 실행할 문장들을 묶어둔 것이다.

다음은 변수 `x`의 값이 양수일 때만 1을 더해주는 코드다. 
```c
int main()
{
    int x;

    x = 10;    // 변수 x에 10을 대입

    /* x > 0은 참(True)이므로 중괄호 안으로 들어간다 */
    if (x > 0) {
        x = x + 1;    /* 조건이 참이므로, 실행된다 */
    }

    return 0;   // 최종적으로 x는 11이 된다.
}
```
만약 `x`가 -5였으면 어떘을까?

1. 조건 검사: `-5 > 0`은 **거짓(False)** 이다. 
2. 건너뜀(Skip): 컴퓨터는 `{ }` 블록 안의 코드를 거들떠보지도 않고, 블록이 끝난 바로 다음 줄 `return 0;`으로 점프해버린다. `x`는 여전히 -5로 남는다.
   
#### 핵심 정리
여기서 가장 중요한 핵심은, **`if`문이 코드의 특정 부분을 "실행할지 말지" 결정**하는 단추라는 것이다. 

조건이 거짓이라면 마치 그 코드가 존재하지 않는 것처럼 **건너뛴다(Skip)**. 일직선으로 흐르던 실행 흐름이 조건에 따라 굽이치거나 점프하게 된다. 


## 6.4 비교 기호 6개: "조건"을 만드는 기본 재료

판단을 내리려면 기준이 있어야 하고, 그 기준을 확인하려면 **비교**를 해야 한다. 
C 언어에서는 다음 6가지 기호(관계 연산자)를 사용해 두 값을 비교한다.

|기호|뜻|예시|참이 되는 경우|
|`==`|같다|`a == b`|a와 b가 같을 때|
|`!=`|다르다|`a != b`|a와 b가 다를 때|
|`<`|작다 (미만)|`a < b`|a가 b보다 작을 때|
|`>`|크다 (초과)|`a > b`|a가 b보다 클 때|
|`<=`|작거나 같다|`a <= b`|a가 b보다 작거나 같을 때|
|`>=`|크거나 같다|`a >= b`|a가 b보다 크거나 같을 때|

#### ⚠️ 주의: 수학과 다르다!
- 수학에서는 '같다'를 `=`으로 쓰지만, C 언어에서는 `=`을 쓴다.
- C 언어세서 `=`은 값을 저장하는 대입(Assignment) 기호다. 
- `if (a = b)`라고 쓰면 비교가 아니라 대입을 해버리는 대참사가 일어난다. 

#### 비교 결과도 "값이다
많은 입문자가 "비교"를 추상적인 동작이라고 생각한다. 
하지만 C 언어 입장에서 비교식은 덧셈(`+`)이나 뺄셈(`-`)과 똑같은 **계산식**일 뿐이다.
덧셈의 결과가 정수이듯, 비교의 결과도 **정수**다.

- 조건이 **참(True)** 이면: 결과 값은 **1**이 된다.
- 조건이 **거짓(False)** 이면: 결과 값은 **0**이 된다.

즉, `if (a > b)`라는 코드를 볼 때 컴퓨터는 `a > b`부분을 먼저 계산해서 `0`이나 `1`로 바꿔치기한 뒤에 `if`문을 실행한다.

### 코드로 확인하기
비교 연산의 결과가 정말 0과 1로 나오는지 확인해보자. 

```c
int main()
{
    int a = 10;
    int b = 3;
    
    int t1, t2;

    /* 괄호 ( )는 보기에 좋으라고 쓴 것이다. 없어도 된다. */
    
    t1 = (a > b);   
    /* 1. (10 > 3)을 비교한다 -> 참이다. 
       2. 참이므로 결과는 1이 된다. 
       3. 변수 t1에 1이 저장된다. */

    t2 = (a < b);   
    /* 1. (10 < 3)을 비교한다 -> 거짓이다.
       2. 거짓이므로 결과는 0이 된다.
       3. 변수 t2에 0이 저장된다. */

    return 0;
}
```

나중에 배울 반복문에서도 비슷하게 비교 결과가 쓰인다. 

## 6.5 if - else: 둘 중 하나만 실행하기 (양자택일)
앞서 배운 if 문은 조건이 맞으면 실행하고, 아니면 무시하는 **옵션**과 같았다. 
하지만 현실에서는 "이거 아니면 저거" 중에 하나를 반드시 선택해야 하는 경우가 더 많습니다.

동전이 앞면이면 짜장면, 뒷면이면 짬뽕

점수가 60점 이상이면 합격, 미만이면 불합격

그럴 때 쓰는 것이 `else`("그렇지 않으면")다.

```c
if (조건) {
    /* 조건이 참(True)일 때 실행되는 길 */
} else {
    /* 조건이 거짓(False)일 때 실행되는 길 */
}
```

`if-else`는 완벽한 **두 갈래 길**이다. 조건에 따라 반드시 둘 중 하나의 길로만 가야 하며, **두 길을 동시에 가거나 둘 다 안 가는 경우는 없다**.

#### 예제: 홀수인가 짝수인가?
가장 대표적인 예제로 홀수/짝수 판별 코드가 있다. 숫자는 홀수 아니면 짝수, 둘 중 하나이며 중간은 없습니다.

```c
int main()
{
    int n;
    int is_even; // 짝수면 1, 홀수면 0을 저장할 변수

    n = 17;

    /* %는 나머지 연산자. 2로 나눈 나머지가 0이면 짝수다. */
    if (n % 2 == 0) {
        /* 참인 경우: 이 블록이 실행된다. */
        is_even = 1;    
    } else {
        /* 거짓인 경우: n은 17이므로 나머지가 1이어서 여기로 온다. */
        is_even = 0;    
    }

    return 0;
}
```

#### 코드 흐름 따라가기 (Trace)
1. `n`은 17이다.
2. `n % 2`를 계산하면 나머지는 1이다.
3. `1 == 0`을 비교한다. 결과는 **거짓(False)** 이다.
4. `if` 블록을 건너뛰고, 바로 `else` 블록으로 진입한다.
5. `is_even`에 0을 저장하고, `else` 블록을 빠져나간다.


## 6.6 `else if`: 갈림길을 여러 개로 늘리기
세상 일은 "모 아니면 도"처럼 두 가지로만 나뉘지 않는다. 
가위바위보(3가지), 신호등(빨강, 노랑, 초록)처럼 세 개 이상의 선택지가 필요할 때가 훨씬 많다.

그럴 때는 `if`와 `else` 사이에 `else if`를 끼워 넣어 갈림길을 계속 늘릴 수 있다. 

```c
if (조건1) {
  /* 조건1이 참일 때 실행 */
} else if (조건2) {
  /* 조건1은 거짓이고(중요!), 조건2가 참일 때 실행 */
} else {
  /* 위의 모든 조건이 거짓일 때 실행 (나머지 처리) */
}
```
마치 **여러 층으로 된 필터**와 같다. 위에서부터 차례대로 조건을 검사하다가, 
하나라도 걸리면(참이면) 그 블록을 실행하고, **전체 `if`문**을 빠져나간다.

#### 예제: 숫자의 부호 판별 (양수, 음수, 0)
숫자는 양수, 음수, 그리고 0이라는 세 가지 상태 중 하나를 가진다. 코드에서 이를 표현할 수 있다.

```c
int main()
{
    int x;
    int sign;  // 1: 양수, -1: 음수, 0: 영

    x = 0;

    /* 첫 번째 관문 */
    if (x > 0) {
        sign = 1;
    }
    /* 두 번째 관문: 위가 거짓일 때만 여기를 검사한다 */
    else if (x < 0) {
        sign = -1;
    }
    /* 마지막 관문: 위 조건들이 모두 거짓이면 여기로 온다 */
    else {
        sign = 0;
    }

    return 0;
}
```


#### 코드 흐름 따라가기 (Trace)
`x`가 0일 때의 흐름을 하드웨어처럼 따라가 봅시다.

1. **첫 번째 검사 (`if (x > 0)`)**: 0 > 0은 거짓(False)이다. 첫 번째 블록은 건너뛴다.

2. **두 번째 검사 (`else if (x < 0)`)**: 0 < 0도 거짓(False)이다. 두 번째 블록도 건너뛴다.

3. **마지막 (`else`)**: 위의 모든 시도가 실패했다. 갈 곳은 `else` 뿐이다. `sign = 0`을 실행하고 종료한다.

#### 핵심 규칙: "선착순 1명"
`else if`를 쓸 때 가장 중요한 규칙은 **위에서부터 검사해서 처음 참이 되는 블록 하나만 실행한다**는 점이다.

만약 조건 1도 참이고 조건 2도 참이라면 어떻게 될까? 조건 1만 실행되고 조건 2는 무시된다. 
조건1에서 먼저 "선택"받았기 때문에, 컴퓨터는 뒤에 있는 조건들을 쳐다보지도 않고 `if` 문 전체를 탈출해 버린다.



## 6.7 자주 쓰는 조건 패턴 4가지
조건문 문법 공부는 끝났다. 여기부터는 **실전**이다. 
프로그래머들이 밥 먹듯이 사용하는 4가지 **조건문 패턴**을 익혀본다. 
나중에 수만 줄짜리 코드를 짜게 되어도 계속해서 등장하는 기본기 중의 기본기다.

### 6.7.1 0인지 검사하기: 금지된 상황 막기 (방어적 프로그래밍)
5장에서 우리는 "0으로 나누는 것은 수학적으로 불가능하며, 컴퓨터에서도 금지된다"고 배웠다. 
사용자가 실수로 입력했든, 계산 결과가 우연히 0이 되었든, 프로그램은 **위험한 상황을 스스로 막아야 한다**.

```c
int main()
{
    int a = 10;
    int b = 0;
    int q;

    /* 안전장치: 나누는 수(b)가 0이 아닐 때만 계산한다 */
    if (b != 0) {
        q = a / b;      
    } else {
        /* 0이라면 계산하지 않고 0으로 처리하거나, 에러 메시지를 띄운다 */
        q = 0;          
    }

    return 0;
}
```
`if` 문은 단순히 분기하는 것을 넘어, **프로그램이 뻗지 않도록(Crash) 막아주는 '에어백' 역할**도 할 수 있다. 
현장에서는 **방어적 프로그래밍(Defensive Programming)** 이라고 부른다.

> [Hardware Note]
>
> 0으로 나누면 CPU가 화를 낸다.
> CPU에게 DIV 명령을 내렸는데 나누는 수가 0이면,
> CPU는 즉시 하던 일을 멈추고 예외(Exception)라는 비상 신호를 발생시킨다.
> 운영체제는 이 신호를 받으면 해당 프로그램을 즉시 강제 종료시킨다.
> if (b != 0) 한 줄은 이런 대형 사고를 막는 가장 저렴하고 확실한 보험이다.

### 6.7.2 짝수/홀수 판별하기: `%` 연산자의 재발견
`%` (나머지 연산)는 단순히 나머지를 구하는 계산기가 아니다. 
프로그래밍에서 `%`는 패턴을 분류하는 강력한 도구다.

```c
if (n % 2 == 0) {
    /* 나머지가 0 -> 짝수 */
} else {
    /* 나머지가 1 -> 홀수 */
}
```
"두 개씩 짝지었을 때 남는 게 있느냐?"를 묻는 것과 같다. 
나중에 배우게 될 배열이나 반복문에서 "2번째마다 색깔 바꾸기", "3번째 줄마다 줄바꿈 하기" 등 규칙적인 패턴을 만들 때 아주 자주 쓰인다.

### 6.7.3 범위 검사하기: 겹겹이 쌓인 관문
어떤 값이 0에서 9 사이인지 확인하려면 어떻게 해야 할까? 
아직 우리는 조건을 묶어주는 연산자(&&)를 배우지 않았다. 
하지만 중첩 if를 사용하면 논리를 훨씬 더 명확하게 들여다볼 수 있다.

```c
int main()
{
    int x = 7;
    int in_range = 0; // 0: 범위 밖, 1: 범위 안

    /* 1차 관문: 0보다 크거나 같은가? */
    if (x >= 0) {
        /* 2차 관문: (1차를 통과한 녀석들 중) 9보다 작거나 같은가? */
        if (x <= 9) {
            /* 두 관문을 모두 통과해야만 이곳에 도달합니다 */
            in_range = 1;
        }
    }

    return 0;
}
```
코드가 조금 길어 보이지만, **조건을 하나씩 단계별로 통과한다**는 논리의 흐름이 눈에 훤히 보인다는 큰 장점이 있다. 
까다로운 조건을 검사할 때 실수를 줄여주는 좋은 습관입니다.

### 6.7.4 값 “잘라내기”: 범위를 벗어나면 강제로 고정하기 (Clamping)
값이 너무 작거나 너무 클 때, 범위를 벗어났다고 에러를 내는 대신 **강제로 범위 안으로 끌고 들어오는 방법**도 있다. 
전문 용어로 **클램핑(Clamping)** 이라고 한다.

```c
int main()
{
    int x = 12; // 범위(0~9)를 벗어난 값

    if (x < 0) {
        x = 0;      /* 너무 작으면 0으로 고정 */
    } else if (x > 9) {
        x = 9;      /* 너무 크면 9로 고정 */
    }
    
    /* 결과: x는 이제 안전하게 9가 된다 */

    return 0;
}
```
클램핑이 어디에 쓰일까?

- 볼륨 조절: 볼륨을 계속 높여도 100을 넘어가면 안된다. (100으로 고정)

- 게임 체력: 체력이 0보다 떨어지면 마이너스가 아니라 0이 되어야 한다.

- 배열 접근: 나중에 배울 '배열'에서 정해진 칸을 벗어나지 않게 할 때 필수적이다.


## 6.8 초보자가 가장 많이 하는 실수 3가지
C 언어를 처음 배울 때, 코드가 빨간 줄(에러) 없이 컴파일은 되는데 프로그램이 이상하게 동작하는 경험을 하게 된다. 
문법을 몰라서가 아니라, C 언어의 유연함이 독이 되는 순간이다.

가장 치명적인 3가지 함정을 미리 파악하고 피하는 법을 배워봅시다.

### 6.8.1 = 와 ==를 헷갈리기 (가장 중요)
= (대입 연산자): 오른쪽 값을 왼쪽에 넣는다. (Action)

== (비교 연산자): 양쪽이 같은지 본다. (Question)

초보자가 가장 많이 하는 실수는 비교해야 할 자리에 대입을 하는 것이다.

```c
int x = 10;

/* 의도: x가 0과 같다면... (비교) */
/* 실제: x에 0을 대입하고, 그 결과인 0을 검사 */
if (x = 0) {
    /* 절대 실행되지 않음 */
}

/* 더 무서운 경우 */
if (x = 5) {
    /* x에 5가 들어가고, 5는 '참'이므로 무조건 실행됨! */
}
```

도대체 왜 컴파일러는 이걸 허용할까? 이를 이해하려면 **식(Expression)** 이라는 용어를 딱 한 번만 짚고 넘어가야 한다.

✅ 식(Expression)이란? C 언어에서 "계산이 끝나면 값 하나가 툭 떨어지는 코드 조각"을 말한다.

1 + 2 → 계산하면 3이 남는다. (식 O)

x > 0 → 비교하면 1 또는 0이 남는다. (식 O)

x = 0 → (중요) x에 0을 넣는 동작을 하고, 그 결과 값인 0이 남는다. (식 O)

if ( ... )의 괄호 안은 바로 이 **'식'**이 들어가는 자리다. 
컴퓨터 입장에서 x = 0은 문법적으로 완벽한 '식'이다. 
결과 값 0이 나오니 if (0)이 되어 '거짓'으로 처리될 뿐이다. 
이 논리적 허점을 피하려면 의식적으로 ==를 써야 한다.

### 6.8.2 if (조건); 처럼 세미콜론 붙이기
코드를 짜다 보면 습관적으로 문장 끝에 세미콜론(;)을 붙이게 된다. 
하지만 if 뒤에 붙으면 재앙이 된다.

```c
if (x > 0);  /* ← 여기가 문제! (빈 문장 실행) */
{
    x = x + 1; /* if와 상관없이 무조건 실행됨 */
}
```
이유는 단순하다.

C 언어에서 ; 하나도 "아무것도 하지 마라"는 뜻을 가진 온전한 문장(Null Statement)이다.

if의 정식 문법은, 
```
if (식) 문장 else 문장
```
이다. 우리가 쓰던 블락 `{ }`도 하나의 문장에 속한다.

결국 `if (식) ; { x = x + 1; }` 에서 `if`는 ;(아무것도 안 함)을 실행하고 끝나버린다.

그 뒤의 { ... } 블록은 if와 연결이 끊긴 채, 그냥 홀로 존재하는 코드가 되어 무조건 실행된다.

**규칙:** if (...) 뒤에는 절대로 ;를 붙이지 않는다.

### 6.8.3 중괄호 { }를 생략하기
C 언어는 `if` 뒤에 실행할 문장이 딱 한 줄이면 중괄호를 생략해도 된다는 규칙이 있다. 하지만 우리는 **이 규칙을 잊어버리는 게 좋다**.

```c
if (x > 0)
    x = x + 1;     /* if에 걸림 */
    x = x + 10;    /* 들여쓰기를 했지만, if와 관계 없음 (항상 실행) */
```
사람 눈에는 들여쓰기 때문에 두 줄 모두 if에 묶인 것처럼 보인다. 
하지만 C 컴파일러(그리고 CPU)는 들여쓰기를 전혀 신경 쓰지 않는다. 
오직 문법만 봅니다. 이로 인해 심각한 버그가 발생합니다.

✅ 우리만의 약속: 무조건 묶는다. 실행할 코드가 단 한 줄이라도, 심지어 비어 있더라도 if와 else 뒤에는 반드시 중괄호 { }를 쓴다. 현업 프로그래머들의 안전 수칙이기도 하다.

## [Tip] 요다 표기법 (Yoda Notation)
스타워즈의 요다처럼 어순을 바꿔쓰는 방식이다.
- `if (x == 5)` 대신 `if (5 == x)`라고 쓴다.
만약 실수로 `if (5 = x)`라고 쓰면? 상수에 값을 대입할 수는 없으므로 컴파일러가 즉시 **에러**를 뱉어낸다. 실수를 원천 봉쇄하는 아주 똑똑한 (하지만 조금 이상해 보이는) 습관이다.

