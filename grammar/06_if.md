# 6. `if`: 조건에 따라 실행 흐름 바꾸기

지금까지의 프로그램은 아직 상황을 감지하지 못하는 자율주행차와 같았다.  
5장까지의 코드는 순서대로, 단 한줄의 의심도 없이 무조건 실행되었다. 
우리는 변수를 만들고(`int x`), 값을 넣고(`x = 10`), 계산하는(`x + 1`) 작업을 해왔다.

하지만 보안의 세계에서 무조건적인 신뢰는 가장 큰 취약점이다. 
외부에서 들어오는 데이터, 사용자의 입력, 시스템의 상태는 언제나 예상 범위를 벗어날 수 있다. 

- **기밀성 유지 (*confidentiality*):** 사용자의 비밀번호가 일치하지 않는다면, 데이터를 보여주지 않는다.
- **무결성 검증 (*integrity*):** 네트워크로 전송받은 파일이 원본과 다르다면 처리를 중단한다.
- **가용성 보장 (*availability*):** 나누는 값이 0이라면, 나눗셈을 수행하지 않는다.
- **경계 검사 (*boundary check*):** 준비된 메모리 공간보다 더 긴 입력은 거부한다.

프로그램에 판단력을 부여할 시간이 되었다. 무조건 직진만 하던 코드에 만약에 (`if`)라는 질문을 던져보자.

> [!NOTE]
> **보안 관점: 해커의 목표**
>
> 해커는 입력 검증이 빠진 코드 경로를 노린다.
> 길이 검사를 하지 않았거나, 음수 입력을 막지 않은 부분을 찾아 공격한다.
> 꼼꼼하게 작성된 if는 보안 코딩의 가장 기본적인 방어막이다.

## 6.0 이 장의 목표: 선택의 기술

이 장에서는 가장 기본적인 판단 기술에 집중한다.

- **참과 거짓 이해하기 (*boolean*):** C 언어는 `0`을 거짓 (*false*)으로, 그 외 모든 값을 참 (*true*)으로 본다.
- **흐름 제어하기 (*branching*):** 위협을 감지했다면 차단하고, 안전하다면 허용하라. (`if`, `else`)
- **관계 파악하기 (*relational*):** 데이터의 경계를 확인하고 검증한다. (`>`, `<`, `==`)

이 세 가지만 확실히 익혀도, 프로그램은 조건에 따라 서로 다른 실행 경로를 선택할 수 있게 된다.

## 6.1 C에서 참/거짓은 어떻게 표현될까?

우리는 일상에서 "그건 참(*true*)이다", "그건 거짓(*false*)이다"라고 명확하게 말한다. 
C89 표준에는 `true`나 `false`라는 키워드가 아예 없었다.

대신 C 언어는 숫자로 모든 것을 판단한다. 
마치 전구에서 전기가 흐르면 불이 들어오고, 전기가 흐르지 않으면 불이 들어오지 않는 것과 같다.

**C 언어의 판단 규칙: 전구 이론**

- **0 (*zero*):** 거짓 (*false*). 전기가 흐르지 않아서 불이 들어오지 않는다.
- **0이 아닌 모든 값 (*non-zero*):** 참 (*true*). 전기가 흘러서 불이 들어온다. 

C 언어에서 판단이란 값이 0인지 아닌지로 평가하는 것이다.

```c
int is_valid;        /* 유효한 상태인지를 저장하는 변수 */

is_valid = 0;        /* 거짓 (false) */
is_valid = 1;        /* 참 (true) */
is_valid = -3;       /* 참 (true) - 0이 아니면 무조건 참이다. */
```

컴퓨터 과학에서는 이렇게 참과 거짓을 나타내는 값을 보통 불리언(*boolean*) 값이라고 부른다.

> [!NOTE]
> **C 언어 역사: 불리언(*boolean*)의 진화**
>
> - **C89:** 불리언 타입이 없었다. 정수 0과 1을 직접 사용했다.
> - **C99:** 0 또는 1로 저장되는 `_Bool` 타입이 도입되었고, `<stdbool.h>`를 포함하면 `bool`, `true`, `false`를 사용할 수 있게 되었다.
> - **C23:** `bool`, `true`, `false`가 정식 키워드로 승격되었다. 헤더 파일 없이도 바로 사용할 수 있다.

> [!CAUTION]
> **보안 관점: 0의 두 얼굴**
>
> 앞으로 리눅스 시스템 프로그래밍을 배우게 되면 `0`의 의미가 문맥에 따라 달라지는 상황을 마주하게 된다.
>
> - **논리 판단 (`if`):** `0`은 거짓 (*false*)이다.
> - **시스템 상태 (`exit` 코드):** `0`은 성공 (*success*)을 의미한다. (에러가 0개라는 뜻이다.)
>
> 만약 개발자가 프로그램 종료 코드를 착각한다면,
> 정상 종료를 오류로 처리하거나,
> 오류 상태를 정상으로 처리하는 문제가 발생할 수 있다.
>
> 보안 프로그래밍에서는 숫자의 의미를 항상 문맥 속에서 해석해야 한다.

## 6.2 `if`의 기본 형태: 참이면 실행, 거짓이면 건너뜀

이제 문법을 보자. C 언어에서 `if`라는 키워드를 써서 만드는 문장인 `if`문은 보안 게이트와 같은 구조를 가진다.
조건을 통과해야만 안쪽 코드가 실행된다. 

**문법 (*syntax*)**

```c
if (조건) {
        /* 조건이 참(true)일 때만 실행되는 내용 */
}
```

`if`문 구조는 크게 세 부분으로 나뉜다. 

- **`if`:** 출입을 허가할지 검사하겠다고 컴퓨터에게 신호를 주는 키워드다.
- **`(조건)`:** 괄호 안에는 검사할 내용이 들어간다. 6.1에서 본 것처럼 값이 0이면 거짓(출입 금지), 0이 아니면 참(출입 허가)으로 해석된다.
- **`{ ... }`:** 블록 (*block*) 내부는 보안 구역이다. 조건이 참일 때만 실행할 문장들을 묶어둔 것이다.

다음은 사용자가 관리자 (*admin*)일 때만 시스템 설정을 초기화하는 코드다.

```c
int main()
{
        int is_admin = 1;        /* 1: 관리자, 0: 일반 사용자 */

        if (is_admin) {          /* is_admin이 0이 아니므로 (참), 중괄호 안으로 진입한다. */

                /* 관리자 권한으로 시스템 초기화 */

        }

        return 0;
}
```

만약 `is_admin`이 `0` (일반 사용자)였다면 어떘을까?

1. **조건식 평가:** 결과인 `0`은 거짓 (*false*)이다.
2. **분기:** 결과가 `0`이므로 블록을 실행하지 않는다.
3. **블록 다음 문장 실행:** `return 0;`이 실행된다. 시스템은 초기화되지 않았다.
 
여기서 핵심은, `if`문이 코드의 실행 흐름을 갈라놓는다는 것이다.
조건이 거짓이라면 해당 블록은 실행되지 않는다 (*skip*). 
일직선으로 흐르던 실행 흐름이 조건에 따라 달라지게 되는데, 이를 컴퓨터 과학에서는 분기 (*branch*)라고 한다. 

> [!NOTE]
> **보안 관점: CPU의 조건 분기**
>
> CPU는 조건의 결과에 따라 특정 위치로 점프하거나 다음 명령을 계속 실행하며, 이를 조건 분기(*conditional branch*)라고 한다.
>
> 메모리 취약점 등을 이용해 분기 대상 주소를 바꾸는 공격을 실행 흐름 조작(*control flow hijacking*)이라고 한다.
>
> 조건을 올바르게 작성하는 것은 입력 검증과 논리 오류를 막는데 중요하며, 이는 보안 프로그래밍의 기본이 된다.

> [!NOTE]
> **보안 관점: 해커와의 숨박꼭질**
>
> 우리가 `if`문으로 올바른 길을 안내하려 노력하는 동안, 해커들은 그 길을 비틀어 샛길로 빠기게 만들려고 한다.
> 개발자가 작성하는 C 코드가 엉성하면(취약점이 있으면),
> 운영체제는 *data execution prevention*, *address space layout randomization*,
> *control flow integrity* 라는 기술들로 프로그램을 필사적으로 지키려고 노력한다.
> 하지만 이 방어막들도 우회 기법이 존재하므로,
> 애초에 보안 프로그래밍 (*secure coding*)으로 취약점을 만들지 않는 것이 최고다. 

## 6.3 비교 기호 6개: "조건"을 만드는 기본 재료

판단을 내리려면 기준이 있어야 하고, 그 기준을 확인하려면 비교를 해야 한다. 
C 언어에서는 다음 6가지 관계 연산자 (*relational operator*)를 사용해 두 값을 비교한다.

|기호|뜻|보안 예시|참이 되는 경우|
|:---:|:---|:---|:---|
|`==`|같다|`pw == input`|비밀번호가 일치할 때|
|`!=`|다르다|`hash != origin`|파일이 변조되었을 때|
|`<`|작다 (미만)|`user_level < 3`|권한이 부족할 때|
|`>`|크다 (초과)|`len > buffer_len`|버퍼 크기 초과|
|`<=`|작거나 같다|`try_count <= 5`|시도 횟수 제한 내|
|`>=`|크거나 같다|`age >= 19`|성인 인증 통과|

> [!CAUTION]
> **`=` vs `==`:** 수학과 다른 위험한 함정
>
> 초보 개발자가 자주 저지르는 실수가 이 기호를 혼동하는 것이다.
> 
> - **수학:** `a = b` (같다)
> - **C 언어:**
>     - `a = b` (대입: `b`의 값을 `a`에 저장한다)
>     - `a == b` (비교: 같은지 확인한다)
>
> 만약 실수로 `if (is_admin = 1)`이라고 작성했다고 가정해보자.
> 1. `is_admin` 변수에 `1`이 저장된다.
> 2. C 언어는 이 수식의 결과를 `1` (참)으로 판단한다.
> 3. 그 결과 관리자 권한이 무조건 허용된다.
>
> 결과적으로 단순한 오타가 아니라, 시스템 전체를 위험에 빠뜨리는 권한 상승 버그가 된다.

> [!TIP]
> **보안 관점: 요다 표기법 (*yoda conditions*)**
>
> `==`와 `=`를 혼동하는 치명적인 실수를 막기 위해, 일부 보안 개발자들은 상수를 왼쪽에 쓰는 습관을 들인다.
> - **`if (x = 5)`:** 컴파일러가 에러를 내지 않는다 (실수하기 쉽다)
> - **`if (5 = x)`:** 컴파일 에러가 발생한다. (`5`에 `x`를 대입할 수 없으므로)
> 마치 스타워즈의 요다처럼 말한다고 해서 요다 표기법이라고 부른다. (`if (5 == x)`로 쓰면 안전하다.)
>
> 다만 가독성이 떨어질 수 있어 팀 스타일에 따라 사용 여부를 결정한다.
 
**비교 연산의 결과**

비교식은 수식 (*expression*)의 일종이기 때문에, 결과값이 있다.

- **비교 결과가 참일 때:** 결과 값은 `1`이 된다.
- **비교 결과가 거짓일 때:** 결과 값은 `0`이 된다.

비교 연산자의 결과는 항상 `int` 타입이며, 값은 `0` 또는 `1`이다. 
6.1에서 본 C 언어의 참과 거짓 규칙과도 연결된다.

```c
if (a > b)
```

와 같은 코드가 있으면, 컴퓨터는 `a > b`를 계산해서 `0`또는 `1`로 평가한 뒤에 `if`문을 실행한다.

**코드에서 확인하기**

```c
int main()
{
        int a = 10;
        int b = 3;
    
        int t1, t2;
    
        t1 = (a > b);       /* 결과: 1 */
        t2 = (a < b);       /* 결과: 0 */

        return 0;
}
```

## 6.4 `if - else`: 둘 중 하나만 실행하기 (양자택일)

앞서 배운 `if` 문은 조건이 맞으면 실행하고, 아니면 무시하는 옵션과 같았다. 

하지만 보안의 현실에서는 허용이냐 차단이냐 중에 하나를 반드시 선택해야 하는 경우가 더 많다.

- **악성 코드:** 가상 머신(분석 환경)이면 활동을 하지 않고, 실제 PC면 공격한다.
- **보안솔루션:** 해킹 시도면 차단하고, 정상 유저면 통과시킨다. 

그럴 때 쓰는 것이 `else`("그렇지 않으면")다.

**문법 (*syntax*)**

```c
if (조건) {
        /* 조건이 참 (true)일 때 실행되는 내용 */
} else {
        /* 조건이 거짓 (false)일 때 실행되는 내용 */
}
```

`if-else`는 두 갈래 길이다. 조건식은 항상 `0` 또는 `0`이 아닌 값으로 평가되므로, 두 블록 중 정확히 하나만 실행된다.

**예제: 앱 무결성 보호 (*anti-debugging*)**

보안팀은 앱이 디버거에 의해 분석되고 있는지 감지해, 의심 환경에서는 동작을 제한하거나 변경한다 (*anti-debugging*). 

- **상황:** 유저가 앱을 실행한다.
- **보안 정책:** 정상적인 실행이라면 로그인 화면을 보여주고, 해킹 도구가 감지되면 앱을 종료하거나 민감 기능을 차단한다.

```c
/* 운영체제에게 내 프로그램을 분석하는 debugger가 있는지 물어본다 */
if (is_debugger_detected()) {
        /* 참 (true): 디버거가 감지되었다. */
        send_security_log("Hacking Attempt Detected!");    /* 현재 상황을 기록한다. */
        terminate_app();                                   /* 앱을 종료하거나 민감 기능을 차단한다. */
} else {
        /* 거짓 (false): 정상 환경이다. 서비스를 제공한다. */
        show_login_screen();                               /* 정상 서비스를 실행한다. */
}
```

보안 관리자에게 `if-else`는 보안 정책을 강제하는 기본 수단이다.
환경 검증, 권한 검증, 입력 검증은 결국 `if-else`로 구현된다. 

- **`if` (위협 감지):** 즉시 서비스를 중단하고 방어 태세로 전환한다.
- **`else` (안전함):** 안전이 확인되면 정상적인 서비스를 제공한다.

보안이 중요한 금융 앱에서 이런 코드가 없다면, 공격자가 권한 검사를 우회하거나 비정상 입력으로 로직을 망가뜨릴 여지가 생긴다.

> [!NOTE]
> **윈도우의 `IsDebuggerPresent()` 기능**
>
> 실제로 윈도우 운영체제는 보안 API (*application programming interface*)로 비슷한 기능을 제공한다.
> `IsDebuggerPresent()` 함수는 현재 내 프로그램이 디버거에 의해 분석당하고 있는지를
> `0` (분석되고 있지 않음) 또는 `0`이 아닌 값 (분석되고 있음)으로 알려준다.

## 6.5 `else if`: 다중 선택

세상 일은 모 아니면 도처럼 두 가지로만 나뉘지 않는다. 

보안 등급(관리자, 유저, 게스트)처럼 세 개 이상의 선택지가 필요할 때가 훨씬 많다.

보안 장비는 수만 가지의 네트워크 신호를 구분해서 처리해야 한다.

그럴 때는 `if`와 `else` 사이에 `else if`를 끼워 넣어 보안 필터의 단계를 계속 늘릴 수 있다. 

**문법 (*syntax*)**

```c
if (조건1) {
        /* 조건1이 참일 때 실행되는 내용 */
} else if (조건2) {
        /* 조건1은 거짓이고, 조건2가 참일 때 실행되는 내용 */
} else {
        /* 위의 모든 조건이 거짓일 때 실행되는 내용 */
}
```
마치 여러 층으로 된 보안 검색대와 같다. 
위에서부터 차례대로 조건을 검사하다가, 하나라도 걸리면(참이면) 그 조취를 취하고 전체 검문을 종료한다.

**예제: 방화벽의 포트 필터링 (*port filtering*)**

방화벽은 들어오는 패킷의 **포트 번호(Port)**를 보고 문을 열어줄지 결정한다.

- **22번:** 관리자용 원격 접속 (SSH)은 무조건 허용
- **80번:** 웹사이트 접속 (HTTP)은 기록 후 허용
- **그 외:** 정체불명의 접속 시도는 차단

```c
int main()
{
        int port = 3389;   /* 해커가 원격 데스크톱(RDP)으로 접속 시도 중! */
        
        /* Rule 1: 관리자 전용 포트 (SSH) */
        if (port == 22) {
                /* [ALLOWED] 관리자 원격 접속을 승인합니다. */
        }
        /* Rule 2: 일반 웹 서비스 포트 (HTTP) */
        else if (port == 80) {
                /* [LOGGING] 웹 접속 기록을 남기고 승인합니다. */
        }
        /* Rule 3: 그 외 모든 포트 (Default Deny) */
        else {
                /* [BLOCKED] 허용되지 않은 포트 접근 차단!*/
        }
    
        return 0;
}
```

**핵심 규칙: 선착순 1명과 보안의 함정**

`else if`를 쓸 때 가장 중요한 규칙은 위에서부터 검사해서 처음 참이 되는 블록 하나만 실행한다는 점이다.

만약 22번 포트로 접속했다면? 첫 번째 `if` 문에서 잡혀서 접속이 승인되고, 뒤에 있는 `else if`나 `else` 블록은 실행되지 않는다.

> [!CAUTION]
> **보안 관점: 규칙 그림자 (*rule shadowing*)**
>
> 방화벽 (*firewall*) 설정을 할 때 이 순서가 매우 중요하다.
> 만약 모든 접속 허용(`if`) 규칙을 맨 위에 두고, 해커 IP 차단(`else if`) 규칙을 그 아래에 두면 어떻게 될까?
> 해커가 들어와도 첫 번째 규칙("모든 접속 허용")에 걸려 통과되고, 차단 규칙은 영원히 실행되지 않는다.
> 상위 규칙이 하위 규칙을 가린다고 하여 *rule shadowing*이라고 한다.
> 보안 정책은 항상 구체적인 차단/허용 규칙을 먼저(`if`), 포괄적인 규칙을 나중에(`else`) 배치해야 한다.


## 6.7 자주 쓰는 조건 패턴 4가지

조건문 문법 공부는 끝났다. 여기부터는 실전이다. 
프로그래머들이 밥 먹듯이 사용하는 4가지 조건문 패턴을 익혀본다. 
나중에 수만 줄짜리 코드를 짜게 되어도 계속해서 등장하는 기본기 중의 기본기다.

### 6.7.1 0인지 검사하기: 시스템 붕괴 막기 (방어적 프로그래밍)

5장에서 우리는 0으로 나누는 것은 수학적으로 불가능하며, 컴퓨터에서도 금지된다고 배웠다. 
사용자가 실수로 입력했든, 해커가 일부러 0을 넣었든, 프로그램은 위험한 상황을 스스로 막아야 한다.

```c
int main()
{
        int a = 10;
        int b = 0;
        int q;

        /* 안전장치: 나누는 수(b)가 0이 아닐 때만 계산한다 */
        if (b != 0) {
                q = a / b;      
        } else {
                /* 0이라면 계산하지 않고 0으로 처리하거나, 에러 메시지를 띄운다 */
                q = 0;          
        }

        return 0;
}
```

`if` 문은 단순히 분기하는 것을 넘어, 프로그램이 뻗지 않도록 (*crash*) 막아주는 에어백 역할도 할 수 있다. 
현장에서는 방어적 프로그래밍(*defensive programming*) 이라고 부른다.

> [!NOTE]
> **보안 관점: DoS (*denial of service*) 공격과 가용성**
>
> 만약 서버 프로그램에 이런 방어 코드가 없다면?
> 해커는 고의로 0을 입력값으로 보내 서버를 강제 종료(*crash*)시킬 것이다.
> 서비스 거부 공격(DoS: *denial of service*)이라고 한는데, 서비스가 중단되면 회사는 막대한 손해를 입는다. 
> if (b != 0) 한 줄은 수천만 원짜리 서버를 지키는 가장 저렴하고 확실한 보험이다. 

### 6.7.2 짝수/홀수 판별하기: `%` 연산자의 패턴화

`%` (나머지 연산)는 단순히 나머지를 구하는 계산기가 아니다. 
프로그래밍에서 `%`는 규칙적인 패턴을 만들어내는 강력한 도구다.

```c
if (n % 2 == 0) {
    /* 짝수 (even): 2로 나눈 나머지가 0 */
} else {
    /* 홀수 (odd): 2로 나눈 나머지가 1 */
}
```

보안 분야에서는 이 간단한 원리를 응용해 엄청난 양의 디도스(DDoS, *distributed denial of service*) 공격 트래픽을 분산시키거나, 암호화 키를 교체하는 규칙을 만든다. 

**보안 예제: 방화벽 부하 분산 (*load balancing*)**

해커가 초당 10만 번의 공격을 퍼부어 방화벽을 다운시키려 한다고 가정해보자. 방화벽 한 대로는 버틸 수 없다.

하지만 `% 2`를 사용하면 트래픽을 정확히 반반으로 나누어 두 대의 장비에 분산시킬 수 있다. 라운드 로빈(*round robin*) 방식이라고 한다.

```c
int main()
{
        int packet_id = 1004;  /* 들어온 패킷의 고유 번호 */

        /* 패킷 번호를 2로 나눈 나머지로 홀짝을 판별한다 */
        if (packet_id % 2 == 0) {
                /* 짝수 패킷 -> 1번 방화벽으로 보낸다 */
                send_to_firewall_A(); 
        } 
        else {
                /* 홀수 패킷 -> 2번 방화벽으로 보낸다 */
                send_to_firewall_B();
        }
        return 0;
}
```

이처럼 `%` 연산자는 데이터를 분산처리하기 위해 분류하는 가장 빠르고 효율적인 방법이다. 장비가 더 많아지면 `%` 하는 숫자를 늘리면 된다. 

### 6.7.3 범위 검사하기: 음수 출금 공격 (*money copy bug*)

어떤 값이 정상적인 범위 안에 있는지 검사하는 것을 보안 용어로 입력값 검증 (*input validation*)이라고 한다. 
해커가 시스템의 허점을 찌르는 것을 막는 제1 방어선이다.

은행 시스템에서 돈을 출금하는 기능을 만든다고 가정해보자.
출금을 하면, $잔액 = 잔액 - 출금액$이라는 수식을 써서 잔액을 업데이트 한다. 만약 개발자가 출금액이 0보다 커야 한다는 검사를 깜빡하면 어떤 일이 벌어질까?

해커는 -50,000원을 출금하겠다고 입력한다.

1. **수식:** $잔액 - (-50,000)$
2. **결과:** 마이너스와 마이너스가 만나면 플러스가 된다. $잔액 + 50,000$
3. **오동작:** 돈을 뺐는데 오히려 잔액이 늘어나는 돈 복사 버그가 발생한다.

```c
int main()
{
        int balance = 10000;    /* 현재 잔액 10,000원 */
        int withdraw = -50000;  /* 해커의 공격: 음수 금액 출금 시도! */

        /* [보안 패치] 입력값 검증: 0 이하의 값은 즉시 차단한다. */
        /* 이 코드가 없으면 해커는 부자가 된다. */
        if (withdraw <= 0) {
                /* [경고] 잘못된 금액입니다. (해킹 시도 탐지) */
        } 
        else if (withdraw > balance) {
                /* [오류] 잔액이 부족합니다. */
        }
        else {
                /* 모든 검증을 통과한 안전한 경우에만 계산한다 */
                balance = balance - withdraw;

                /* 출금 완료. 남은 잔액: balance */
        }

        return 0;
}
```
이처럼 `if` 문을 사용한 범위 검사는 단순한 문법이 아니라, 시스템의 논리적 결함 (*logical flaw*)을 방어하는 가장 강력한 방패다.

> [!NOTE]
> **보안 관점:** 모든 입력을 의심하라
>
> 보안 관리자는 유저가 입력한 데이터를 절대 믿지 않는다 (*never trust user input*).
> 유저가 실수로, 혹은 악의적으로 엉뚱한 값을 넣을 것이라고 항상 가정하고 방어 코드를 작성해야 한다.

### 6.7.4 값 잘라내기: 범위를 벗어나면 강제로 고정하기 (*clamping*)
값이 너무 작거나 너무 클 때, 범위를 벗어났다고 에러를 내는 대신 강제로 범위 안으로 끌고 들어오는 방법도 있다. 
전문 용어로 클램핑(*clamping*) 이라고 한다.

```c
int main()
{
        /* x의 범위가 0부터 100까지만 유효하다고 가정하자 */
        int x = 120;         /* 범위(0 ~ 100)를 벗어난 값

        if (x < 0) {
                x = 0;       /* 너무 작으면 0으로 고정 */
        }
        else if (x > 9) {
                x = 9;       /* 너무 크면 9로 고정 */
        }
        
        /* 결과: x는 이제 안전하게 9가 된다 */
        
        return 0;
}
```

클램핑이 어디에 쓰일까?

- 볼륨 조절: 볼륨을 계속 높여도 100을 넘어가면 안된다. (100으로 고정)

- 게임 체력: 체력이 0보다 떨어지면 마이너스가 아니라 0이 되어야 한다.

- 배열 접근: 나중에 배울 '배열'에서 정해진 칸을 벗어나지 않게 할 때 필수적이다.


## 6.8 초보자가 가장 많이 하는 실수 3가지
C 언어를 처음 배울 때, 코드가 빨간 줄(에러) 없이 컴파일은 되는데 프로그램이 이상하게 동작하는 경험을 하게 된다. 
문법을 몰라서가 아니라, C 언어의 유연함이 독이 되는 순간이다.

가장 치명적인 3가지 함정을 미리 파악하고 피하는 법을 배워봅시다.

### 6.8.1 = 와 ==를 헷갈리기 (가장 중요)
= (대입 연산자): 오른쪽 값을 왼쪽에 넣는다. (Action)

== (비교 연산자): 양쪽이 같은지 본다. (Question)

초보자가 가장 많이 하는 실수는 비교해야 할 자리에 대입을 하는 것이다.

```c
int x = 10;

/* 의도: x가 0과 같다면... (비교) */
/* 실제: x에 0을 대입하고, 그 결과인 0을 검사 */
if (x = 0) {
    /* 절대 실행되지 않음 */
}

/* 더 무서운 경우 */
if (x = 5) {
    /* x에 5가 들어가고, 5는 '참'이므로 무조건 실행됨! */
}
```

도대체 왜 컴파일러는 이걸 허용할까? 이를 이해하려면 **식(Expression)** 이라는 용어를 딱 한 번만 짚고 넘어가야 한다.

✅ 식(Expression)이란? C 언어에서 "계산이 끝나면 값 하나가 툭 떨어지는 코드 조각"을 말한다.

1 + 2 → 계산하면 3이 남는다. (식 O)

x > 0 → 비교하면 1 또는 0이 남는다. (식 O)

x = 0 → (중요) x에 0을 넣는 동작을 하고, 그 결과 값인 0이 남는다. (식 O)

if ( ... )의 괄호 안은 바로 이 **'식'**이 들어가는 자리다. 
컴퓨터 입장에서 x = 0은 문법적으로 완벽한 '식'이다. 
결과 값 0이 나오니 if (0)이 되어 '거짓'으로 처리될 뿐이다. 
이 논리적 허점을 피하려면 의식적으로 ==를 써야 한다.

### 6.8.2 if (조건); 처럼 세미콜론 붙이기
코드를 짜다 보면 습관적으로 문장 끝에 세미콜론(;)을 붙이게 된다. 
하지만 if 뒤에 붙으면 재앙이 된다.

```c
if (x > 0);  /* ← 여기가 문제! (빈 문장 실행) */
{
    x = x + 1; /* if와 상관없이 무조건 실행됨 */
}
```
이유는 단순하다.

C 언어에서 ; 하나도 "아무것도 하지 마라"는 뜻을 가진 온전한 문장(Null Statement)이다.

if의 정식 문법은, 
```
if (식) 문장 else 문장
```
이다. 우리가 쓰던 블락 `{ }`도 하나의 문장에 속한다.

결국 `if (식) ; { x = x + 1; }` 에서 `if`는 ;(아무것도 안 함)을 실행하고 끝나버린다.

그 뒤의 { ... } 블록은 if와 연결이 끊긴 채, 그냥 홀로 존재하는 코드가 되어 무조건 실행된다.

**규칙:** if (...) 뒤에는 절대로 ;를 붙이지 않는다.

### 6.8.3 중괄호 { }를 생략하기
C 언어는 `if` 뒤에 실행할 문장이 딱 한 줄이면 중괄호를 생략해도 된다는 규칙이 있다. 하지만 우리는 **이 규칙을 잊어버리는 게 좋다**.

```c
if (x > 0)
    x = x + 1;     /* if에 걸림 */
    x = x + 10;    /* 들여쓰기를 했지만, if와 관계 없음 (항상 실행) */
```
사람 눈에는 들여쓰기 때문에 두 줄 모두 if에 묶인 것처럼 보인다. 
하지만 C 컴파일러(그리고 CPU)는 들여쓰기를 전혀 신경 쓰지 않는다. 
오직 문법만 봅니다. 이로 인해 심각한 버그가 발생합니다.

✅ 우리만의 약속: 무조건 묶는다. 실행할 코드가 단 한 줄이라도, 심지어 비어 있더라도 if와 else 뒤에는 반드시 중괄호 { }를 쓴다. 현업 프로그래머들의 안전 수칙이기도 하다.

## [Tip] 요다 표기법 (Yoda Notation)
스타워즈의 요다처럼 어순을 바꿔쓰는 방식이다.
- `if (x == 5)` 대신 `if (5 == x)`라고 쓴다.
만약 실수로 `if (5 = x)`라고 쓰면? 상수에 값을 대입할 수는 없으므로 컴파일러가 즉시 **에러**를 뱉어낸다. 실수를 원천 봉쇄하는 아주 똑똑한 (하지만 조금 이상해 보이는) 습관이다.

