# 8. 여러 값을 한꺼번에 다루기: 배열(Array)

우리는 지금까지 `int x;`처럼 **값 하나를 담는 상자(변수)** 를 만들고, 

`if`로 **조건에 따라 다른 일을 하고**, 

`for`로 **같은 일을 여러 번 반복하는 법**을 배웠다.

그런데 현실 문제는 값이 하나만 있는 경우가 거의 없다.

- 장비에서 센서가 1초마다 측정한 온도 60개
- 업체에서 12개월간 발생한 매출
- 게임에서 몬스터 100마리의 체력

같은 상황에서 변수로만 프로그래밍을 하려고 한다면, 

```c
int s0, s1, s2, s3, s4, s5, s6, s7 /* ... */ ; /* 지옥 시작 */
```

과 같이 필요한만큼 변수들을 많이 만들어야 한다. 

여기서 필요한 것이 **배열**이다. 

> 배열은
>
> **같은 타입의 상자가 여러 칸 줄지어 있는 것**이다. 마치 똑같은 구조의 집이 쭉 늘어선 아파트와 같다.

## 8.1 배열이 필요한 이유: "많은 값"을 다루는 기본 단위

`for`문은 "0, 1, 2, 3, ..."처럼 숫자들에 순서를 부여할 수 있다는데 강점이 있다.

배열은 "0번째 값, 1번째 칸, 2번째 칸, 3번째 칸, ..."처럼 번호를 붙여서 여러 변수들을 쓸 수 있다. 

`for`문으로 만들어낸 숫자를 배열의 '방 번호'로 쓰면, 엄청난 시너지를 낼 수 있다.

비유를 하지면, 

- 배열: 물건이 순서대로 정리된 긴 선반
- `for`문: 그 선반을 처음부터 끝까지 지나가는 자동 레일 위에 있는 엔진

선반(배열)은 가만히 있지만, 엔진(`for`)가 0번부터 끝까지 돌면서 값을 하나씩 처리해준다.

## 8.2 배열의 기본 모양: "한 줄로 늘어선 똑같은 타입 상자들"

예를 들어 `int` 배열은 이런 느낌이다.

```
 a[0]    a[1]    a[2]   a[3]    a[4]
[상자]  [상자]  [상자]  [상자]  [상자]  
```

각 칸은 `int` 변수 하나와 똑같은 역할을 한다. 
- `a[0]`도 `int` 변수 하나
- `a[1]`도 `int` 변수 하나
- ... 전부 `int` 변수다.

여기서 대괄호 `[ ]` 안의 숫자를 **인덱스(Index)** 라고 부른다. 
"몇번째 칸이냐"를 뜻하는 번호로, 우리는 그냥 방번호라고 생각해도 된다.

## 8.3 배열 선언: "몇 칸짜리 선반을 만들 건가?"

배열을 만드는 문법은 다음과 같다.

```c
int a[5];
```

의미는 이렇게 해석하면 된다. 
- `int`: 이 선반의 각 칸은 정수 상자다.
- `a`: 선반 이름은 a다.
- `[5]: 칸이 5개다. 

**C89에서 중요한 사실 1: 배열 크기는 "고정"이다**

우리가 따르는 C89에는 고무줄 같은 배열이 없다. `int a[n];`처럼 실행 중에 배열 크기가 결정되게 할 수 없다.
반드시 `int a[5];`, `int a[100];`처럼 숫자로 딱 박아놔야 한다. 

비유를 하자면, 집을 짓는 공사를 시작하기 전에 설계도에 방 개수가 적혀있어야 하는 것과 같다. 

**C89에서 중요한 사실 2: 선언은 블록 맨 위에서**

배열도 변수 선언이므로, C89 규칙에 따라 함수나 블록의 맨 윗부분에 몰아서 선언해야 한다.

```c
int main()
{
    int i;
    int a[5];  /* 배열 선언도 변수 선언 구역에! */

    /* ... 실행 코드 ... */

    return 0;
}
```

⚠️일반 변수 선언과 마찬가지로, 초기값 없이 배열을 선언한 직후에 모든 상자에는 알 수 없는 값이 들어있다. 

## 8.4 배열의 핵심 규칙: 인덱스는 0부터 시작한다

C언어의 문화는 숫자를 0부터 세는 것이다. 우리가 7장에서 `for (i = 0; ...)`으로 시작했던 이유도 여기 있다.

`int a[5];`라면 가능한 인덱스는:
- 첫 칸: `a[0]`
- 마지막 칸: `a[4]`

0부터 차례대로 세어나가보면,

> 크기가 N인 배열의 마지막 인덱스는 N - 1이 된다.

**가장 흔한 실수: `<=` 때문에 "한칸 더"**

다음 코드는 매우 흔한 버그다.

```c
int a[5];

for (i = 0; i <= 5; i = i + 1) { /* 위험! */
    a[i] = 0;
}
```

`i`가 5일 때 `a[5]`를 건드리는데, `a[5]`는 존재하지 않는다. (마지막은 `a[4]`)

정답 패턴은 다음과 같다.

```c
for (i = 0; i < 5; i = i + 1) {
    a[i] = 0;
}
```

## 8.5 배열은 범위를 벗어나면 "미정의 동작"이다
C는 배열 접근에서 안전장치가 없다.
`a[1000]`을 썼다고 해서 자동으로 막아주지 않는다.

배열 범위를 벗어나는 접근은 대표적인 미정의 동작(Undefined Behavior)이다. 

> 미정의 동작이란
> "결과가 보장되지 않으며, 운 좋게 되는 것처럼 보여도 절대 믿으면 안되는 상태"다.

그래서 배열을 다룰 때 가장 중요한 안전수칙은 이것 하나다.

> 인덱스가 0 이상, (크기 - 1) 이하인지 항상 보장하라.

## 8.6 배열에 값 저장하기와 저장된 값 쓰기

**8.6.1 값 저장하기**
`a[i]`는 "i번째 칸"이라는 뜻의 변수이다. 일반 `int` 변수처럼 대입 연산자(`=`)로 값을 저장한다.
```c
a[0] = 10;
a[1] = 20;
a[2] = 10 + 20; /* 계산 결과(30)도 저장할 수 있다! */
```

💡 핵심 포인트: 인덱스는 계산 가능하다. 꼭 숫자만 쓰지 않아도 된다. 변수나 계산식도 인덱스가 된다.
```c
int a[5];
int k = 3;

a[i] = 40;      /* a[3]에 40 대입 */
a[k + 1] = 50;  /* a[4]에 50 대입 */
```
인덱스가 계산 가능하기 때문에 `for (i = 0; ...)` 반복문에서 `a[i]`를 이용해 모든 값을 처리할 수 있는 것이다.

**8.6.2 저장된 값 쓰기**
저장된 값을 쓸 때도 일반 변수와 완벽하게 똑같다. 
```c
int a[5];
int x;
int sum;

a[0] = 10;
a[1] = 20;

/* 상자 안에 저장된 값을 다른 변수에 저장하기 */
x = a[1];  /* 20 */

/* 덧셈에 사용하기 */
sum = a[0] + a[1];  /* 10 + 20 */
```

**요약:** 수식에서 `a[숫자]`라고 쓰는 순간, 그것은 \*\*`int` 변수 하나(`x`)\*\*와 다를 게 전혀 없다.

**8.7 배열 초기화: 만들면서 값 저장하기**

배열도 변수를 만들 때처럼, 선언과 동시에 값을 저장할 수 있다.

1. 꽉 채우기 (완전 초기화)
```c
int a[5] = { 10, 20, 30, 40, 50 };
```
이렇게 쓰면 순서대로 값이 저장된다.

- `a[0] = 10;`
- ...
- `a[4] = 50;`

2. 덜 채우기 (나머지는 0)
칸 수보다 적게 적으면 어떻게 될까?

```c
int a[5] = { 1, 2 };
```

이 경우 **"는 칸은 자동으로 0이 된다**는 규칙이 있다.

- `a[0] = 1;`
- `a[1] = 2;`
- 나머지 `a[2]`, `a[3]`, `a[4]`는 모두 `0`

꿀팁: 싹 다 0으로 밀고 싶을 때 `int a[5] = { 0 };`이라고 적으면, 첫 칸은 0, 나머지도 규칙에 따라 자동 0이 되므로, 
배열 전체가 깔끔하게 0으로 초기화된다.

3. 안 채우기 (초기화 생략)
```c
int a[5];
```

5장에서 배운 변수와 같다. 메모리 공간을 할당만 받고, 아직 값을 저장하지 않았기 때문에, 
이전에 메모리에 남아있던 알 수 없는 값이 들어있을 수 있다.

4. (보너스) 칸 수 생략하기
초기화 값이 있으면, 굳이 칸 수를 세지 않고 컴퓨터에게 맡길 수도 있다.
```c
int a[] = { 1, 3, 5 }; /* 칸 수를 빈칸으로 둠 */
```

대괄호를 비워두면, 컴파일러가 "값이 3개네?" 하고 알아서 `int a[3]`으로 만들어준다. 

## 8.8 for + 배열: "전체를 처리하는" 가장 기본 패턴

배열은 혼자 쓰이는 법이 거의 없다. 항상 `for`문과 단짝처럼 붙어 다닌다.

`for`문의 루프 변수 `i`가 0번 방부터 마지막 방까지 차례대로 방문하면서 작업을 처리하기 때문이다.

**예제 1: 배열을 0으로 쓰기**

반복문을 돌며 각 칸(`a[i]`)에 값을 대입하는 패턴이다.

```c
int main()
{
    int i;
    int a[5];

    /* i가 0, 1, 2, 3, 4로 변하면서 모든 칸을 방문 */
    for (i = 0; i < 5; i = i + 1) {
        a[i] = i;  /* i를 저장 */
    }

    /* 배열 a에는 0, 1, 2, 3, 4가 저장되어 있다. */

    return 0;
}
```

**예제 2: 합계 구하기 (스캔 + 누적)**

배열의 값을 하나씩 꺼내서(`a[i]`) 어딘가에 계속 더하는(`sum`) 패턴이다. 

```c
int main()
{
    int i;
    int a[5] = { 10, 20, 30, 40, 50 };
    int sum = 0;   /* 합계를 저장할 변수. 0으로 초기화 필수! */

    for (i = 0; i < 5; i = i + 1) {
        sum = sum + a[i];   /* 기존 sum에 현재 칸의 값을 더하기 */
    }

    /* 여기서 sum에는 10 + 20 + 30 + 40 + 50이 저장되어 있다. */

    return 0;
}
```

`sum = sum + a[i]` 코드가 실행될 때 변수들이 어떻게 변할까?
|`i` (인덱스)|`a[i]` (현재 값)|`sum` (누적 전)|`sum + a[i]` (누적 후)|
|*-*|*-*|*-*|*-*|
|0|10|0|10|
|1|20|10|30|
|2|30|30|60|
|3|40|60|100|
|4|50|100|150|

마치 눈덩이를 굴리듯 `sum`이 점점 커지는 것을 볼 수 있다.

**예제 3: 피보나치 수열 구하기**

이전 값을 활용하는 패턴이다. 
피보나치 수열은 `1, 1, 2, 3, 5, 8, ...`처럼 나가는 수열이다. 규칙은 간단하다: "내 값 = 바로 앞 값 + 그 앞 값". 
코드로 표현하면 다음과 같다: `a[i] = a[i - 1] + a[i - 2];`

```c
int main()
{
    int i;
    int a[10]; /* 10개짜리 수열 만들기 */

    /* 1. 처음 두 값은 규칙으로 만들 수 없어서 직접 저장해야 한다. */
    a[0] = 1;
    a[1] = 1;

    /* 2. 3번째 칸(인덱스 2)부터 반복 시작! */
    for (i = 2; i < 10; i = i + 1) {
        a[i] = a[i - 1] + a[i - 2];
    }

    /* 배열 a에는 1, 1, 2, 3, 5, 8, 13, 21, 34, 55가 저장되어 있다. */
    return 0;   
}
```

이 예제는 배열을 사용하는 가장 멋진 이유 중 하나인 **"이전 값 활용하기"**를 보여줍니다.앞선 예제들은 각 칸이 독립적이었지만, 이번에는 "앞의 두 칸을 더해서 현재 칸을 채우는" 규칙이 적용됩니다.예제 3: 피보나치 수열 (앞의 두 수 더하기)피보나치 수열은 1, 1, 2, 3, 5, 8... 처럼 나가는 수열입니다.규칙은 간단합니다: "내 값 = 바로 앞 값 + 그 앞 값"코드로 표현하면 다음과 같습니다.$$a[i] = a[i-1] + a[i-2]$$C#include <stdio.h>

int main(void)
{
    int i;
    int a[10]; /* 10개짜리 수열 만들기 */

    /* 1. 처음 두 값은 규칙으로 못 만드니 직접 넣어야 함 */
    a[0] = 1;
    a[1] = 1;

    /* 2. 3번째 칸(인덱스 2)부터 반복 시작! */
    /* 중요: i가 0이나 1이면 i-2가 음수가 되어 에러 발생 */
    for (i = 2; i < 10; i = i + 1) {
        a[i] = a[i - 1] + a[i - 2];
    }

    /* 3. 결과 출력 */
    for (i = 0; i < 10; i = i + 1) {
        printf("%d ", a[i]);
    }
    
    return 0;
}

**🔍 이 코드의 핵심 포인트**

**1. 반복문 시작이 `i = 0`이 아니다!** 이 코드는 `for (i = 2; ...)`로 시작한다.
만약 `i = 0`부터 시작했다면 어떻게 될까? `a[0] = a[-1] + a[-2]`가 된다. 
여기서 `a[-1]`과 `a[-2]`는 배열 밖의 메모리를 의미하기 때문에 쓸 수 없다. 
또한 `a[1] = a[0] + a[-1]`이 된다.
여기서 `a[0]`은 문제가 없지만 `a[-1]`은 배열 밖의 메모리를 의미해서 쓸 수 없다.
`a[2] = a[1] + a[0]`부터는 문제가 없다.
그래서 앞의 두개 (`0`, `1`)은 수동으로 채워주고, 안전하게 2번 방부터 규칙을 적용해야 한다.

**2. 인덱스 계산 (`i - 1`, `i - 2`)** 배열의 인덱스 자리에는 더하기, 빼기 같은 계산식을 자유롭게 쓸 수 있다.
인덱스를 계산해서 쓸 수 있다는 것이 배열을 강력하게 만드는 원동력이 된다. 




## 8.9 배열의 함정: 통째로 대입은 불가능하다

**배열의 이름은 그저 '집 주소(간판)'일 뿐, 집 자체가 아니다.** 
그래서 등호(`=`)로 한 번에 저장하려고 하면 에러가 난다.

❌ **잘못된 방법 (컴파일 에러)**
```c
int a[3] = {1, 2, 3};
int b[3];

b = a;   /* 에러! 배열은 통째로 대입할 수 없다. */
```

**왜 안될까?** `b = a;`라고 쓰는 것은 컴퓨터에게 "b라는 아파트를 들어서 a 아파트 위치로 옮겨라"라고 하는 것과 같다. 
C언어에서 배열의 위치(주소)는 만들어질 때 고정되므로 바꿀 수 없다.

✅ **올바른 방법 (for문으로 한 칸씩)**
이사할 때 짐을 하나하나 옮기듯이, 반복문을 이용해 한 칸씩 값을 복사해야 한다.

```c
int i;
int a[3] = {1, 2, 3};
int b[3];

/* 한 칸씩 꺼내서 옮겨 담기 */
for (i = 0; i < 3; i = i + 1) {
    b[i] = a[i];
}
```
작성하신 내용은 초보자가 가장 이해하기 어려워하면서도 반드시 알아야 할 C언어의 특징을 정확히 짚으셨습니다.

다른 언어(Python 등)에서는 b = a가 되기 때문에 더욱 헷갈리는 부분입니다. **"왜 안 되는지"**에 대한 비유와 **"올바른 해결책"**을 시각적으로 정리해 드리겠습니다.

8.9 배열의 함정: 통째로 대입은 불가능하다
배열의 이름은 그저 '집 주소(간판)'일 뿐, 집 자체가 아닙니다. 그래서 등호(=)로 한 번에 복사하려 하면 에러가 납니다.

❌ 잘못된 방법 (컴파일 에러)

C
int a[3] = {1, 2, 3};
int b[3];

b = a;  /* 에러! 배열은 통째로 대입할 수 없다. */
왜 안 될까? b = a;라고 쓰는 것은 컴퓨터에게 "b라는 아파트를 들어서 a 아파트 위치로 옮겨라" 혹은 **"b라는 간판을 떼서 a에 붙여라"**라고 하는 것과 같습니다. C언어에서 배열의 위치(주소)는 태어날 때 고정되므로 바꿀 수 없습니다.

✅ 올바른 방법 (for문으로 한 칸씩)

이사할 때 짐을 하나하나 옮기듯이, 반복문을 이용해 한 칸씩 값을 복사해야 합니다.

C
int i;
int a[3] = {1, 2, 3};
int b[3];

/* 한 칸씩 꺼내서 옮겨 담기 */
for (i = 0; i < 3; i = i + 1) {
    b[i] = a[i];
}
`a[0]`의 값이 `b[0]`으로, `a[1]`이 `b[1]`로 복사되어 쌍둥이 배열이 만들어진다.

