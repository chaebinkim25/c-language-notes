# 12. 문자와 문자열: `char`의 세계

10장에서 모든 값은 메모리에 저장된다는 것을 봤고, 11장에서 그 주소를 다루는 포인터를 배웠다. 
지금 시점에 남은 큰 질문이 하나 있다. "좋아, 숫자는 알겠는데... 글자는 메모리에 어떻게 저장하지?"

사실 컴퓨터 메모리에는 '글자'라는 개념이 없다. 오직 0과 1, 숫자뿐이다. C 언어에서 문자를 다루기위한 타입(`char`)는, 
내부적으로 어떤 글자를 어떤 숫자로 나타낼지 미리 약속해 놓고, 메모리에 저장하거나 계산할 때 조그만 정수 타입처럼 쓴다. 

글은 메모리에 어떻게 저장할까? 글자들을 메모리에 일렬로 늘어놓고, 뒤에 "여기서 끝!"을 의미하는 표식을 붙인다. 
문자와 문자열의 실체를 메모리 관점에서 적나라하게 확인해보자.

## 12.0 이 장의 목표

이 장을 끝내면 다음을 이해하고 구현할 수 있다. 

1. **`char`의 이중성**: `char`가 단순한 글자가 아니라, 산술 연산이 가능한 작은 정수임을 이해한다.
2. **값 vs 주소**: 문자 상수 `'A'`(정수)와 문자열 리터럴 `"A"`(메모리 주소)의 결정적 차이를 구분한다.
3. **문자열 처리**: 문자열 길이, 복사, 비교를 직접 구현해보며 문자열 처리 패턴을 내 것으로 만든다.
4. **안전한 코딩**: 배열 범위 초과와 문자열 표기 규칙 위반이 왜 시스템을 망가뜨리는지 알고 예방한다.

## 12.1 문자는 "특별한 것"이 아니라 결국 숫자다. 

데이터와 값 단원에서 우리는 중요한 진실을 마주했었다. 
> "메모리에는 0과 1만 있다. 그것을 무엇으로 보느냐는 우리의 몫이다."

만약 메모리 한 칸(1바이트)에 `01000001` (10진수 65)이라는 값이 들어있다고 가정해보자.

* 정수로 해석하면: 숫자 65가 된다.
* 문자로 해석하면: 알파벳 'A'가 된다. (ASCII 코드를 쓰는 컴퓨터에서)

C언어에서 `char` 타입은 사실 아주 작은 정수다. 그래서 C는 문자를 위한 별도의 복잡한 규칙을 만들지 않고, 정수와 똑같이 취급한다.

\[코드 예시: 정체 확인\]
```c
char ch = 'A'; /* ASCII 코드를 쓰는 컴퓨터에서는 65, EBCDIC 코드를 쓰는 컴퓨터에서는 193 */
```

**`char`의 특징**
- C언어에서 1바이트의 정의는 `char` 타입 하나의 크기와 동일하다.
- `sizeof(char)`를 하면 항상 1을 얻는다.
- C언어에서 `char` 타입의 비트 개수는 최소 8개다. (대부분 8비트를 1바이트로 쓴다.)
- `char` 타입에 음수, 0, 양수를 모두 저장할 수 있게 만들지 (8비트인 경우 -127부터 128까지 저장), 또는 0, 양수만 저장하게 만들지 (8비트인 경우 0부터 255까지 저장), 구현마다 다르게 선택할 수 있다. 

## 12.2 문자 리터럴: 작은따옴표(`' '`)의 약속
우리는 `int` 타입을 할 때 `10` 처럼 코드에 직접 적은 고정된 값을 리터럴이라고 불렀다. 문자도 레터럴로 적는 법을 배워보자. 

C언어에서 문자를 적을 때는 엄격한 규칙이 하나 있다. 문자 하나는 받느시 작은따옴표(`' '`)로 감싼다. 
- `'A'`: (O) 문자 리터럴
- `'z'`: (O) 문자 리터럴
- `'@'`: (O) 문자 리터럴

왜 따옴표가 필요할까? 컴파일러 입장이 되어보자. 따옴표가 없으면 이게 글자인지 변수 이름인지 알 방법이 없다. 

```c
char a = 'B';     /* OK. 변수 a에 글자 'B'를 저장해라. */
char b = B;       /* 에러! 컴파일러는 'B'라는 이름의 변수를 찾기 시작한다. */
```

## 12.3 문자와 산술 연산

문자가 곧 숫자이기에 가능한 마법도 있다. 바로 산술 연산이다.
```c
char next = 'A' + 1;       /* ASCII에서, 65 + 1 = 66, EBCDIC에서, 193 + 1 = 194 */
```

> [!NOTE]
>
> "그럼 `'A'`는 무조건 `65`인가요?" 대다수 환경(ASCII 표준)에서는 그렇다.
> 하지만 드물게 다른 번호 체계(EBCDIC 등)를 쓰는 컴퓨터도 있다.
> 중요한 건 "`65`라는 숫자를 외우지 말라"는 것이다.
> 코드에 `char ch = 65;`라고 쓰는 것보다 `char ch = 'A';`라고 쓰는 것이 훨씬 읽기 좋고,
> 어떤 컴퓨터에서도 안전하게 `'A'`를 의미하게 된다. 컴퓨터에게 번호 찾기를 맡기자.

## 12.4 탈출 문자: `\n`, `\t`, `\0`

키보드로 직접 치기 어려운 문자를 표현하기 위해 C는 `\`로 시작하는 표기(이스케이프 시퀀스)를 제공한다.

| 표기 | 뜻 | 많이 쓰는 곳 |
| :---: | :--- | :--- |
| `'\n'` | 줄바꿈(newline) | 다음 줄로 바꾸기 |
| `'\t'` | 탭(tab) | 간격 맞추기 |
| **`'\0'`** | **null 문자(null character)** | **문자열의 끝 표시** |
| `'\\'` | 역슬래시 `\` 자체 | 파일 경로, 이스케이프 문자 |
| `'\''` | 작은따옴표 `'` | 문자 리터럴 안에서 `'` |

특히 **`'\0'`**는 이 장의 주인공이다.

> `'\0'`는 **정수 값이 0인 문자**로 생각하면 된다.

## 12.5 C 문자열의 정체: `char`배열 + `'\0'`
문자 여러개로 이루어진 글(문자열)은 어떻게 다루면 될까? 우리는 8장에서 배열로 여러 개의 상자를 붙여놓을 수 있다고 했다. 문자열도 `char` 상자 여러 개를 붙여놓으면 된다.

하지만 9장(함수와 배열)에서 배운 치명적인 문제가 있다.

> "배열은 함수에 넘길 때 크기 정보가 사라진다(Decay)."

`int arr[]`를 함수에 보낼 때 `int len`을 같이 보냈던 기억이 날 것이다. 그렇다면 문자열을 다룰 때마다 `strfun(str, 100글자);` 처럼 매번 길이를 알려줘야 할까? 너무 귀찮다.

그래서 C언어는 약속(Convention)을 하나 정했다. **"배열 맨 끝에 0(Null)을 넣어두자. 거기까지만 읽으면 된다."**

### 12.5.1 끝을 표시하는 센티널

배열의 끝에 특별한 기호를 써서 표시하는 방식을 센티널(Sentinel, 보초/감시병) 방식이라고 한다. 

- 길이 정보 방식: "이 데이터는 5칸짜리야." (데이터 앞에 숫자를 적음)
- 센티널 방식(C 문자열): "어디까지인지는 모르겠지만, 가자가 깃발(`'\0'`)이 나오면 멈춰."

이 규칙 때문에 C의 문자열을 **null 종료 문자열(Null-terminated String)** 이라고 부른다. 

### 12.5.2 손으로 문자열 만들기

```c
/* "Hello"는 5글자지만, 배열 크기는 반드시 6이어야 한다! */
char s1[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
```

메모리(배열) 안은 이렇게 생겼다. 

| 인덱스 | 0 | 1 | 2 | 3 | 4 | 5 |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: |
| **값** | 'H' | 'e' | 'l' | 'l' | 'o' | **'\0'** |

문자열의 모든 문자에 대해서 반복 작업을 할 때는, 값이 `'\0'`인 문자를 보면, "아, 여기까지구나"하고 퇴근하면 된다.

> [!WARNING]
>
> 초보자가 가장 많이 하는 실수: "칸 부족"
>
> ```c
> char s[5] = {'H', 'e', 'l', 'l', 'o'};   /* (X) 위험! */
> ```
>
> 이렇게 꽉 채워 버리면 `'\0'`을 저장할 자리가 없다.
> 반복 작업을 할 때 멈추지 못하고 메모리 뒤쪽의 엄한 값까지 계속 처리해대다가,
> 운이 나쁘면 프로그램이 강제 종료된다. 
> 공식: 문자열 배열 크기 = 글자수 + 1 (null 문자 자리)

### 12.5.3 문자열 리터럴로 더 쉽게 만들기 (자동화)

매번 `{ }`로 한 땀 한 땀 넣고, 끝에 `'\0'`까지 챙기는건 실수하기 딱 좋다. 그래서 C는 큰따옴표(`" "`) 문법을 제공한다. 

```c
char s2[] = "Hello";   /* 컴파일러: "5글자군. 뒤에 '\0'을 붙여서 6칸으로 만들어줄게." */
```

1. 자동 계산: `[]`안을 비워두면, 컴퓨터가 알아서 "글자수 + 1" 크기로 배열을 만든다.
2. 자동 마감: 맨 뒤에 `'\0'`을 자동으로 넣어준다.

우리는 이 편한 방법을 주로 사용할 것이다. 하지만 그 뒤에는 "배열 + `\0`"이라는 원리가 숨어있음을 절대 잊으면 안된다. 

## 12.6 문자열 훑기(Iteration): `'\0'`을 만날 때까지

문자열 처리의 대원칙은 딱 하나다. "0번부터 시작해서, null 문자(`'\0'`)가 나올 때까지 한 칸씩 전진한다."

배열의 크기를 몰라도, 글자가 몇 개인지 몰라도 상관없다. 원칙만 지키면 끝을 찾아낼 수 있다.

```c
char s[] = "ABC";   /* 실제로는 {'A', 'B', 'C', '\0'}이 저장됨 */
int i;

/* 핵심 조건: s[i] != '\0' (null 문자가 아니면 계속해라)
for (i = 0; s[i] != '\0'; i++) {
    s[i];    /* 이 식의 계산 결과는 인덱스 i에 해당하는 문자 값 */
}
```

**이 코드가 작동하는 과정 (스캔)**

1. `i=0`, `s[0]`은 `'A'`. (`\0` 아님) -> **실행**
2. `i=1`, `s[1]`은 `'B'`. (`\0` 아님) -> **실행**
3. `i=2`, `s[2]`은 `'C'`. (`\0` 아님) -> **실행**
4. `i=3`, `s[3]`은 `\0`. -> **거짓! 반복 종료**

**왜 `i < 3`이라고 안 했을까?**
만약 `i < 3`이라고 숫자를 박아버리면, `"Hello"`(5글자)를 넣었을 때 코드를 고쳐야 한다.
하지만 `s[i] != '\0'` 조건을 쓰면, `"A"` 한 글자든, 셰익스피어 전집이든 **코드를 단 한 줄도 고칠 필요 없이** 끝까지 읽을 수 있다.

**이 패턴의 확장성**
이 `for` 문 하나로 우리는 문자열을 다루는 표준 함수들을 직접 만들 수 있다.
* **길이 재기:** 훑으면서 숫자(`cnt`)를 1씩 더한다.
* **복사하기:** 훑으면서 다른 배열에 똑같이 넣는다.
* **찾기:** 훑으면서 내가 찾는 글자(`'K'`)인지 확인한다.

## 12.7 "Hello"를 포인터로 받으면 어떤 일이 일어날까?

11장에서 포인터를 배웠으니, 문자열을 다룰 때 `char *p = "Hello";`와 같은 형태도 자주 보게 될 것이다.

언뜻 보면 배열(`char s[]`)과 비슷해 보이지만, 메모리 내부 사정은 완전히 다르다.

1. **"Hello" (문자열 리터럴):** 프로그램이 시작될 때 "읽기 전용 메모리(Read-Only Memory)" 어딘가에 안전하게 저장된다. (절대 수정 불가 구역)
2. **`p` (포인터 변수):** 그 읽기 전용 구역의 주소만 달랑 들고 있다.

**\[함정\] 전시품을 만지지 마시오**

포인터 `p`가 가리키는 곳은 박물관의 전시품과 같다. 눈으로 볼 수는 있지만, 손을 대면 경보가 울린다. 

```c
char *p = "Hello";
p[0] = 'h'; /* [위험!] 읽기 전용 메모리에 쓰기 시도 (미정의 동작, Undefined Behavior) -> 프로그램 강제 종료(Crash) 가능성 높음 */
```

동일한 내용의 문자열 리터럴이 여러개 있을 때, C 언어 표준에서는 메모리에 별도로 존재할 필요가 없다. 
컴파일러가 메모리 절약을 위해 읽기 전용 구역에 하나만 저장하고, 이를 공유할 수 있다. 
만약 프로그램이 문자열 리터럴을 수정하려고 시도하면, 그 결과는 정의되지 않는다(Undefined Behavior). 
대부분의 현대 시스템에서는 프로그램이 강제 종료된다. 


**\[해결책 1\] 내 스케치북에 복사하기 (배열 사용)**

수정이 필요하다면 원본을 가리키는 게 아니라, 내 공간(배열)에 복사해와야 한다. `char s[] = "Hello";` 처럼 작성하면 "Hello"를 내 메모리(배열에 있는 상자들)로 한 글자씩 복사해오기 때문에 `s[0] = 'h';` 처럼 마음대로 수정할 수 있다.

```c
char s[] = "Hello"; /* "Hello"를 내 메모리(Stack)로 한 글자씩 복사해옴 */
s[0] = 'h';         /* [OK] 내 메모리니까 마음대로 수정 가능 ('H' -> 'h') */
```

**\[해결책 2\] `const`로 사고 예방하기 (추천)**

포인터를 선언할 때, `*`보다 앞에 `const`라고 써주면, 포인터를 읽기 전용으로 만들 수 있다. `const char *p = "Hello";`라고 선언하면, `p`가 읽기 전용으로 선언되어서, 실수로 내용물을 수정하려고 할 때 컴파일러가 미리 발견해서 에러를 내는 방식으로 알려준다. 

```c
const char *p = "Hello"; // "나는 이 문자열을 읽기만 하겠다"는 선언
p[0] = 'h';              // 컴파일 에러! (컴파일러가 미리 막아줌)
p = "World";             // [OK] 화살표 방향을 바꾸는 건 가능하다.
```

## 12.8 문자열 처리 3대 기본 함수: 길이 / 복사 / 비교

이제 문자열을 제대로 다루려면, 문자열 전용 기본 도구가 필요하다.

1. **길이**: `"Hello"`는 몇 글자인가?
2. **복사**: 다른 배열로 옮겨 담기
3. **비교**: 두 문자열이 같은가?

표준 라이브러리 `<string.h>`에는 이미 도구가 많지만(예: `strlen`, `strcpy`, `strcmp`), 여기서는 원리를 잡기 위해 직접 만들어 본다.

> [!NOTE]
> **const의 의미**
> 아래 함수 설명에서 `const`가 보이면 **이 매개변수는 읽기만 하겠다(수정하지 않겠다)**라는 약속으로 이해하자.

### 12.8.1 문자열 길이: `str_len`

반환값은 null 문자(`'\0'`)를 제외한 순수 글자 수다.
문자열은 끝 표시가 배열 안에 들어 있으므로, 길이를 알기 위해서는 **null 문자가 나올 때까지 끝까지 훑는** 비용이 든다.

비어있는 반복문을 사용하여 인덱스 `i`를 `\0`을 만날 때까지 증가시키는 패턴이 사용된다.

```c
/*
 * str_len는 문자열 길이를 구하는 함수다. 
 *
 * 매개변수: s. 읽기 전용 문자 배열. 글자 수를 셀 문자열이 들어있다. '\0'으로 끝나게 저장되어 있어야 한다.
 * 반환값: '\0'을 제외한 글자 수
 */
int str_len(const char s[])
{
    int i;

    for (i = 0; s[i] != '\0'; i = i + 1) {
        /* empty */
    }

    return i;
}
```

### 12.8.2 문자열 복사: 안전이 최우선이다

8장에서 배열은 `b = a;`로 통째로 복사할 수 없고, 한 칸씩 옮겨야 한다고 했다. 문자열도 결국 `char` 배열이므로 똑같다.

그런데 문자열 복사는 더 까다롭다.
1. 끝의 `'\0'`도 함께 복사해야 한다.
2. 목적지 배열 크기를 넘기면 메모리 사고(범위 초과)가 난다.

그래서 우리는 안전한, **목적지 그릇의 크기(`dst_size`)를 아는 함수**를 설계해야 한다.

```c
/*
 * str_copy는 문자열을 복사하는 함수다. 
 *
 * 매개 변수:
 * - dst: 복사한 문자열을 저장할 배열. dst_size가 1 이상이면 dst는 반드시 '\0'로 끝나게 만든다.
 * - dst_size: dst 배열의 크기
 * - src: 복사할 문자열
 *
 * 반환값: 복사한 문자 개수
 */
int str_copy(char dst[], int dst_size, const char src[])
{
    int i;

    if (dst_size <= 0) {
        return 0;
    }

    /* 마지막 한 칸(-1)은 null 문자를 위해 남겨둔다 */
    for (i = 0; i < dst_size - 1; i = i + 1) {
        dst[i] = src[i];

        if (src[i] == '\0') {
            /* 도중에 문자열이 끝났다면 복사 완료 */
            return i; 
        }
    }

    /* 여기까지 왔다는 건, 공간이 부족해서 잘렸다는 뜻 */
    dst[dst_size - 1] = '\0'; /* 강제로 끝을 맺음 */
    return dst_size - 1;
}
```

**[핵심 로직] 마지막 한 칸의 미학**
우리는 `dst_size - 1`까지만 복사한다. 왜일까?
그릇에 꽉 채워서 글자를 넣으면 `'\0'`이 들어갈 자리가 없어진다. 그래서 **무조건 한 칸은 남겨서 `\0`을 넣어준다**는 철칙을 지키는 것이다.

### 12.8.3 문자열 비교: `str_cmp`

문자열 비교도 결국 한 칸씩 비교하는 것이다.

* **다르면**: 그 자리에서 결론을 낸다. 누가 더 앞서는 글자인지 판단하기 위해 두 문자의 차이(`a[i] - b[i]`)를 반환한다.
* **같으면**: 다음 칸으로 넘어간다.
* **끝까지 같고 동시에 `\0`에 도달하면**: 0을 반환한다(같다).

```c
/*
 * str_cmp는 두 문자열을 앞에서부터 비교한 결과를 반환하는 함수다.
 * (주의: 표준 ASCII 문자 0~127 범위에서만 올바르게 작동한다.)
 *
 * 매개변수:
 * - a: 비교할 첫번째 문자열
 * - b: 비교할 두번째 문자열
 *
 * - 반환값: a와 b가 같으면 0, i번째 글자가 처음으로 다르면, a[i] - b[i]
 */
int str_cmp(const char a[], const char b[])
{
    int i;

    for (i = 0; ; i = i + 1) {
        if (a[i] != b[i]) {
            /* 다르면 차이를 반환 (사전식 순서) */
            return a[i] - b[i];
        }

        if (a[i] == '\0') {
            /* 여기까지 왔으면 둘 다 동시에 끝났다는 뜻. a[i]와 b[i]가 같고, 둘다 null 문자다. */
            return 0;
        }
    }
}
```

**[계산 원리]**
* `a[i] - b[i]`: 만약 `a`가 "ABC"고 `b`가 "ABD"라면, 'C'(67) - 'D'(68) = **-1**이 된다. 음수는 `a`가 `b`보다 사전에서 앞선다는 뜻이다.
* 반대로 양수가 나오면 `a`가 뒤에 있다는 뜻이다.

> [!NOTE]
> **나중에 배울 이야기 (확장 문자)**
> 위 논리는 영문자나 숫자 같은 표준 ASCII에서는 잘 작동한다. 하지만 나중에 **`unsigned` (부호 없는 자료형)**를 배우게 되면, 한글이나 특수문자 같은 "확장 문자"를 비교할 때 코드를 살짝 고쳐야 한다는 것을 알게 될 것이다. 지금은 "기본 원리"에만 집중하자.


## 12.9 포인터로 문자열 걷기: 인덱스 말고 “직접” 이동하기

11장(포인터)에서 **포인터 산술(`p + 1`)** 을 배웠다. 이것은 단순한 덧셈이 아니라 **다음 칸으로 이동**을 의미했다.
문자열도 결국 `char`들이 모인 배열이므로, 인덱스(`[i]`)를 쓰지 않고 포인터만으로 끝까지 갈 수 있다.

**[방식 비교]**
* **인덱스 방식 (`s[i]`):** `s`는 가만히 있고, 숫자 `i`가 0, 1, 2...로 변하며 “몇 번째 칸”을 가리킨다.
* **포인터 방식 (`*p`):** 포인터 `p`가 직접 메모리 위를 한 칸씩 걸어간다.

### 12.9.1 포인터로 길이 재기 (기본형)

이 방식은 `p`를 `s`의 시작 주소로 초기화한 뒤, `*p`가 널 문자(`\0`)가 될 때까지 `p`를 한 칸씩 증가시키는 방식이다.

```c
int str_len_ptr(const char *s)
{
    const char *p = s; /* p는 s의 시작 위치에서 출발한다 */
    int n = 0;
    /* *p가 널 문자('\0')가 될 때까지 p를 한 칸씩 전진시킨다 */
    for ( ; *p != '\0'; p = p + 1) {
        n = n + 1;
    }
    return n;
}
```

### 12.9.2 더 C언어다운 방법: 주소 뺄셈

위 방식에서 개수를 세는 변수(`n`)는 사실 필요 없다. 포인터의 강력한 기능인 **주소 뺄셈**을 쓰면 된다.

**도착한 주소(`p`) - 출발한 주소(`s`) = 지나온 칸의 개수**

```c
int str_len_advanced(const char *s)
{
    const char *p = s; /* p에 시작 주소 저장(출발점 기억) */

    while (*p != '\0') {
        p = p + 1; /* p는 계속 앞으로 간다 */
    }

    /* (끝 위치) - (시작 위치) = 글자 수 */
    return p - s;
}
```

이 패턴은 C언어 라이브러리 내부 코드에서 정말 많이 보게 될 패턴이다.

**왜 이 방식이 중요한가?**
다음 장에서 배울 **동적 메모리 할당(`malloc`)** 은 배열의 이름이 아니라 **주소(포인터)** 를 던져준다. 그때 메모리를 자유자재로 다루려면 주소를 직접 더하고 빼는 감각이 필수적이다.

## 12.10 작은 실전 예제: "숫자 문자열"을 int로 바꾸기

문자열 `"1234"`는 숫자처럼 보이지만 실제로는 문자들의 배열이다.

| 인덱스 | 0 | 1 | 2 | 3 | 4 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| **값** | `'1'` | `'2'` | `'3'` | `'4'` | `'\0'` |

우리가 원하는 건 이것을 정수 `1234`로 만드는 것이다.
여기에는 두 가지 중요한 수학적 트릭이 필요하다.

**1. 글자를 숫자로 변환하기 (`c - '0'`)**

컴퓨터에서 `'1'`은 정수 1이 아니다. (ASCII 코드값으로 보통 49다.)
진짜 숫자 1을 얻으려면 **기준점인 `'0'`(48)을 빼줘야 한다.**

* `'1' - '0'`  =>  `49 - 48`  =>  `1`
* `'9' - '0'`  =>  `57 - 48`  =>  `9`

> [!NOTE]
>
> C 언어에서는, 문자 `'0'`, `'1'`, ... , `'9'`의 코드 값이 반드시 연속적이어야 함을 보장한다.
> - `'1'`의 값은 `'0' + 1`과 같아야하고, `'2'`의 값은 `'1' + 1`과 같아야 한다.
> 그렇기때문에, `c - '0'`과 같은 연산을 통해 문자 `'0'` ~ `'9'`를 정수 `0`~`9`로 안전하게 변환할 수 있다.
>
> 주의: 알파벳(`'A'`~`'Z'`, `'a'`~`'z'`)에 대해서는 이런 연속성을 보장하지 않는다. (EBCDIC 같은 방식에서는 알파벳 중간에 크게 코드값을 건너뛰기 때문이다.)

**2. 자릿수 올리기 (`n * 10`)**

글자를 하나씩 읽을 때마다, 기존에 읽은 숫자에 10을 곱해서 자릿수를 "왼쪽으로 밀어"줘야 한다.

**\[알고리즘 추적: "123" 변환 과정\]**

1. 초기값 `n = 0`
2. **`'1'` 읽음:** `0 * 10 + 1` = **1**
3. **`'2'` 읽음:** `1 * 10 + 2` = **12** (1이 10의 자리로 밀려남)
4. **`'3'` 읽음:** `12 * 10 + 3` = **123** (12가 120으로 밀려남)

**\[구현 로직\]**

우리가 만들 함수 `parse_uint`는 다음과 같은 규칙을 가진다.
* `s`가 "1234" 같은 형태(숫자만 있는 문자열)면 그 값을 `int`로 만들어서 `*out`에 저장한다.
* **반환값:**
    * `0`: 성공
    * `-1`: 숫자가 아닌 문자가 섞여 있음
    * `-2`: 빈 문자열 ("")

**\[코드 구현\]**
```c
/*
 * parse_uint: 문자열을 부호 없는 정수로 변환하는 함수
 *
 * 매개변수:
 * - s: 정수로 변환할 문자열
 * - out: 변환된 정수를 저장할 주소
 *
 * 반환값: 0(성공), -1(비숫자 포함), -2(빈 문자열)
 */
int parse_uint(const char s[], int *out)
{
    int i;
    int n = 0;

    /* 1. 빈 문자열 검사 */
    if (s[0] == '\0') {
        return -2;
    }

    /* 문자의 모든 문자에 대해 앞에서부터 반복 시작 */
    for (i = 0; s[i] != '\0'; i = i + 1) {

        /* 2. 숫자가 아닌 문자 검사 */
        if (s[i] < '0') { return -1; }
        if (s[i] > '9') { return -1; }

        /* 3. 자릿수 누적 (핵심 로직) */
        /* 기존 값에 10을 곱해 자리를 만들고, 일의 자리에 새 숫자를 더한다 */
        n = n * 10 + (s[i] - '0');
    }

    *out = n; /* 결과 저장 */

    return 0;
}
```


> [!WARNING]
> **오버플로우 주의**
> 이 함수는 `int` 범위를 넘어서는 거대한 숫자(예: "9999999999")가 들어오면 엉뚱한 값(음수 등)이 될 수 있다. 실제 상용 프로그램에서는 `strtol` 같은 표준 함수를 사용하여 이런 에러까지 처리한다. 지금은 "변환 원리"에만 집중하자.


## 12.11 문자열에서 자주 터지는 사고 5가지

문자열은 **포인터 + 배열 + 메모리 + `'\0'`의 약속**이 한꺼번에 얽혀 있는 복잡한 구조다. 그래서 C언어 버그의 절반은 여기서 나온다. 가장 흔한 사고 5가지와 예방법을 정리했다.

### 1. '좀비' 문자열: `'\0'`를 빼먹는다

* **증상:** 문자열을 처리하는 함수가 멈추지 않고 외계어를 계속 처리하다가 에러가 발생한다.
* **원인:** 끝 표시(`'\0'`)가 없어서, 컴퓨터가 메모리 끝까지 계속 읽어버림.
* **\[해결책\]** 수동으로 배열을 채울 땐 항상 **마지막엔 `'\0'`**을 잊지 말자.

### 2. '꽉 낀 바지' 문제: 공간 부족

* **증상:** "Hello"를 넣으려고 5칸짜리 배열을 만든다.
* **원인:** `'\0'`이 들어갈 자리가 없다. (결국 1번 사고로 이어진다.)
* **[해결책]** **글자 수 + 1**. 항상 널 문자를 위한 VIP석을 남겨둬라.

### 3. 버퍼 오버플로우: 남의 땅 침범하기

* **증상:** 어떤 함수를 써서 문자열을 복사했는데, 전혀 상관없는 변수 값이 갑자기 바뀐다.
* **원인:** 배열 크기를 검사하지 않는 함수를 주의하라. 물(데이터)이 넘쳐서 옆 테이블(다른 변수)을 적신다.
* **[해결책]** `dst_size`를 확인하는 복사 함수(우리가 만든 `str_copy` 등)를 쓴다.

### 4. 박물관 전시품 만지기: 리터럴 수정

* **증상:** 포인터로 가리킨 문자열 리터럴을 수정하려고 하면 에러가 발생한다.
* **원인:** 문자열 리터럴은 읽기 전용 구역에 산다.
* **\[해결책\]** 수정이 필요하면 배열(`char s[]`)에 복사해서 써라. 포인터에는 `const`를 붙여라.

### 5. 신분 세탁: `sizeof`의 배신

* **증상:** 함수 안에서 `sizeof(s)`를 했더니 배열 크기가 아니라 주소 크기가 나온다.
* **원인:** 배열이 함수로 넘어갈 때 **포인터(주소)로 신분이 하락(Decay)**하기 때문이다. 메인 함수에서는 전체 크기를 주지만, 함수 내부에서는 포인터 크기만 준다.
* **\[해결책\]** 함수에 배열을 넘길 때는 **크기 정보도 같이 넘겨야 한다.**

