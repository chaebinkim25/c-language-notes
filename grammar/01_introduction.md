# 1장. C89와 표준화의 의미

## 1.1 왜 C 언어에 표준이 필요했는가

C 언어는 1970년대 초반, UNIX 운영체제 개발을 목적으로 등장한 언어이다. 당시에는 커니핸(Kernighan)과 리치(Ritchie)가 저술한 명서, The C Programming Language 초판(일명 K&R C)이 사실상의 기준 역할을 했다.

하지만 K&R C는 엄밀한 규칙이라기보다는 가이드라인에 가까웠다. 초기 C는 같은 C 소스 코드라도 실행 환경에 따라 다르게 동작하는 경우가 빈번했다.

'표준의 부재'는 개발자들에게 다음과 같은 치명적인 문제를 안겨주었다.

- 이식성의 결여: 하드웨어가 바뀔 때마다 코드를 전면 수정해야 했다.

- 컴파일러 간의 파편화: 벤더마다 독자적인 문법 확장이나 상이한 해석을 적용했다.

- 라이브러리의 동작 불일치: 라이브러리로 제공되는 같은 이름의 함수라도 시스템마다 반환 값이나 에러 처리 규칙 등이 달랐다.

- 정체성의 모호함: "도대체 어디까지가 C이고, 어디서부터가 비표준인가?"라는 질문에 명확히 답할 기준이 없었다.

결국 C 언어가 범용적인 시스템 언어로 자리 잡기 위해서는 “무엇이 C인가”를 공식적으로 정의하는 문서가 절실해졌다.

---

## 1.2 ANSI C89의 등장

이 혼란을 잠재우기 위해 1983년, 미국 국가표준 협회(ANSI)는 X3J11 위원회를 소집하여 언어의 표준화 작업에 착수했다. 그리고 장장 6년의 치열한 논의 끝에 1989년, 마침내 C 언어의 첫 번째 공식 표준인 ANSI X3.159-1989, 일명 'C89'가 세상에 나오게 된다.

C89 표준 위원회는 다음과 같은 핵심 목표를 가지고 작업을 수행했다.

- C 언어 문법의 엄밀한 정의

- 프로그램 실행 의미의 일관된 규정

- 상이한 컴파일러 및 하드웨어 환경 간의 동작 차이 최소화

- 기존 C 코드에 대한 하위 호환성(Backward Compatibility) 유지

이 표준은 그 완성도를 인정받아 이듬해인 1990년, 국제 표준화 기구(ISO)에 의해 국제 표준으로 채택되었으며(ISO/IEC 9899:1990), 이를 C90이라 부른다.

C89는 미국 표준 명칭, C90은 국제 표준 명칭일 뿐, 문서의 서식 차이를 제외하면 기술적으로는 완전히 동일한 표준이며, 일반적인 프로그래밍 관점에서는 두 용어를 구분 없이 사용하기도 한다.

---

## 1.3 C89 표준 문서의 역할

C89 표준은 “C 언어로 프로그램을 어떻게 작성해야 하는가”를 친절하게 가르쳐주는 사용 설명서가 아니다. 오히려 컴파일러 개발자가 구현해야 할 기준이자, 언어 해석의 최종 권위를 가진 기술 명세서에 가깝다.

표준 문서는 구체적으로 다음과 같은 질문에 답을 제시한다.

- 특정 문법 구조가 유효한가?

- 이 식(Expression)의 계산 결과는 어떻게 결정되는가?

- 컴파일러가 반드시 준수해야 할 제약 사항은 무엇인가?

- 어떤 동작이 명확히 정의되어 있고, 어떤 동작이 정의되지 않았는가?

다른 말로 표현하면, 언어의 허용 범위와 동작의 한계를 엄격히 규정하는 법전과 같다.

---

## 1.4 C89의 핵심 철학

C89 표준은 단순히 문법을 나열한 것이 아니라, C의 영혼이라 불리는 확고한 설계 철학을 바탕으로 제정되었다. 이 철학은 오늘날까지도 C 언어의 정체성을 규정하는 핵심 원리다.

### 1️⃣ 프로그래머에 대한 신뢰와 효율

C89는 "프로그래머가 자신이 무엇을 하는지 정확히 알고 있다"고 가정한다. 따라서 언어 차원에서 과도한 안전장치를 두거나 복잡한 추상화를 제공하는 대신, 하드웨어 제어권을 프로그래머에게 온전히 위임한다.

- 명시적 제어: 메모리 관리와 포인터 연산을 통해 하드웨어를 직접 조작한다.
- 성능 우선: 실행중 검사를 생략하여 실행 속도를 높인다.
- 작고 단순한 언어: 복잡한 기능을 배제하여 컴파일러를 가볍게 유지한다.

### 2️⃣ 구현의 자유와 최적화

표준은 모든 세부 동작을 획일적으로 강제하지 않는다. 다양한 하드웨어에서 C 언어가 가장 효율적인 기계어로 번역될 수 있도록 하기 위해서다.

동작은 크게 네 가지로 분류된다.

- 정의된 동작 (Defined Behavior): 어떤 시스템에 대한 실행 파일을 만들던 언어 차원에서 동일한 결과를 보장
- 구현 정의 동작 (Implementation-defined Behavior): 시스템에 따라 효율적인 방식을 선택하는 것이 허용됨 (문서화 필수)
- 미지정 동작 (Unspecified Behavior): 같은 시스템에서도 결과가 다를 수 있음 (문서화되지 않음)
- 미정의 동작 (Undefined Behavior): 결과가 보장되지 않으며 프로그램이 즉시 종료되거나 오작동할 수 있음 (절대 금지)

### 3️⃣ 기존 관행의 표준화

C89의 목표는 새로운 언어를 발명하는 것이 아니라, 이미 널리 쓰이고 있던 C 언어를 기술하는 것이었다.

- 하위 호환성: 기존에 작성된 방대한 코드가 표준 컴파일러에서도 문제없이 작동해야 했다
- 관행의 수용: 현대적인 관점에서는 다소 투박하거나 위험해 보이는 기능이라도, 당시 널리 쓰이던 관행이라면 표준으로 포용했다

--- 

## 1.5 C89의 가치: 왜 여전히 C89인가?

비록 오늘날 C99, C11, C17, 그리고 최신 C23에 이르는 표준들이 등장했지만, C89는 여전히 대체 불가능한 위상을 차지하고 있다.

단순히 "가장 오래된 표준"이라서가 아니다. C89가 여전히 유효한, 그리고 반드시 학습해야 할 이유는 다음과 같다.

- 거대한 레거시의 지배력: UNIX 커널, 리눅스 커널, 초기 Windows, 금융 시스템 등, 현대 IT 인프라를 떠받치는 핵심 코드의 상당수가 C89를 기준으로 작성되었다.
- 극한의 이식성: 8비트 마이크로컨트롤러부터 슈퍼컴퓨터까지, 모든 C 컴파일러가 지원하는 유일한 최대공약수가 C89다.
- 임베디드 시스템의 표준: 최신 컴파일러를 지원하지 않는 저사양/특수 목적 하드웨어 환경에서는 C89가 여전히 현역 표준이다.
- 언어 원형의 이해: 이후 추가된 기능들이 왜 필요했는지, 혹은 왜 위험한지를 판단하려면 그 기준점인 C89를 명확히 알아야 한다.

C89를 학습한다는 것은 낡은 문법을 외우는 것이 아니다. 그것은 C 언어의 본질적인 사고방식을 체득하고, 현대 프로그래밍 언어가 지금의 모습으로 진화해 온 필연적인 이유를 이해하는 과정이다.

---

## 1.6 부록

#### "K&R C는 엄밀한 규칙이라기보다는 가이드라인에 가까웠다" 예시

초기 C에서는 `x = x - y`를 `x =- y`로 썼었다. 컴파일러 입장에서 이것은 `x = -y` (x에 -y를 대입한다)로 해석될 수 있었다. C89에서는 문법을 `-=`로 바꿔서 대입과 부호의 애매함을 없앴다. 

### "같은 C 소스 코드라도 실행 환경에 따라 다르게 동작하는 경우가 빈번했다." 예시

초기 C에서는 `printf`와 같은 입출력이나 메모리 할당이 UNIX 운영체제의 기능을 불러오는 것에 가까웠다. IBM 메인프레임과 같은 다른 운영체제에서 코드를 실행하려면 입출력 기능을 처음부터 다시 구현해야 했다. C89에서는 표준 라이브러리를 정해서 반드시 제공되어야 할 함수들을 언어 차원에서 제공하게 했다. 

또한 초기 C는 PDP-11 컴퓨터에 특화되어 실수 연산의 경우 무조건 `double`로 했지만, C89에서는 `float` 연산이 더 효율적인 컴퓨터를 위해서 `float` 연산도 가능하게 만들었다.

### "컴파일러 간의 파편화" 예시

임베디드/시스템 프로그래밍에서 "읽기 전용 데이터", "값이 바뀔 수 있는 데이터"를 명확히 표현하려는 요구가 컸지만, C89 이전에는 컴파일러마다 자체적으로 키워드를 도입해서 해결하고 있었다. C89에서는 이를 위해 `const`와 같은 표준 키워드를 도입했다.

반대로 16비트 환경에서 큰 메모리를 의미하는 `huge`와 같은 키워드는 표준 C 코드가 아닌 벤더 확장으로 분리했다. 

### "성능 우선: 실행중 검사를 생략하여 실행 속도를 높인다" 예시

배열에서 `arr[i]`라고 하면 단순히 `*(arr + i)`라는 포인터 산술 연산으로 기계어 변환된다. 장점으로는 추가적인 CPU 작업량이 없다는 것이며 수백만번 반복할 때 이 차이는 거대하다. 단점으로는 버퍼 오버플로우 취약점의 원인이 되며, 다른 중요한 값을 바꿀 수 있어서 해킹의 통로가 된다. 

### "작고 단순한 언어: 복잡한 기능을 배제하여 컴파일러를 가볍게 유지한다" 예시

C에는 언어 차원의 예외 처리 기능이 없다. 대신 함수는 보통 반환값/에러번호와 같은 단순한 규칙으로 오류를 전달한다. 장점은 언어를 구현하는 것이 가볍다는 것이고, 단점은 프로그래머가 체크를 잘 해야한다는 것이다.

### "정의된 동작 (Defined Behavior)" 예시

```c
int a = 10;
int b = 20;
int c = a + b; /* c == 30 */
```
int 표현 범위를 넘지 않는 한, 결과는 항상 동일하다.

### "구현 정의 동작 (Implementation-defined Behavior)" 예시

```c
#include <stdio.h>
int main(void){
    printf("%zu\n", sizeof(int));
}
```

어떤 시스템은 `int`가 2바이트, 어떤 시스템은 `int`가 4바이트일 수 있다. C를 구현할 때 우리 `int`는 몇 바이트인지 문서화해야 한다. 윈도우의 MSVC는 Microsoft Learn에서 int가 4바이트이지만, 이식 가능한 코드에서는 int 크기에 의존하면 안된다고 나와있다. Apple의 Clang의 경우, clang에서는 플랫폼을 따른다고 되어 있고, macOS / iOS ABI 문서에 int가 32비트로 규정되어 있다.

### "미지정 동작 (Unspecified Behavior)" 예시

```c
#include <stdio.h>
int main(void){
    int i = 0;
    printf("%d, %d\n", i++, i++);
}
```

함수에 전달되는 인자들이 어떤 순서로 계산될지는 정해져 있지 않다. 컴파일러에 따라서 왼쪽 `i++`가 먼저 실행될 수도 있고, 오른쪽 `i++`가 먼저 실행될 수도 있다. 

### "미정의 동작 (Undefined Behavior)" 예시

```c
#include <stdio.h>
int main(void){
    int a[3] = {1, 2, 3};
    a[3] = 10;
}
```

메모리 다른 영역을 덮어쓸 수 있고, 운 좋게 되는 것처럼 보이기도 한다. 하지만 표준적으로는 결과가 보장되지 않는다.
