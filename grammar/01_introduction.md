# 1장. 표준화된 C의 시작: C89의 등장과 의미

## 1.1 C 언어의 핵심 철학

C 언어는 C의 영혼이라 불리는 확고한 설계 철학을 바탕으로 제정되었다. 오늘날까지도 C 언어의 정체성을 규정하는 핵심 원리다.

**프로그래머를 믿어라**

C 언어는 프로그래머가 **자신이 무엇을 하는지 정확히 알고 있다**고 가정한다. 따라서 언어 차원에서 과도한 안전장치를 두거나 복잡한 추상화를 제공하는 대신, 컴퓨터 하드웨어의 제어권을 프로그래머에게 온전히 넘겨준다.

- **명시적 제어:** 메모리 관리(Memory Management)와 포인터 연산(Pointer Arithmetic)을 통해 하드웨어를 직접 조작한다.
- **성능 우선:** 실행 중(Rumtime)에 "이게 맞아?"라고 검사하는 과정을 생략하여 속도를 극대화한다.
- **작고 단순한 언어:** 복잡한 기능을 배제하고 언어를 가볍게 유지한다.

덕분에 C 언어는 성능이 낮은 소형 기계나 아주 오래된 컴퓨터에서도 쌩쌩 돌아갈 수 있다. 

> 비유하자면, 최신 자동차에서 무거운 자율주행 시스템과 안전 센서를 떼어낸 레이싱 카와 같다.
> 차체(언어)가 가벼워져서 속도는 아주 빠르지만, 운전(프로그래밍)을 잘못하면 가드레일을 들이받을 수도 있다.

**구현의 자유와 최적화**

C 언어는 모든 세부 동작을 획일적으로 강제하지 않는다. 다양한 하드웨어에서 C 언어가 가장 효율적인 기계어로 번역될 수 있도록 하기 위해서다.

표준 문서는 프로그램의 동작을 크게 네 가지로 분류하여 규정한다. (괄호 안의 영어 용어는 보안 분야에서 매우 자주 쓰이므로 꼭 익혀두자.)

1. **정의된 동작 (Defined Behavior)**
   - **의미:** 언어 표준이 정확한 결과를 보장하는 동작이다.
   - **특징:** 어떤 컴퓨터, 어떤 종류의 C 언어 번역기를 쓰더라도 항상 똑같은 결과가 나와야 한다.
   - **예:** `1 + 1`은 항상 `2`여야 한다. 

2. **구현 정의 동작 (Implementation-defined Behavior)**
   - **의미:** 하드웨어 특성에 맞춰서 C 언어 번역기를 구현한 사람이 알아서 정하도록 허용한 동작이다.
   - **책임:** 어떻게 정했는지 반드시 문서화해야 한다.
   - **예:** 하드웨어에서 가장 적절한 크기의 정수 타입인 `int` 타입의 크기가 2바이트인지 4바이트인지는 시스템(번역기)마다 다를 수 있다. 

3. **미지정 동작 (Unspecified Behavior)**
   - **의미:** 여러가지 올바른 방법 중 C 언어 번역기가 그때그때 가장 효율적인 것을 선택하도록 놓아둔 동작이다.
   - **책임:** 어떤 방식을 택했는지 문서화할 필요가 없으며, 상황에 따라 결과가 달라질 수 있다.
   - **예:** `a() + b()`에서 `a()`를 먼저 실행할 지 `b()`를 먼저 실행할지는 순서가 정해져 있지 않다.

4. **미정의 동작 (Undefined Behavior, UB)**
   - **의미:** 이건 절대 하면 안 된다고 규정한 금지된 동작이다.
   - **위험성:** 프로그래머가 이 규칙을 어기면, 표준은 아무것도 보장하지 않는다. 표준이 보호를 포기한 상태의 코드라고 할 수 있다. 프로그램이 단순히 멈추는 것을 넘어, 메모리에 저장된 값이 변경되거나 해커가 의도한 악성 코드가 실행될 수도 있다.
   - **예:** 허가받지 않은 메모리에 대한 접근 (Buffer Overflow 등)

**기존 관행의 표준화**

C 언어의 표준화 작업을 할 때 목표는 새로운 언어를 발명하는 것이 아니라, 이미 널리 쓰이고 있던 C 언어를 있는 그대로 기록하는 것이었다.

- **호환성 (Backward Compatibility):** 가장 중요한 원칙은 이미 작성된 코드를 깨뜨리지 않는다는 것이었다. 기존에 있된 방대한 양의 C 코드가 표준화 작업 이후의 새로운 C 번역기에서도 문제없이 작동해야 했다.
- **위험한 관행의 수용:** 현대적인 보안 관점에서는 다소 투박하거나 위험해 보이는 기능이라도, 당시 개발자들이 널리 쓰고 있었다면 표준으로 포용했다. (참고로, 그렇기 때문에 버퍼 오버플로우 취약점을 유발하는 `gets()` 같은 함수가 표준에 포함되었고, 이는 후대 보안 전문가들에게 큰 숙제를 남겼다.)

## 1.2 왜 C 언어에 표준이 필요했는가

C 언어는 1970년대 초반, UNIX 운영체제 개발을 목적으로 등장한 언어이다. 당시에는 커니핸과 리치가 저술한 명서, 「The C Programming Language」초판(일명 K&R)이 사실상의 법전 역할을 했다.

하지만 이 책은 엄밀한 법이라기보다는 가이드라인에 가까웠다. 초기 C는 같은 C 소스 코드라도 실행 환경에 따라 다르게 동작하는 경우가 빈번했다.

표준의 부재는 개발자들에게 다음과 같은 치명적인 문제를 안겨주었다.

- **이식성의 결여:** 한 번 작성하면 어디서든 실행된다는 꿈은 불가능했다. 하드웨어가 바뀔 때마다 코드를 전면 수정해야 했다.

- **번역기 간의 파편화:** C 언어 제작사(Microsoft, IBM 등)마다 독자적인 문법을 추가하거나, 같은 코드를 서로 다르게 해석했다. 마치 지역마다 사투리가 심해서 대화를 할 수 없는 것과 같았다.

- **라이브러리의 동작 불일치:** C 언어 차원에서 기본으로 제공되는 도구(함수)들조차 시스템마다 반환 값이나 에러 처리 규칙이 제각각이었다.

- **정체성의 모호함:** "도대체 어디까지가 C이고, 어디서부터가 특정 회사의 비표준 기능인가?"라는 질문에 답할 기준이 없었다. 보안 관점에서 보면, 이러한 모호함은 프로그램의 오작동을 유발할 뿐만 아니라, 해커가 파고들 수 있는 보안 취약점의 원인이 되기도 했다.

결국 C 언어가 범용적인 시스템 언어로 자리 잡기 위해서는 무엇이 C인가를 공식적으로 정의하는 문서가 절실해졌다.

## 1.3 ANSI C89의 등장

이 혼란을 잠재우기 위해 1983년, 미국 국가표준 협회(ANSI)는 X3J11이라는 이름의 위원회를 소집하여 언어의 표준화 작업에 착수했다. 그리고 장장 6년의 치열한 논의 끝에 1989년, 마침내 C 언어의 첫 번째 공식 표준인 일명 C89가 세상에 나오게 된다.

C89 표준 위원회는 다음과 같은 핵심 목표를 가지고 작업을 수행했다.

- **C 언어 문법의 엄밀한 정의:** C 언어에서의 표준어를 확립했다. 

- **프로그램 실행 의미의 일관된 규정:** 코드가 실행될 때 어떤 일이 벌어져야 하는지를 명확히 했다.

- **상이한 번역기 및 하드웨어 환경 간의 차이 최소화:** 어디서든 최대한 비슷하게 동작하도록 만들었다.

- **기존 C 코드에 대한 호환성 유지:** 옛날 코드들을 최대한 끌어안았다.

그 결과 만들어진 표준의 완성도를 인정받아 이듬해인 1990년, 국제 표준화 기구(ISO)에 의해 국제 표준으로 채택되었으며, 이를 C90이라 부른다.

> [!NOTE]
> C89는 미국 표준 명칭, C90은 국제 표준 명칭일 뿐이다.
> 문서의 서식 차이를 제외하면 기술적으로는 완전히 동일한 표준이며, 현업에서는 두 용어를 구분 없이 사용하기도 한다.

## 1.4 C89 표준 문서의 역할

C89 표준 문서는 C 언어로 프로그램을 어떻게 짜야 하는가를 친절하게 알려주는 입문서나 사용 설명서가 아니다. 
오히려 C 언어 번역기를 만드는 개발자들이 반드시 지켜야 할, 최종 권위를 가진 기술 명세서에 가깝다.

표준 문서는 구체적으로 다음과 같은 질문에 답을 제시한다.

- **문법의 유효성:** "이 코드가 C 언어 문법에 맞는 올바른 문장인가?"

- **연산의 의미:** "복잡한 수식이 있을 때, 컴퓨터는 어떤 순서로 계산해야 하는가?"

- **번역기의 제약:** "C 언어 번역기라면 최소한 이 정도 기능은 반드시 제공해야 한다."

- **동작의 경계:** "어디까지가 안전한 동작이고, 어디서부터가 위험한(정의되지 않은) 동작인가?"

다른 말로 표현하면, 언어의 허용 범위와 동작의 한계를 엄격히 규정하는 C 언어의 헌법과도 같다.

보안 관점에서 보면, 해커들은 이 헌법의 틈새인 표준이 정의하지 않았다고(Undefined) 남겨둔 회색 지대를 집요하게 파고들어 공격 코드를 심는다.
따라서 보안 전문가는 표준을 단순한 규칙이 아니라, 시스템의 방어선을 이해하는 지도로 활용해야 한다.

## 1.5 C89의 가치: 왜 여전히 C89인가?

비록 오늘날 C99, C11, C17, 그리고 최신 C23에 이르는 표준들이 등장했지만, C89는 여전히 대체 불가능한 위상을 차지하고 있다.

단순히 가장 오래된 표준이라서가 아니다. C89가 여전히 유효하며, 보안 전문가가 반드시 학습해야 할 이유는 다음과 같다.

- **거대한 레거시의 지배력:** UNIX 커널, 리눅스 커널, 초기 Windows, 금융 시스템 등, 현대 IT 인프라를 떠받치는 핵심 코드의 상당수가 C89를 기준으로 작성되었다. 보안 전문가로서 나중에 분석하게 될 수많은 오래된 코드들이 C89로 짜여 있다. 
- **극한의 이식성(Portability):** 8비트 마이크로컨트롤러부터 슈퍼컴퓨터까지, 모든 C 컴파일러가 지원하는 유일한 표준이 C89다.
- **임베디드와 IoT 보안의 표준:** 최신 번역기를 지원하지 않는 저사양 하드웨어나 보안 취약점이 많은 IoT(사물인터넷) 기기들은 여전히 가볍고 단순한 C89를 현역으로 사용한다.
- **언어 원형의 이해:** 이후 추가된 기능들이 왜 필요했는지, 삭제된 기능들이 왜 위험했는지를 판단하려면 그 기준점인 C89를 명확히 알아야 한다.

C89를 학습한다는 것은 낡은 문법을 외우는 것이 아니다. 그것은 C 언어의 본질적인 사고방식을 체득하고, 현대 프로그래밍 언어가 지금의 모습으로 진화해 온 필연적인 이유를 이해하는 과정이다.

## 1.6 부록: C89가 필요했던 결정적 순간들

1. **애매모호한 문법의 정리:** `=-` vs `-=`

   초기 C(K&R)에서는 오해를 부를 소지가 있는 문법이 있었다.

   - **과거:** `x = x - y`를 줄여서 쓸 때 `x =- y`라고 썼다.
   - **문제:** 번역기나 사람에 따라 이것을 `x = -y` (`x`에 `-y`를 대입한다)로 오해할 수 있었다.
   - **C89:** 연산자를 `-=`으로 바꾸어 대입과 부호의 애매함을 완전히 없앴다.

2. **실행 환경간의 차이 해결:** `printf`와 `float`

   초기 C 코드는 실행 환경에 따라 다르게 동작하거나 아예 실행되지 않는 경우가 빈번했다.

   - **입출력:** `printf` 같은 함수는 원래 UNIX 운영체제의 기능이었다. 따라서 IBM 메인프레임 같은 다른 환경에서는 개발자가 입출력 기능을 처음부터 다시 만들어야 했다. C89에서는 표준 라이브러리를 정해서 필수 함수들을 언어 차원에서 보장했다. 

   - **실수 연산:** 초기 C는 PDP-11 컴퓨터에 특화되어 실수 연산을 무조건 `double`로 처리했다. C89에서는 `float` 연산이 더 효율적인 컴퓨터 하드웨어를 위해서 `float` 연산도 가능하게 표준화했다.

3. **춘추전국시대의 통일:** `const`와 `huge`

   표준이 없던 시절, 각 제작사는 필요한 기능을 벤더 확장(사투리와 같은 방식)으로 해결했다.

   - **const의 도입:** 임베디드 프로그래밍에서 읽기 전용 데이터를 표현하려는 요구가 컸지만, 제작사마다 키워드가 달랐다. C89는 이를 `const`라는 표준 키워드로 통일했다.

   - **비표준의 분리:** 반대로 16비트 환경에서나 쓰이던 `huge`와 같은 특수 키워드는 표준 C에서 제외하고 벤더 확장으로 남겨두어, 표준의 순수성을 지켰다.

4. **성능우선주의와 보안의 트레이드오프:** 배열 인덱스

   C 언어는 실행 중 검사(Runtime Check)를 생략하여 속도를 높인다.

   - **원리:** 배열에서 `arr[i]`는 단순히 `*(arr + i)`라는 포인터 덧셈 연산으로 변환된다.
   - **장점:** 배열의 크기를 확인하는 추가 작업이 없으므로, 수백만 번 반복할 때 속도가 압도적으로 빠르다. 
   - **보안 위험(Buffer Overflow):** 프로그래머가 실수로 배열의 크기를 넘어서도(예: `arr[100]`) 컴퓨터는 경고 없이 메모리의 다른 중요한 값을 덮어써 버린다. 그래서 해킹의 주요 통로가 된다. 

5. **가벼운 엔진과 프로그래머의 책임:** 에러 처리

   C 언어는 최신 언어들(Python, Java 등)처럼 무거운 자동 에러 처리(예외 처리) 기능이 없다. 
   - **방식:** 함수는 보통 반환값(`-1`, `NULL` 등)이나 에러 번호(`errno`) 같은 단순한 규칙으로 문제가 생겼음을 알린다.
   - **장점:** 언어를 구현하는 번역기 구조가 매우 단순하고 가볍다.
   - **단점:** 프로그래머가 귀찮아서 반환값 체크를 안 하고 넘어가면, 프로그램은 불안정한 상태로 계속 실행되다가 결국 오작동하거나 보안 구멍을 노출하게 된다.

