# 4장. 데이터의 개념: 프로그램이 다루는 재료

지금까지 우리는 숲에 해당하는 프로그램 구조를 보고 나무에 해당하는 토큰을 봤다.

- **어디서 시작하는지:** `main` 함수라는 입구
- **어떻게 실행되는지:** 위에서 아래로 한 줄씩
- **어떻게 읽히는지:** 의미 있는 조각(토큰) 단위로

이것을 요리책에 비유하자면, 우리는 이제 막 조리법이 적힌 형식을 파악한 셈이다.
어디가 제목이고, 순서가 어떻게 되고, 어떤 종류의 낱말들이 있는지 알게 되었다. 

요리책에 조금은 익숙해졌으니, 다음으로 볼 것은 맛있는 요리를 하기 위한 첫 단추인 재료다. 

프로그램에게 재료란 바로 데이터(Data)라고 할 수 있다. 

재료(데이터)는 어떻게 구분하고, 어디에 담아서 보관해야 할까?

**재료의 종류 (타입)**

요리 재료에 고기, 채소, 양념이 있듯이 데이터에도 정수, 실수, 문자 같은 종류가 있다.

**재료를 담는 그릇 (변수)**

달걀은 깨지지 않게 달걀 판에 담아야 하고, 우유는 흐르지 않게 컵에 담아야 하듯이, 데이터도 그 종류에 맞는 그릇(변수)에 담아야 한다.

C 언어라는 주방에서 재료를 다루는 법을 본격적으로 배워보자.

## 4.1 프로그램은 데이터를 다룬다

프로그램이 하는 일을 아주 단순하게 요약하면 세 가지 단계로 나뉜다. 
약자로 IPO (input-process-output) 모델이라고 한다.

1. **입력 (input):** 재료를 준비한다. (키보드 입력, 파일 읽기, 메모리 읽기)
2. **처리 (process):** 요리한다. (계산, 판단, 가공)
3. **출력 (output):** 완성된 요리를 내놓는다. (화면 출력, 파일 저장, 메모리 저장)

어떤 복잡한 일을 하든, 모든 과정의 중심에는 항상 데이터가 있다. 아무리 화려하고 복잡한 코드라도, 결국은 데이터를 다루기 위해 존재할 뿐이다.

**데이터가 없다면?**

우리가 즐겨 하는 게임을 예로 들어보자.

* **내 캐릭터의 체력(HP):** 데이터 (정수)
* **아이템 이름:** 데이터 (문자열)
* **친구와의 채팅:** 데이터 (문자열)

만약 데이터가 없다면, 캐릭터는 존재할 수 없고 채팅도 불가능하다. 프로그램은 껍데기일 뿐이다.

**데이터의 흐름**

다음과 같은 간단한 덧셈 코드가 있다고 하자.

```c
1 + 2
```

이 코드를 실행하면 CPU는 내부 회로에서 복잡한 전기 신호를 주고받으며 계산을 수행한다. 하지만 프로그래머인 우리에게 중요한 건, 디지털 회로가 어떻게 연산을 했는가가 아니고, 3이라는 데이터를 결과값으로 얻었다는 것이다. 3이라는 결과 값은 다음 코드에서 처리해서 또 새로운 데이터를 만들어낸다. 

프로그래밍이란 필요한 데이터를 메모리라는 창고에 불러오고, 원하는 형태로 가공하고, 다시 저장하는 과정의 연속이라고 할 수 있다.

## 4.2 리터럴(literal): 코드에 직접 적혀있는 데이터: 

앞 장에서 우리는 이런 코드를 본 적이 있다.

```c
return 0;
```

여기서 `0`은 계산해서 나온 결과가 아니다. 프로그래머가 코드 안에 직접 적어 놓은 데이터다.

소스 코드에 직접 등장하는 값을 리터럴(Literal)이라고 부른다.

**왜 리터럴인가?**

Literal은 영어로 문자 그대로라는 뜻이다.
메모리에 저장되는 데이터는 상황에 따라 값이 10이 될 수도 있고 100이 될 수도 있지만, 리터럴 `0`은 말 그대로 언제나 0이다.

컴파일러는 리터럴을 만나면 "아, 이건 계산할 필요 없이 그냥 이 값이구나!" 하고 있는 그대로 받아들인다.

**리터럴의 종류**

C 언어에는 숫자뿐만 아니라 다양한 형태의 리터럴이 있다.

- **정수 리터럴:** `0`, `10`, `-5` (소수점이 없는 숫자)
- **실수 리터럴:** `3.14`, `-0.01` (소수점이 있는 숫자)
- **문자 리터럴:** `'A'`, `'z'`, `'\n'` (작은따옴표로 감싼 한 글자)
- **문자열 리터럴:** `"Hello"`, `"C Language"` (큰따옴표로 감싼 여러 글자)

**리터럴의 특징**

리터럴은 가공되지 않은 원재료와 같다.

- **계산 과정이 없다:** 프로그램을 실행하기 전부터 이미 값이 코드에 적혀 있다. 
- **변하지 않는다:** 프로그램이 실행되는 동안 `0`이 `1`로 변하는 일은 절대 없다. (불변성)

> [!NOTE]
> **리터럴 vs 수식**
>
> - `1 + 2`: 이것은 계산을 하는 수식이다. 결과는 3이 된다.
> - `1`, `2`: 이것들은 리터럴이다.
>
> 리터럴(`1`, `2`)은 수식(`1 + 2`)을 만드는데 쓸 수 있다.

## 4.3 데이터의 순환: 어디서 와서 어디로 가는가?

모든 데이터가 리터럴(`0`, `"Hello"`)처럼 코드에 적힌 상태로 존재하는 것은 아니다.
대부분의 데이터는 프로그램이 실행되는 동안 메모리 안에서 만들어지고, 저장되고, 쓰이고, 소멸되는 흐름을 가진다.

**생성: 데이터가 처음 만들어지는 순간**

데이터가 만들어질 때는,
- 리터럴 값을 복사하거나, 키보드나 파일에서 데이터를 읽어온다.
- 또는 `1 + 2` 처럼 계산을 통해 새로운 데이터 `3`을 만들어낸다.

프로그래밍에서는 이렇게 생성된 구체적인 데이터의 실체를 값(value)이라고 부른다. 
리터럴 `1`, `2`는 코드에 적혀 있는 값이고, `3`은 계산을 통해 만들어낸 값이다. 
모든 데이터는 결국 값으로 존재한다.

**저장: 메모리라는 창고**

생성된 값은 공중에 떠다닐 수 없다. 사라지지 않도록 메모리라는 창고에 안전하게 보관해야 한다.

만약 저장하지 않으면, `1 + 2`로 만든 `3`이라는 값은 다음 줄로 넘어가는 순간 증발해 버린다.

**사용: 저장된 값 불러오기**

창고(메모리)에 저장해 둔 값을 꺼내서 쓴다. 
- "아까 저장한 값이 5보다 큰가?" 하고 판단하거나,
- "아까 값에 10을 더해라" 처럼 또 다른 계산의 재료로 사용한다.

**소멸: 메모리 공간 반납하기**

자신이 속한 블록(`{ }`)이나 함수의 실행이 끝나면 데이터는 사라질 수 있다. 더 정확히는, 사용하던 상자를 반납한다.
메모리 공간은 한정되어 있기 때문에, 필요 없어진 데이터는 제때 치워야 새로운 데이터를 위한 자리가 생긴다.

C 언어는 이 과정(생성-저장-사용-소멸)을 명확하게 드러내서 프로그래머가 직접 다루도록 설계되어 있다.

## 4.4 연산 (operation): 값으로 계산을 한다는 것

"컴퓨터는 계산기니까 수학을 엄청 잘하겠지?"

반은 맞고 반은 틀린 말이다. 
컴퓨터가 수행하는 연산(Operation)은 우리가 배우는 수학처럼 복잡해 보이지 않는다.

컴퓨터의 연산은 더하기(`+`), 빼기(`-`), 대입하기(`=`) 처럼 아주 기초적인 동작들로 이루어져 있다.
하지만 프로그래밍의 위대함은 바로 이 단순함의 조합에 있다.

우리는 이 작은 연산 조각들을 레고 블록처럼 조립하고 연결해서, 복잡한 방정식을 풀거나 물리 현상을 시뮬레이션 하거나 화려한 3D 그래픽을 그려낸다.

**무엇을 계산하는가?**

컴퓨터에게 연산이란, 값을 재료로 삼아 새로운 값을 만들어내는 모든 행위를 말한다.

- **산술 연산 (수학):** 숫자를 더하거나 빼서 새로운 값을 만든다.

  `10 + 20`으로 `30`이라는 새로운 숫자 값을 만든다.

- **대입 연산 (저장):** 값을 저장한다.

  `age = 20`으로 `age`라는 상자에 `20`이라는 값을 저장한다.

> [!WARNING]
>
> **수학의 `=` vs C 언어의 `=`**
>
> 수학에서 $x = y$는 $x$와 $y$가 같다는 뜻이지만, C 언어에서 `=`는 오른쪽의 값을 왼쪽에 대입하라는 명령이다.
> 같다는 의미의 기호인 `==`은 나중에 배운다.

**연산자 (operator): 계산의 도구**

요리를 하려면 칼이나 불 같은 도구가 필요하듯, 데이터를 지지고 볶으려면 도구가 필요하다.
연산을 하게 해주는 기호들을 연산자(operator)라고 부른다.

- **`+`, `-`, `*`, `/`:** 더하고 빼는 도구
- **`=`:** 데이터를 상자에 담는 도구

**우선순위 (precedence): 계산의 순서**

수학에서 $1 + 2 \times 3$을 계산할 때 곱셈을 먼저 하듯, C 언어에도 순서가 있다.
컴퓨터에서는 정해진 우선 순위에 따라 연산자들을 하나씩 처리한다.

**수식 (expression)과 결과값**

수학에서처럼 연산자와 데이터가 뭉쳐서 하나의 결과값을 만들어내는 단위를 수식 (expression)이라고 부른다.
모든 식은 결국 하나의 값으로 변한다.

```c
1 + 2 * 3
```

컴퓨터 내부에서는 이 코드가 다음과 같이 계산된다. 

1. `2 * 3`을 먼저 계산해서 `6`으로 바꾼다. 남은 코드는 `1 + 6`이 된다.
2. `1 + 6`을 계산해서 `7`로 바꾼다. 남은 코드는 `7`이 된다.

결국 `1 + 2 * 3`이라는 긴 식은 `7`이라는 하나의 값이 된다. 

## 4.5 변수 (variable): 데이터를 저장한다는 것

앞서 4.3절에서 데이터는 저장되어야 한다고 했다.
데이터를 그냥 흘려보내지 않고, 필요할 때 다시 쓰려면 어딘가에 담아 두는 방법이 필요하다.

아직 C 언어 문법을 배우지 않았으므로, 개념적으로 상상해보자.
넓은 메모리 창고에서 내 데이터를 잃어버리지 않으려면 어떻게 해야 할까?

"상자에 담고 이름표를 붙이면 된다!"

프로그래밍에서는 데이터를 담기 위해 메모리 안에 특정 공간을 배정받는데, 이 공간을 변수(variable)이라고 부른다. 

비유하자면, 물건을 찾기 쉽게 상자를 가져와서 담고 이름표를 붙여 놓는 것과 같다. 

정리하면 다음과 같다.

- **변수:** 값을 담는 상자 (메모리 공간)
- **식별자:** 상자에 붙인 이름표 (변수 이름)
- **값:** 상자에 들어있는 내용물 (데이터)

## 4.6 타입 (type): 0과 1에 의미를 부여하는 안경

앞에서 우리는 값이 만들어지고, 계산되고, 저장된다는 흐름을 배웠다.

마지막으로 가장 중요한 질문을 던질 차례다.

"메모리에 저장된 값은 언제나 같은 의미일까?"

컴퓨터 메모리의 입장에서 보면, 모든 데이터는 그저 `0`과 `1`의 나열일 뿐이다. 
예를 들어 메모리에 `0100 0001`이라는 정보가 있다고 해보자. 

이것은 십진수 `65`일까? 아니면 알파벳 `'A'`일까?

정답은 어떤 관점으로 보느냐에 따라 다르다. 

**타입은 값을 해석하는 규칙이다**

C 언어에서 타입 (type)이란, 메모리에 담긴 `0`과 `1`을 어떻게 해석할지 결저하는 규칙이다. 

똑같은 `0100 0001`이라도,

- **정수 타입**이라는 안경을 쓰고 보면 숫자 `65`로 해석될 수 있고,
- **문자 타입**이라는 안경을 쓰고 보면 문자 `A`로 해석될 수 있다.

따라서 값은 타입을 통해 비로소 의미가 생긴다. 

**타입은 상자의 크기를 결정한다**

타입은 데이터의 의미뿐만 아니라 크기도 결정한다. 
앞서 변수를 상자에 비유했는데, 타입은 어떤 크기의 상자를 준비할 것인가를 알려주는 설계도 역할을 한다.

- **작은 숫자를 담으려면?** 작은 상자가 필요하다. (예: 1 바이트)
- **엄청 큰 숫자를 담으려면?** 큰 상자가 필요하다. (예: 4 바이트, 8 바이트)

타입을 정한다는 것은 컴파일러에게 "이 데이터를 저장하려면 메모리 몇 칸이 필요해!"라고 미리 알려주는 것과 같다.
