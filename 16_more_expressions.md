# 16. 흐름 제어의 완성: 조건을 조립하고 반복을 유연하게

우리는 6장에서 `if`문을 배우며 프로그램에 갈림길을 만들었다. 덕분에 무조건 직진만 하던 코드가 상황에 따라 다른 길을 선택할 수 있게 되었다. 
7장에서는 `for`문을 통해 "횟수가 보이는" 반복을 구현했다. 1부터 10까지 더하거나, 배열을 순회하는 일은 이제 익숙해졌다.

그런데 현실의 문제는 조금 더 복잡하다. 코드를 짜다 보면 다음 두 가지가 부족해 코드가 지저분해지는 순간이 온다.

1. **조건을 조립하는 도구의 부재**: "나이가 20세 이상이고(AND), (입장권을 가지고 있거나(OR), 초청장이 있어야 한다)" 같은 복합적인 조건을 `if`문 중첩으로만 짜려면 코드가 깊은 늪에 빠진다.

2. **언제 끝날지 모르는 반복**: 사용자가 '종료' 버튼을 누를 때까지, 혹은 파일의 끝에 닿을 때까지 반복해야 한다면, 횟수를 정해두는 `for`문은 어울리지 않는다.

또 하나의 문제가 있다. 분기가 10개, 20개가 넘어가면 `if-else if` 사다리는 너무 길어져서 읽기가 괴로워진다. 
그리고 조건식이나 반복문 안에서 `i++` 같은 코드를 무심코 섞어 썼다가, **부수 효과**라는 함정에 빠져 원인을 알 수 없는 버그를 만들기도 한다.

그동안 미뤄두었던 흐름 제어의 나머지 퍼즐 조각을 맞추는 시간이 왔다. 새로운 도구들을 익히면 여러분의 논리는 더 단단해지고, 코드는 더 안전해질 것이다.

## 16.0 목표

이 장을 끝내면 다음을 할 수 있게 된다.

- `&&`, `||`, `!`로 조건을 조립할 수 있다.
- 단락 평가(Short-circuit) 때문에 조건의 일부가 "실행되지 않을 수 있다"는 것을 이해한다.
- 횟수가 정해지지 않은 반복을 `while`과 `do`-`while`로 제어할 수 있다.
- `switch`로 여러 갈래 분기를 깔끔하게 정리하고, `break`와 fall-through를 활용할 수 있다.
- `++`, `--`, 대입(`=`) 같이 변수의 값을 바꾸는 부수 효과가 포함된 식을 안전하게 작성하는 습관을 기른다. 

## 16.1 조건을 조립하는 논리 연산자: `&&`, `||`, `!`

조건을 만들다 보면 "A도 옳아야 하고 B도 옳아야 한다", "A나 B나 다 안 된다", "A가 틀리거나 B가 틀리거나 둘 다 틀려야 한다" 같은 말을 코드로 옮겨야 한다.

C언어는 이를 위해 다음과 같은 논리 연산자들을 제공한다.

- `!`(NOT, 논리 부정): 참을 거짓으로, 거짓을 참으로 바꾼다.
- `&&`(AND, 논리 곱): 두 조건이 모두 참일 때만 참이 된다.
- `||`(OR, 논리 합): 두 조건 중 하나라도 참이면 참이 된다. 

### 16.1.1 복습 C의 쿨한 규칙: 0만 아니면 다 OK

6장에서 배운 핵심 규칙을 다시 확인해보자. C언어는 참과 거짓을 판단할 때 아주 관대하다. 딱 하나, 0만 거짓이고 나머지는 전부 참으로 쳐준다.
여기서 중요한 점은 음수도 0이 아니기 때문에 참이라는 사실이다. 

```c
int x = -5;
if (x) {
    /* 실행 된다! -5도 0이 아니니까 참이다. */
}
```

반면에, 비교 연산자(`>`, `<`)가 결과를 내놓을 때는 아주 엄격하다. 조건이 맞으면 무조건 1, 틀리면 무조건 0이다.

```c
10 > 3;   /* 비교 식의 결과값은 참에 해당하는 1이다. */
3 > 10;   /* 비교 식의 결과값은 거짓에 해당하는 0이다. */
```

### 16.1.2 `!` : 조건 뒤집기 (NOT)

`!` 연산자는 **참을 거짓으로, 거짓을 참으로** 바꾼다.

* `!0`은 `1` (거짓을 참으로)
* `!123`은 `0` (참을 거짓으로)

입력이 무엇이든 **결과는 무조건 0 또는 1**이 된다. 

한글 문장으로 비유하면 "~이 아니면"이고, 영어 문장으로 비유하면 "not ~"다. C 코드를 영어로 설명해보면, 자연스럽게 읽힌다.

```c
if (!found) {
    /* "찾지 못했다면(If not found)" */
}

if (!(x >= 0)) {
    /* 범위 안에 있지 않으면(If not in the range) */
}
```

> **[TIP] 괄호는 선택이 아니라 필수**
>
> `!`는 연산자 우선순위가 매우 높다(힘이 세다). 따라서 복잡한 조건을 뒤집을 때는 반드시 괄호로 감싸야 한다.
>
> * `!A && B` : A만 뒤집고 B와 AND 연산 (의도와 다를 수 있음)
> * `!(A && B)` : A와 B의 결과를 먼저 구하고 전체를 뒤집음 (안전함)

### 16.1.3 && : 둘 다 참 (AND)

`&&` 연산자는 **두 조건이 모두 참(True)일 때만** 결과가 1이 된다. 하나라도 거짓이면 결과는 가차 없이 0이다.

* 참 `&&` 참은 **1**
* 참 `&&` 거짓은 **0**
* 거짓 `&&` 거짓은 **0**

가장 대표적인 사용처는 **범위 검사**다.

```c
if (x >= 0 && x <= 9) {
    /* x가 0 이상이고, "그리고" 9 이하일 때 */
}

```
> **[주의] 수학식처럼 썼다간 큰일 난다**
>
> 초보 시절 가장 많이 하는 실수가 범위를 수학식처럼 한 줄에 쓰는 것이다.
>
>         /* (X) 문법 에러는 안 나지만, 논리 에러 발생 */
>         if (0 <= x <= 9) { ... }
>
> 이 코드가 위험한 이유는 **컴파일 에러가 뜨지 않고 실행되기 때문**이다. 컴퓨터는 이 식을 앞에서부터 순서대로 계산해버린다.
>
> 1.  `0 <= x`를 먼저 계산한다. 결과는 무조건 **0 또는 1**이다.
> 2.  그 결과(0 또는 1)를 가지고 다시 `9`와 비교한다. (`<= 9`)
> 3.  그런데 **0도 9보다 작고, 1도 9보다 작다.**
>
> 결국 x가 100이든 -50이든 이 조건식은 언제나 참이 되어 버린다. 따라서 C언어에서는 반드시 `&&`를 이용해 두 조건을 "접착제"로 붙여줘야 한다.

### 16.1.4 || : 하나라도 참이면 참 (OR)

`||` 연산자는 `&&`보다 훨씬 관대하다. 두 조건 중 어느 한쪽이라도 참이면 결과는 1(참)이 된다. 둘 다 거짓일 때만 0(거짓)이 된다.

* 참 `||` 거짓은 **1**
* 거짓 `||` 참은 **1**
* 거짓 `||` 거짓은 **0**

이 연산자는 주로 "~이거나(OR)"의 상황을 표현할 때 사용합니다.

**범위 밖을 검사할 때**
`&&`가 "0에서 100 사이"를 검사했다면, `||`는 그 반대인 "범위를 벗어난 비정상적인 값"을 잡아낼 때 유용하다.

```c
/* 0보다 작거나, 100보다 크면 (잘못된 점수) */
if (score < 0 || score > 100) {
    printf("점수가 올바르지 않습니다.\n");
}
```

**여러 선택지를 검사할 때**
사용자의 입력이 소문자 'q'일 수도 있고, 대문자 'Q'일 수도 있다. 둘 중 하나만 맞아도 종료해야 한다면 이렇게 쓴다.
```c
/* 'q'를 눌렀거나, 'Q'를 눌렀다면 */
if (input == 'q' || input == 'Q') {
    return 0; /* 종료 */
}
```

> [!NOTE]
> 컴퓨터는 게으르다 (단축 평가)
>
> C언어의 논리 연산에는 재미있는 특징이 있다. 컴퓨터는 **결과가 뻔하면 뒤쪽은 쳐다보지도 않는다.**
>
> * `A || B` 에서 **A가 참이면**, B는 검사하지 않고 바로 참으로 결론낸다. (어차피 결과는 참이니까)
> * `A && B` 에서 **A가 거짓이면**, B는 검사하지 않고 바로 거짓으로 결론낸다. (어차피 결과는 거짓이니까)
>
> 이를 단축 평가(Short-circuit evaluation)라고 한다. 효율적이지만, 두번째 수식이 실행되지 않을 수도 있으니 주의해야 한다.

### 16.1.5 우선순위와 괄호: "명확성"

논리 연산자 사이에도 힘의 우열(우선순위)이 존재한다.

1. `!` (가장 강함)
2. `&&` (논리 **곱**은 곱셈과 비슷)
3. `||` (논리 **합**은 덧셈과 비슷)

수학에서 덧셈보다 곱셈을 먼저 계산하듯, C언어도 `&&`를 `||`보다 먼저 처리한다. 하지만 이 순서를 억지로 외우려 애쓸 필요는 없다. 
가장 좋은 규칙은 `&&`와 `||`가 섞이면 무조건 괄호로 묶는 것이다.

예를 들어, 다음 코드를 보자.

```c
if (a && b || c) { ... }
```

컴퓨터는 우선순위 규칙에 따라 `(a && b)`를 먼저 하고 나중에 `c`를 본다. 하지만 코드를 읽는 사람(동료 개발자)은 "뭐가 먼저지?" 하고 멈칫하게 된다.

그래서 의도를 명확히 드러내기 위해 괄호를 쓴다.

```c
/* 의도: (a와 b가 참)이거나, 혹은 c가 참이면 */
if ((a && b) || c) { ... }

/* 의도: a는 무조건 참이고, (b나 c 중 하나)가 참이면 */
if (a && (b || c)) { ... }
```

괄호 몇 글자를 더 적는 수고가, 나중에 코드를 읽을 때 생길 오해를 완벽하게 막아준다.

