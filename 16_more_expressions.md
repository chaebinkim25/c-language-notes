# 16. 흐름 제어의 완성: 조건을 조립하고 반복을 유연하게

우리는 6장에서 `if`문을 배우며 프로그램에 갈림길을 만들었다. 덕분에 무조건 직진만 하던 코드가 상황에 따라 다른 길을 선택할 수 있게 되었다. 
7장에서는 `for`문을 통해 "횟수가 보이는" 반복을 구현했다. 1부터 10까지 더하거나, 배열을 순회하는 일은 이제 익숙해졌다.

그런데 현실의 문제는 조금 더 복잡하다. 코드를 짜다 보면 다음 두 가지가 부족해 코드가 지저분해지는 순간이 온다.

1. **조건을 조립하는 도구의 부재**: "나이가 20세 이상이고(AND), (입장권을 가지고 있거나(OR), 초청장이 있어야 한다)" 같은 복합적인 조건을 `if`문 중첩으로만 짜려면 코드가 깊은 늪에 빠진다.

2. **언제 끝날지 모르는 반복**: 사용자가 '종료' 버튼을 누를 때까지, 혹은 파일의 끝에 닿을 때까지 반복해야 한다면, 횟수를 정해두는 `for`문은 어울리지 않는다.

또 하나의 문제가 있다. 분기가 10개, 20개가 넘어가면 `if-else if` 사다리는 너무 길어져서 읽기가 괴로워진다. 
그리고 조건식이나 반복문 안에서 `i++` 같은 코드를 무심코 섞어 썼다가, **부수 효과**라는 함정에 빠져 원인을 알 수 없는 버그를 만들기도 한다.

그동안 미뤄두었던 흐름 제어의 나머지 퍼즐 조각을 맞추는 시간이 왔다. 새로운 도구들을 익히면 여러분의 논리는 더 단단해지고, 코드는 더 안전해질 것이다.

## 16.0 목표

이 장을 끝내면 다음을 할 수 있게 된다.

- `&&`, `||`, `!`로 조건을 조립할 수 있다.
- 단락 평가(Short-circuit) 때문에 조건의 일부가 "실행되지 않을 수 있다"는 것을 이해한다.
- 횟수가 정해지지 않은 반복을 `while`과 `do`-`while`로 제어할 수 있다.
- `switch`로 여러 갈래 분기를 깔끔하게 정리하고, `break`와 fall-through를 활용할 수 있다.
- `++`, `--`, 대입(`=`) 같이 변수의 값을 바꾸는 부수 효과가 포함된 식을 안전하게 작성하는 습관을 기른다. 

## 16.1 조건을 조립하는 논리 연산자: `&&`, `||`, `!`

조건을 만들다 보면 "A도 옳아야 하고 B도 옳아야 한다", "A나 B나 다 안 된다", "A가 틀리거나 B가 틀리거나 둘 다 틀려야 한다" 같은 말을 코드로 옮겨야 한다.

C언어는 이를 위해 다음과 같은 논리 연산자들을 제공한다.

- `!`(NOT, 논리 부정): 참을 거짓으로, 거짓을 참으로 바꾼다.
- `&&`(AND, 논리 곱): 두 조건이 모두 참일 때만 참이 된다.
- `||`(OR, 논리 합): 두 조건 중 하나라도 참이면 참이 된다. 

### 16.1.1 복습 C의 쿨한 규칙: 0만 아니면 다 OK

6장에서 배운 핵심 규칙을 다시 확인해보자. C언어는 참과 거짓을 판단할 때 아주 관대하다. 딱 하나, 0만 거짓이고 나머지는 전부 참으로 쳐준다.
여기서 중요한 점은 음수도 0이 아니기 때문에 참이라는 사실이다. 

```c
int x = -5;
if (x) {
    /* 실행 된다! -5도 0이 아니니까 참이다. */
}
```

반면에, 비교 연산자(`>`, `<`)가 결과를 내놓을 때는 아주 엄격하다. 조건이 맞으면 무조건 1, 틀리면 무조건 0이다.

```c
10 > 3;   /* 비교 식의 결과값은 참에 해당하는 1이다. */
3 > 10;   /* 비교 식의 결과값은 거짓에 해당하는 0이다. */
```

### 16.1.2 `!` : 조건 뒤집기 (NOT)

`!` 연산자는 **참을 거짓으로, 거짓을 참으로** 바꾼다.

* `!0`은 `1` (거짓을 참으로)
* `!123`은 `0` (참을 거짓으로)

입력이 무엇이든 **결과는 무조건 0 또는 1**이 된다. 

한글 문장으로 비유하면 "~이 아니면"이고, 영어 문장으로 비유하면 "not ~"다. C 코드를 영어로 설명해보면, 자연스럽게 읽힌다.

```c
if (!found) {
    /* "찾지 못했다면(If not found)" */
}
```

> **[TIP] 괄호는 선택이 아니라 필수**
>
> `!`는 연산자 우선순위가 매우 높다(힘이 세다). 따라서 복잡한 조건을 뒤집을 때는 반드시 괄호로 감싸야 한다.
>
> * `!A && B` : A만 뒤집고 B와 AND 연산 (의도와 다를 수 있음)
> * `!(A && B)` : A와 B의 결과를 먼저 구하고 전체를 뒤집음 (안전함)

### 16.1.3 `&&` : 둘 다 참 (AND)

`&&` 연산자는 **두 조건이 모두 참(True)일 때만** 결과가 1이 된다. 하나라도 거짓이면 결과는 가차 없이 0이다.

* 참 `&&` 참은 **1**
* 참 `&&` 거짓은 **0**
* 거짓 `&&` 거짓은 **0**

가장 대표적인 사용처는 **범위 검사**다.

```c
if (x >= 0 && x <= 9) {
    /* x가 0 이상이고, "그리고" 9 이하일 때 */
}

```
> **[주의] 수학식처럼 썼다간 큰일 난다**
>
> 초보 시절 가장 많이 하는 실수가 범위를 수학식처럼 한 줄에 쓰는 것이다.
>
>         /* (X) 문법 에러는 안 나지만, 논리 에러 발생 */
>         if (0 <= x <= 9) { ... }
>
> 이 코드가 위험한 이유는 **컴파일 에러가 뜨지 않고 실행되기 때문**이다. 컴퓨터는 이 식을 앞에서부터 순서대로 계산해버린다.
>
> 1.  `0 <= x`를 먼저 계산한다. 결과는 무조건 **0 또는 1**이다.
> 2.  그 결과(0 또는 1)를 가지고 다시 `9`와 비교한다. (`<= 9`)
> 3.  그런데 **0도 9보다 작고, 1도 9보다 작다.**
>
> 결국 x가 100이든 -50이든 이 조건식은 언제나 참이 되어 버린다. 따라서 C언어에서는 반드시 `&&`를 이용해 두 조건을 "접착제"로 붙여줘야 한다.

### 16.1.4 `&&`로 중첩 `if`문을 한줄로

### 16.1.4 (실전) 6장의 그 코드, 이제는 한 줄로

우리는 6장에서 `&&`를 아직 배우지 않았기 때문에, 범위를 검사할 때 if문을 겹겹이 쌓아야(중첩) 했다. 10대인지(10~19세) 확인하기 위해 관문을 두 개나 만들었다.

```c
/* [Before] 6장 방식: 중첩 if (깊고 복잡함) */
if (age >= 10) {
    if (age <= 19) {
        /* 여기서 age는 10대 */
    }
}
```
이제 우리에게는 `&&`라는 강력한 접착제가 생겼다. 두 개의 관문을 굳이 따로 세울 필요 없이 한 줄로 합칠 수 있다.
```c
/* [After] 16장 방식: && 연산자 (깔끔한 한 줄) */
if (age >= 10 && age <= 19) {
    /* 여기서 age는 10대 */
}
```
무엇이 좋아졌을까?

1.  **깊이(Depth)가 얕아짐:** 불필요한 들여쓰기가 사라져 코드가 평평해졌다.
2.  **가독성:** "10세 이상 그리고 19세 이하"라는 의도가 한눈에 들어온다.

프로그래밍에서는 이렇게 결과는 같지만 내부 구조를 더 효율적이고 깔끔하게 고치는 과정을 리팩터링(Refactoring)이라고 한다. 도구(문법)를 하나씩 익힐 때마다, 여러분의 코드는 더 짧고 강력해질 것이다.

### 16.1.5 || : 하나라도 참이면 참 (OR)

`||` 연산자는 `&&`보다 훨씬 관대하다. 두 조건 중 어느 한쪽이라도 참이면 결과는 1(참)이 된다. 둘 다 거짓일 때만 0(거짓)이 된다.

* 참 `||` 거짓은 **1**
* 거짓 `||` 참은 **1**
* 거짓 `||` 거짓은 **0**

이 연산자는 주로 "~이거나(OR)"의 상황을 표현할 때 사용합니다.

**범위 밖을 검사할 때**
`&&`가 "0에서 100 사이"를 검사했다면, `||`는 그 반대인 "범위를 벗어난 비정상적인 값"을 잡아낼 때 유용하다.

```c
/* 0보다 작거나, 100보다 크면 (잘못된 점수) */
if (score < 0 || score > 100) {
    printf("점수가 올바르지 않습니다.\n");
}
```

**여러 선택지를 검사할 때**
사용자의 입력이 소문자 'q'일 수도 있고, 대문자 'Q'일 수도 있다. 둘 중 하나만 맞아도 종료해야 한다면 이렇게 쓴다.
```c
/* 'q'를 눌렀거나, 'Q'를 눌렀다면 */
if (input == 'q' || input == 'Q') {
    return 0; /* 종료 */
}
```

> [!NOTE]
> 컴퓨터는 게으르다
>
> `&&`와 `||`는 결과가 이미 정해지면 오른쪽을 보지 않을 수 있다.
> 단축(Short-circuit) 평가라고 부르며, 16.2에서 안전 규칙으로 정리한다.

### 16.1.6 `||`로 반복되는 `else if` 정리하기

`&&`가 깊어지는 들여쓰기(중첩 `if`)를 해결해 줬다면, `||`는 지루하게 반복되는 코드를 해결해 준다.

6장에서는 잘못된 값을 골라낼 때, 에러 처리 코드를 여러 번 복사해서 붙여넣어야 했다.
```c
/* [Before] 6장 방식: 코드가 중복됨 */
if (score < 0) {
    /* 잘못된 값에 대한 에러 처리 */
}
else if (score > 100) {
    /* 잘못된 값에 대한 똑같은 에러 처리 */
}
```
"0보다 작거나" 또는 "100보다 크면" 에러라는 목적은 같은데, 에러 처리 코드를 두 번이나 쓰는 것은 비효율적이다. 
`||` 연산자를 쓰면 이 중복을 한 방에 없앨 수 있다.

```c
/* [After] 16장 방식: || 연산자로 통합 */
if (score < 0 || score > 100) {
    /* 잘못된 값에 대한 에러 처리 한번만 */
}
```
무엇이 좋아졌을까?

1.  **중복 제거:** 똑같은 에러 메시지를 두 번 쓸 필요가 없다. (나중에 메시지를 고칠 때도 한곳만 고치면 된다.)
2.  **논리 통합:** "정상 범위를 벗어난 경우"를 하나의 덩어리로 묶어서 관리할 수 있다.

프로그래밍에는 "DRY (Don't Repeat Yourself, 똑같은 말을 반복하지 마라)"라는 격언이 있다. `||` 연산자는 이 원칙을 지키는 가장 쉬운 방법이다.

### 16.1.7 우선순위와 괄호: "명확성"

논리 연산자 사이에도 힘의 우열(우선순위)이 존재한다.

1. `!` (가장 강함)
2. `&&` (논리 곱은 곱셈과 비슷)
3. `||` (논리 합은 덧셈과 비슷)

수학에서 덧셈보다 곱셈을 먼저 계산하듯, C언어도 `&&`를 `||`보다 먼저 처리한다. 하지만 이 순서를 억지로 외우려 애쓸 필요는 없다. 
가장 좋은 규칙은 `&&`와 `||`가 섞이면 무조건 괄호로 묶는 것이다.

예를 들어, 다음 코드를 보자.

```c
if (a && b || c) { ... }
```

컴퓨터는 우선순위 규칙에 따라 `(a && b)`를 먼저 하고 나중에 `c`를 본다. 하지만 코드를 읽는 사람(동료 개발자)은 "뭐가 먼저지?" 하고 멈칫하게 된다.

그래서 의도를 명확히 드러내기 위해 괄호를 쓴다.

```c
/* 의도: (a와 b가 참)이거나, 혹은 c가 참이면 */
if ((a && b) || c) { ... }

/* 의도: a는 무조건 참이고, (b나 c 중 하나)가 참이면 */
if (a && (b || c)) { ... }
```

괄호 몇 글자를 더 적는 수고가, 나중에 코드를 읽을 때 생길 오해를 완벽하게 막아준다.

`x >= 0 && x <= 9`에서는 비교 연산자(`>=`, `<=`)가 우선순위에 따라 먼저 계산되고, 그래서 괄호 없이도 동작한다. 하지만 우리는 사람이 읽기 쉽게 괄호를 선택할 수도 있다. 

## 16.2 단축 평가(Short-circuit evaluation): 결과가 뻔하면 뒤는 안 본다

논리 연산자는 단순히 조건을 합치는 도구가 아닙니다. 조건식 안에서 검사를 어디까지 할지를 결정하는 작은 흐름 제어 장치이기도 하다.

핵심 규칙은 이 한 줄이다.

`&&`와 `||`는 왼쪽부터 평가하며, 이미 결과가 결정되면 오른쪽은 실행조차 하지 않는다.

전기 회로에서 전기가 지름길로 빠져버리는 현상에 빗대어 단락 평가라고 부른다.

### 16.2.1 `&&`의 단락 평가: 거짓말쟁이를 만나면 즉시 중단

`&&` (AND) 연산자는 하나만 거짓이어도 전체가 거짓이 된다. 따라서 왼쪽 조건이 거짓이면, 오른쪽 조건은 쳐다보지도 않고 넘어간다.

위험한 코드를 실행하기 전 안전장치를 만들 때 아주 유용하다.

```c
/* 안전한 코드 패턴 */
if (ptr != NULL && *ptr == 10) {
    /* 1. ptr이 NULL인지 먼저 확인 (거짓이면 중단) */
    /* 2. NULL이 아닐 때만 *ptr에 접근 (안전함) */
}
```

만약 단락 평가가 없어서 `*ptr`을 무조건 실행했다면, 프로그램은 뻗어버렸을 것이다.

### 16.2.2 `||`의 단락 평가: 정답을 찾으면 즉시 중단

반대로 `||` (OR) 연산자는 하나만 참이어도 전체가 참이 된다. 따라서 왼쪽 조건이 참이면, 오른쪽은 검사하지 않는다.

무거운 작업을 건너뛰는 최적화에 자주 쓰인다. 

```c
/* 예시: VIP 회원이면 입장료 결제 함수를 실행하지 않음 */
if (is_vip || make_payment()) {
    enter_gate();
}
```

1. `is_vip`가 참(1)이라면:
   이미 입장이 확정되었다.
   뒤에 있는 `make_payment()` 함수는 호출되지 않는다. (돈이 안 빠져나간다!)
2. `is_vip`가 거짓(0)이라면:
   그제야 뒤쪽의 `make_payment()`를 실행해서 결제를 시도한다.

만약 단락 평가가 없었다면, VIP 회원인데도 결제 함수가 실행되는 대참사가 일어났을 것이다. `||`는 앞에서 해결되면 뒤는 신경 끄는 효율적인 문지기 역할을 한다.

### 16.2.3 `&&`와 `||`를 쓸 때는 변수를 지켜주자

단락 평가 때문에 생기는 가장 흔하고 치명적인 실수가 있다. 오른쪽 조건에 변수 값을 바꾸거나(`=`), 중요한 함수를 호출하는 코드를 넣는 경우다.

앞서 본 `is_vip` 예제에서, 이번에는 누가 입장하든 방문 횟수를 1 증가시키고 싶다고 가정해 보자.
 
```c
int visits = 0;
int is_vip = 1; /* VIP 회원 */

/* 의도: VIP거나 일반인이거나, 일단 방문자 수를 늘리고 입장 */
if (is_vip || (visits = visits + 1) > 10) {
    /* is_vip인 경우 (visits = visits + 1) > 10 이 실행되지 않는다. */
}
```

VIP가 입장했을 때 결과는 어떻게 될까?

* **기대:** VIP가 입장했으니 `visits`가 1이 되어야 함.
* **실제:** `visits`는 여전히 **0**.

이유는 단순하다. `is_vip`가 참(1)이므로, 컴퓨터는 오른쪽 식 `(visits = visits + 1) > 0`을 아예 쳐다보지도 않고 건너뛰었기 때문이다. 결국 VIP 회원들은 통계에서 누락되는 유령 회원이 되어버린다.

가장 안전한 것은, 값이 변해야 하는 작업을 논리 계산 바깥으로 꺼내는 것이다.

```c

/* VIP거나 일반인이거나, 일단 방문자 수를 늘리기 */
visits = visits + 1;

/* 조건 처리에는 그 다음에 */
if (is_vip || visits > 10) {
    /* visists에는 현재 누적 방문자 수가 저장되어 있다. */
}
```


### 16.2.6 (주의) &와 &&, |와 || 구분하기

C언어에는 모양이 비슷해서 초보자를 괴롭히는 연산자들이 있다. 바로 하나짜리(`&`, `|`)와 두 개짜리(`&&`, `||`)다.

* `&&`, `||` : **논리 연산자** (참/거짓 판단, 조건 조립용)
* `&`, `|` : **비트 연산자** (0/1 비트 단위 계산용)

지금 배우는 `if`문이나 조건 검사에서는 무조건 두 개짜리(`&&`, `||`)를 써야 한다. 
실수로 하나만 썼을 때 발생하는 가장 큰 문제는 단축 평가를 하지 않는다는 점이다.

예를 들어 보자.

```c
/* (O) 안전함: ptr이 NULL이면 뒤쪽(*ptr)은 쳐다보지도 않음 */
if (ptr != NULL && *ptr == 5) { ... }

/* (X) 위험함: ptr이 NULL이어도 뒤쪽(*ptr)을 강제로 실행해서 뻗음 */
if (ptr != NULL & *ptr == 5) { ... }
```

`&`와 `|`는 나중에 비트 연산 파트에서 자세히 다룬다. 지금은 이것만 기억하자. "조건을 검사할 때는 키보드를 두 번씩(`&&`, `||`) 두드린다."

