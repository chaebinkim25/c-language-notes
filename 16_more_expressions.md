# 16. 흐름 제어의 완성: 조건을 조립하고 반복을 유연하게

우리는 6장에서 `if`문을 배우며 프로그램에 갈림길을 만들었다. 덕분에 무조건 직진만 하던 코드가 상황에 따라 다른 길을 선택할 수 있게 되었다. 
7장에서는 `for`문을 통해 "횟수가 보이는" 반복을 구현했다. 1부터 10까지 더하거나, 배열을 순회하는 일은 이제 익숙해졌다.

그런데 현실의 문제는 조금 더 복잡하다. 코드를 짜다 보면 다음 두 가지가 부족해 코드가 지저분해지는 순간이 온다.

1. **조건을 조립하는 도구의 부재**: "나이가 20세 이상이고(AND), (입장권을 가지고 있거나(OR), 초청장이 있어야 한다)" 같은 복합적인 조건을 `if`문 중첩으로만 짜려면 코드가 깊은 늪에 빠진다.

2. **언제 끝날지 모르는 반복**: 사용자가 '종료' 버튼을 누를 때까지, 혹은 파일의 끝에 닿을 때까지 반복해야 한다면, 횟수를 정해두는 `for`문은 어울리지 않는다.

또 하나의 문제가 있다. 분기가 10개, 20개가 넘어가면 `if-else if` 사다리는 너무 길어져서 읽기가 괴로워진다. 
그리고 조건식이나 반복문 안에서 `i++` 같은 코드를 무심코 섞어 썼다가, **부수 효과**라는 함정에 빠져 원인을 알 수 없는 버그를 만들기도 한다.

그동안 미뤄두었던 흐름 제어의 나머지 퍼즐 조각을 맞추는 시간이 왔다. 새로운 도구들을 익히면 여러분의 논리는 더 단단해지고, 코드는 더 안전해질 것이다.

## 16.0 목표

이 장을 끝내면 다음을 할 수 있게 된다.

- `&&`, `||`, `!`로 조건을 조립할 수 있다.
- 단락 평가(Short-circuit) 때문에 조건의 일부가 "실행되지 않을 수 있다"는 것을 이해한다.
- 횟수가 정해지지 않은 반복을 `while`과 `do`-`while`로 제어할 수 있다.
- `switch`로 여러 갈래 분기를 깔끔하게 정리하고, `break`와 fall-through를 활용할 수 있다.
- `++`, `--`, 대입(`=`) 같이 변수의 값을 바꾸는 부수 효과가 포함된 식을 안전하게 작성하는 습관을 기른다. 

## 16.1 조건을 조립하는 논리 연산자: `&&`, `||`, `!`

### 16.1.1 C의 참/거짓 규칙 다시 보기

우리는 6장에서 `if`문을 배울 때 "조건이 참이면 실행되고, 거짓이면 실행되지 않는다"라고 배웠다. 
`if`문에서 조건이 참이라는 것을 확인하는 방법은 0이 아닌지 확인하는 것이었다.

```c
if (0) {
    /* 절대 실행되지 않음 (0이므로 거짓) */
}

if (100) {
    /* 항상 실행됨 (0이 아니므로 참) */
}
```

비교 연산은 참일 경우에 결과값이 `1`이었고, 거짓일 경우는 결과값이 `0`이었다. 

```c
20 > 19;   /* 이 비교 연산의 결과값은 참에 해당하는 1이다. */

19 > 19;   /* 이 비교 연산의 결과값은 거짓에 해당하는 0이다. */

```
