# 16. 흐름 제어의 완성: 조건을 조립하고 반복을 유연하게

우리는 6장에서 `if`문을 배우며 프로그램에 갈림길을 만들었다. 덕분에 무조건 직진만 하던 코드가 상황에 따라 다른 길을 선택할 수 있게 되었다. 
7장에서는 `for`문을 통해 "횟수가 보이는" 반복을 구현했다. 1부터 10까지 더하거나, 배열을 순회하는 일은 이제 익숙해졌다.

그런데 현실의 문제는 조금 더 복잡하다. 코드를 짜다 보면 다음 두 가지가 부족해 코드가 지저분해지는 순간이 온다.

1. **조건을 조립하는 도구의 부재**: "나이가 20세 이상이고(AND), (입장권을 가지고 있거나(OR), 초청장이 있어야 한다)" 같은 복합적인 조건을 `if`문 중첩으로만 짜려면 코드가 깊은 늪에 빠진다.

2. **언제 끝날지 모르는 반복**: 사용자가 '종료' 버튼을 누를 때까지, 혹은 파일의 끝에 닿을 때까지 반복해야 한다면, 횟수를 정해두는 `for`문은 어울리지 않는다.

또 하나의 문제가 있다. 분기가 10개, 20개가 넘어가면 `if-else if` 사다리는 너무 길어져서 읽기가 괴로워진다. 
그리고 조건식이나 반복문 안에서 `i = i + 1` 같은 코드를 무심코 섞어 썼다가, **부수 효과**라는 함정에 빠져 원인을 알 수 없는 버그를 만들기도 한다.

그동안 미뤄두었던 흐름 제어의 나머지 퍼즐 조각을 맞추는 시간이 왔다. 새로운 도구들을 익히면 여러분의 논리는 더 단단해지고, 코드는 더 안전해질 것이다.

## 16.0 목표

이 장을 끝내면 다음을 할 수 있게 된다.

- `&&`, `||`, `!`로 조건을 조립할 수 있다.
- 단축 평가(Short-circuit) 때문에 조건의 일부가 "실행되지 않을 수 있다"는 것을 이해한다.
- 횟수가 정해지지 않은 반복을 `while`과 `do`-`while`로 제어할 수 있다.
- `switch`로 여러 갈래 분기를 깔끔하게 정리하고, `break`와 fall-through를 활용할 수 있다.
- `++`, `--`, 대입(`=`) 같이 변수의 값을 바꾸는 부수 효과가 포함된 식을 안전하게 작성하는 습관을 기른다. 

## 16.1 조건을 조립하는 논리 연산자: `&&`, `||`, `!`

조건을 만들다 보면 "A도 옳아야 하고 B도 옳아야 한다", "A나 B나 다 안 된다", "A가 틀리거나 B가 틀리거나 둘 다 틀려야 한다" 같은 말을 코드로 옮겨야 한다.

C언어는 이를 위해 다음과 같은 논리 연산자들을 제공한다.

- `!`(NOT, 논리 부정): 참을 거짓으로, 거짓을 참으로 바꾼다.
- `&&`(AND, 논리 곱): 두 조건이 모두 참일 때만 참이 된다.
- `||`(OR, 논리 합): 두 조건 중 하나라도 참이면 참이 된다. 

### 16.1.1 복습 C의 쿨한 규칙: 0만 아니면 다 OK

6장에서 배운 핵심 규칙을 다시 확인해보자. C언어는 참과 거짓을 판단할 때 아주 관대하다. 딱 하나, 0만 거짓이고 나머지는 전부 참으로 쳐준다.
여기서 중요한 점은 음수도 0이 아니기 때문에 참이라는 사실이다. 

```c
int x = -5;
if (x) {
    /* 실행 된다! -5도 0이 아니니까 참이다. */
}
```

반면에, 비교 연산자(`>`, `<`)가 결과를 내놓을 때는 아주 엄격하다. 조건이 맞으면 무조건 1, 틀리면 무조건 0이다.

```c
10 > 3;   /* 비교 식의 결과값은 참에 해당하는 1이다. */
3 > 10;   /* 비교 식의 결과값은 거짓에 해당하는 0이다. */
```

논리 연산자(`!`, `&&`, `||`)의 결과도 마찬가지로 항상 1 또는 0으로 나온다. 

### 16.1.2 `!` : 조건 뒤집기 (NOT)

`!` 연산자는 **참을 거짓으로, 거짓을 참으로** 바꾼다.

* `!0`은 `1` (거짓을 참으로)
* `!123`은 `0` (참을 거짓으로)

입력이 무엇이든 **결과는 무조건 0 또는 1**이 된다. 

한글 문장으로 비유하면 "~이 아니면"이고, 영어 문장으로 비유하면 "not ~"다. C 코드를 영어로 설명해보면, 자연스럽게 읽힌다.

```c
/* found 변수에는 찾았을 때 1, 못찾았을 때 0이 저장되어 있다고 가정한다. */
if (!found) {
    /* "찾지 못했다면(If not found)" */
}
```

> **[!NOTE] 괄호는 선택이 아니라 필수**
>
> `!`는 연산자 우선순위가 매우 높다(힘이 세다). 따라서 복잡한 조건을 뒤집을 때는 반드시 괄호로 감싸야 한다.
>
> * `!A && B` : A만 뒤집고 B와 AND 연산 (의도와 다를 수 있음)
> * `!(A && B)` : A와 B의 결과를 먼저 구하고 전체를 뒤집음 (안전함)

### 16.1.3 `&&` : 둘 다 참 (AND)

`&&` 연산자는 **두 조건이 모두 참(True)일 때만** 결과가 1이 된다. 하나라도 거짓이면 결과는 가차 없이 0이다.

* 참 `&&` 참은 **1**
* 참 `&&` 거짓은 **0**
* 거짓 `&&` 거짓은 **0**

가장 대표적인 사용처는 **범위 검사**다.

```c
if (x >= 0 && x <= 9) {
    /* x가 0 이상이고, "그리고" 9 이하일 때 */
}

```
> [!CAUTION]
> **수학식처럼 썼다간 큰일 난다**
>
> 초보 시절 가장 많이 하는 실수가 범위를 수학식처럼 한 줄에 쓰는 것이다.
>
>         /* (X) 문법 에러는 안 나지만, 논리 에러 발생 */
>         if (0 <= x <= 9) { ... }
>
> 이 코드가 위험한 이유는 **컴파일 에러가 뜨지 않고 실행되기 때문**이다. 컴퓨터는 이 식을 앞에서부터 순서대로 계산해버린다.
>
> 1.  `0 <= x`를 먼저 계산한다. 결과는 무조건 **0 또는 1**이다.
> 2.  그 결과(0 또는 1)를 가지고 다시 `9`와 비교한다. (`<= 9`)
> 3.  그런데 **0도 9보다 작고, 1도 9보다 작다.**
>
> 결국 x가 100이든 -50이든 이 조건식은 언제나 참이 되어 버린다. 따라서 C언어에서는 반드시 `&&`를 이용해 두 조건을 "접착제"로 붙여줘야 한다.

### 16.1.4 `&&`로 중첩 `if`문을 한줄로

우리는 6장에서 `&&`를 아직 배우지 않았기 때문에, 범위를 검사할 때 if문을 겹겹이 쌓아야(중첩) 했다. 10대인지(10~19세) 확인하기 위해 관문을 두 개나 만들었다.

```c
/* [Before] 6장 방식: 중첩 if (깊고 복잡함) */
if (age >= 10) {
    if (age <= 19) {
        /* 여기서 age는 10대 */
    }
}
```
이제 우리에게는 `&&`라는 강력한 접착제가 생겼다. 두 개의 관문을 굳이 따로 세울 필요 없이 한 줄로 합칠 수 있다.
```c
/* [After] 16장 방식: && 연산자 (깔끔한 한 줄) */
if (age >= 10 && age <= 19) {
    /* 여기서 age는 10대 */
}
```
무엇이 좋아졌을까?

1.  **깊이(Depth)가 얕아짐:** 불필요한 들여쓰기가 사라져 코드가 평평해졌다.
2.  **가독성:** "10세 이상 그리고 19세 이하"라는 의도가 한눈에 들어온다.

프로그래밍에서는 이렇게 결과는 같지만 내부 구조를 더 효율적이고 깔끔하게 고치는 과정을 리팩터링(Refactoring)이라고 한다. 도구(문법)를 하나씩 익힐 때마다, 여러분의 코드는 더 짧고 강력해질 것이다.

### 16.1.5 || : 하나라도 참이면 참 (OR)

`||` 연산자는 `&&`보다 훨씬 관대하다. 두 조건 중 어느 한쪽이라도 참이면 결과는 1(참)이 된다. 둘 다 거짓일 때만 0(거짓)이 된다.

* 참 `||` 거짓은 **1**
* 거짓 `||` 참은 **1**
* 거짓 `||` 거짓은 **0**

이 연산자는 주로 "~이거나(OR)"의 상황을 표현할 때 사용한다.

**범위 밖을 검사할 때**
`&&`가 "0에서 100 사이"를 검사했다면, `||`는 그 반대인 "범위를 벗어난 비정상적인 값"을 잡아낼 때 유용하다.

```c
/* 0보다 작거나, 100보다 크면 (잘못된 점수) */
if (score < 0 || score > 100) {
    /* 에러 처리하기 */
}
```

**여러 선택지를 검사할 때**
사용자의 입력이 소문자 'q'일 수도 있고, 대문자 'Q'일 수도 있다. 둘 중 하나만 맞아도 종료해야 한다면 이렇게 쓴다.
```c
/* 'q'를 눌렀거나, 'Q'를 눌렀다면 */
if (input == 'q' || input == 'Q') {
    return 0; /* 종료 */
}
```

> [!NOTE]
> 컴퓨터는 게으르다
>
> `&&`와 `||`는 결과가 이미 정해지면 오른쪽을 보지 않을 수 있다.
> 단축(Short-circuit) 평가라고 부르며, 16.2에서 안전 규칙으로 정리한다.

### 16.1.6 `||`로 반복되는 `else if` 정리하기

`&&`가 깊어지는 들여쓰기(중첩 `if`)를 해결해 줬다면, `||`는 지루하게 반복되는 코드를 해결해 준다.

6장에서는 잘못된 값을 골라낼 때, 에러 처리 코드를 여러 번 복사해서 붙여넣어야 했다.
```c
/* [Before] 6장 방식: 코드가 중복됨 */
if (score < 0) {
    /* 잘못된 값에 대한 에러 처리 */
}
else if (score > 100) {
    /* 잘못된 값에 대한 똑같은 에러 처리 */
}
```
"0보다 작거나" 또는 "100보다 크면" 에러라는 목적은 같은데, 에러 처리 코드를 두 번이나 쓰는 것은 비효율적이다. 
`||` 연산자를 쓰면 이 중복을 한 방에 없앨 수 있다.

```c
/* [After] 16장 방식: || 연산자로 통합 */
if (score < 0 || score > 100) {
    /* 잘못된 값에 대한 에러 처리 한번만 */
}
```
무엇이 좋아졌을까?

1.  **중복 제거:** 똑같은 에러 메시지를 두 번 쓸 필요가 없다. (나중에 메시지를 고칠 때도 한곳만 고치면 된다.)
2.  **논리 통합:** "정상 범위를 벗어난 경우"를 하나의 덩어리로 묶어서 관리할 수 있다.

프로그래밍에는 "DRY (Don't Repeat Yourself, 똑같은 말을 반복하지 마라)"라는 격언이 있다. `||` 연산자는 이 원칙을 지키는 가장 쉬운 방법이다.

### 16.1.7 우선순위와 괄호: "명확성"

논리 연산자 사이에도 힘의 우열(우선순위)이 존재한다.

1. `!` (가장 강함)
2. `&&` (논리 곱은 곱셈과 비슷)
3. `||` (논리 합은 덧셈과 비슷)

수학에서 덧셈보다 곱셈을 먼저 계산하듯, C언어도 `&&`를 `||`보다 먼저 처리한다. 하지만 이 순서를 억지로 외우려 애쓸 필요는 없다. 
가장 좋은 규칙은 `&&`와 `||`가 섞이면 무조건 괄호로 묶는 것이다.

예를 들어, 다음 코드를 보자.

```c
if (a && b || c) { ... }
```

컴퓨터는 우선순위 규칙에 따라 `(a && b)`를 먼저 하고 나중에 `c`를 본다. 하지만 코드를 읽는 사람(동료 개발자)은 "뭐가 먼저지?" 하고 멈칫하게 된다.

그래서 의도를 명확히 드러내기 위해 괄호를 쓴다.

```c
/* 의도: (a와 b가 참)이거나, 혹은 c가 참이면 */
if ((a && b) || c) { ... }

/* 의도: a는 무조건 참이고, (b나 c 중 하나)가 참이면 */
if (a && (b || c)) { ... }
```

괄호 몇 글자를 더 적는 수고가, 나중에 코드를 읽을 때 생길 오해를 완벽하게 막아준다.

`x >= 0 && x <= 9`에서는 비교 연산자(`>=`, `<=`)가 우선순위에 따라 먼저 계산되고, 그래서 괄호 없이도 동작한다. 하지만 우리는 사람이 읽기 쉽게 괄호를 선택할 수도 있다. 

## 16.2 단축 평가(Short-circuit evaluation): 결과가 뻔하면 뒤는 안 본다

논리 연산자는 단순히 조건을 합치는 도구가 아니다. 조건식 안에서 검사를 어디까지 할지를 결정하는 작은 흐름 제어 장치이기도 하다.

핵심 규칙은 이 한 줄이다.

`&&`와 `||`는 왼쪽부터 평가하며, 이미 결과가 결정되면 오른쪽은 실행조차 하지 않는다.

전기 회로에서 전기가 지름길로 빠져버리는 현상에 빗대어 단축 평가라고 부른다.

단축 평가는 빠르게 만들려고 가끔 하는 최적화가 아니라, C가 보장하는 평가 규칙이다. 

### 16.2.1 `&&`의 단축 평가: 거짓말쟁이를 만나면 즉시 중단

`&&` (AND) 연산자는 하나만 거짓이어도 전체가 거짓이 된다. 따라서 왼쪽 조건이 거짓이면, 오른쪽 조건은 쳐다보지도 않고 넘어간다.

위험한 코드를 실행하기 전 안전장치를 만들 때 아주 유용하다.

```c
/* 안전한 코드 패턴 */
if (ptr != NULL && *ptr == 10) {
    /* 1. ptr이 NULL인지 먼저 확인 (거짓이면 중단) */
    /* 2. NULL이 아닐 때만 *ptr에 접근 (안전함) */
}
```

만약 단축 평가가 없어서 `*ptr`을 무조건 실행했다면, 프로그램은 뻗어버렸을 것이다.

배열의 인덱스를 확인할 때도 마찬가지다.

```c
/* 안전한 코드 패턴 */
if (i >= 0 && i < n && a[i] == target) {
    /* 1. 인덱스 i가 0 이상인지 먼저 확인 */
    /* 2. 인덱스 i가 배열 크기 n보다 작은지 확인 */
    /* 3. 인덱스가 범위 안에 있을 때만 a[i] 값을 확인 (안전함) */
}
```

단축 평가를 했기 때문에, `i`가 범위 안에 있을 때만 배열 원소에 접근한다. 

### 16.2.2 `||`의 단축 평가: 정답을 찾으면 즉시 중단

반대로 `||` (OR) 연산자는 하나만 참이어도 전체가 참이 된다. 따라서 왼쪽 조건이 참이면, 오른쪽은 검사하지 않는다.

무거운 작업을 건너뛰는 최적화에 자주 쓰인다. 

```c
/* 예시: VIP 회원이면 입장료 결제 함수를 실행하지 않음 */
if (is_vip || make_payment_and_check()) {
    enter_gate();
}
```

1. `is_vip`가 참(1)이라면:
   이미 입장이 확정되었다.
   뒤에 있는 `make_payment_and_check()` 함수는 호출되지 않는다. (돈이 안 빠져나간다!)
2. `is_vip`가 거짓(0)이라면:
   그제야 뒤쪽의 `make_payment_and_check()`를 실행해서 결제를 시도한다.
3. `make_payment_and_check()`를 실행한 결과 결제가 완료되어 값이 1이면:
   입장한다.

만약 단축 평가가 없었다면, VIP 회원인데도 결제 함수가 실행되는 대참사가 일어났을 것이다. `||`는 앞에서 해결되면 뒤는 신경 끄는 효율적인 문지기 역할을 한다.

### 16.2.3 `&&`와 `||`를 쓸 때는 변수를 지켜주자

단축 평가 때문에 생기는 가장 흔하고 치명적인 실수가 있다. 어떤 경우에도 실행해야 하는 코드를 오른쪽에 넣는 경우다.

앞서 본 `is_vip` 예제에서, 이번에는 누가 입장하든 방문 횟수를 1 증가시키고 싶다고 가정해 보자.
 
```c
int visits = 0;
int is_vip = 1; /* VIP 회원 */

/* 의도: VIP거나 일반인이거나, 일단 방문자 수를 늘리고 입장 */
if (is_vip || (visits = visits + 1) > 10) {
    /* is_vip인 경우 (visits = visits + 1) > 10 이 실행되지 않는다. */
}
```

VIP가 입장했을 때 결과는 어떻게 될까?

* **기대:** VIP가 입장했으니 `visits`가 1이 되어야 함.
* **실제:** `visits`는 여전히 **0**.

이유는 단순하다. `is_vip`가 참(1)이므로, 컴퓨터는 오른쪽 식 `(visits = visits + 1) > 10`을 아예 쳐다보지도 않고 건너뛰었기 때문이다. 결국 VIP 회원들은 통계에서 누락되는 유령 회원이 되어버린다.

가장 안전한 것은, 값이 변해야 하는 작업을 논리 계산 바깥으로 꺼내는 것이다.

```c

/* VIP거나 일반인이거나, 일단 방문자 수를 늘리기 */
visits = visits + 1;

/* 조건 처리에는 그 다음에 */
if (is_vip || visits > 10) {
    /* visits에는 현재 누적 방문자 수가 저장되어 있다. */
}
```

### 16.2.4 단축 평가의 전략: "가벼운 건 앞, 무거운 건 뒤"

단축 평가(Short-circuit) 덕분에 프로그래머는 조건문을 전략적으로 배치할 수 있다. 오른쪽 코드가 "건너뛰어질 수 있다"는 점을 이용하는 것이다.

규칙은 간단하다.

1.  **가벼운 조건 / 안전 점검(Gatekeeper)** 을 왼쪽에 둔다.
2.  **무거운 연산 / 위험한 시도(Action)** 는 오른쪽에 둔다.

비유하자면 성에 들어갈 때 "초대장이 있는지(가벼운 조건)"을 먼저 보고, 무거운 성문을 열어주는(무거운 작업) 것과 같다.

**1. 안전을 위한 배치 (Crash 방지)**
가장 흔한 패턴은 포인터를 사용할 때다.

* **왼쪽:** 포인터가 `NULL`인지 확인 (가벼움)
* **오른쪽:** 포인터가 가리키는 값 읽기 (위험함)

```c
/* ptr이 NULL이면 오른쪽은 실행되지 않으므로 안전함 */
if (ptr != NULL && *ptr == 10) { ... }

/* (X) 위험: ptr이 NULL일 때 *ptr을 먼저 평가할 수 있음 */
if (*ptr == 10 && ptr != NULL) { ... }

```

**2. 성능을 위한 배치 (렉 방지)**
시간이 오래 걸리는 작업(DB 접속, 파일 읽기)을 뒤로 미룬다.

* **왼쪽:** 이미 로딩된 데이터가 있는지 확인 (가벼움)
* **오른쪽:** 하드디스크에서 파일 읽기 (무거움)

```c
/* 데이터가 준비되지 않았을 때만(왼쪽이 거짓일 때만), 파일을 읽어옴 */
if (is_data_ready || load_from_file()) { ... }
```

만약 `load_from_file()`을 왼쪽에 뒀다면, 데이터가 이미 있는데도 매번 파일을 읽느라 프로그램이 느려졌을 것이다. 논리 연산자 순서 하나도 프로그램의 **안전성**과 **성능**을 좌우할 수 있다.

### 16.2.5 (주의) `&`와 `&&`, `|`와 `||` 구분하기

C언어에는 모양이 비슷해서 초보자를 괴롭히는 연산자들이 있다. 바로 하나짜리(`&`, `|`)와 두 개짜리(`&&`, `||`)다.

* `&&`, `||` : **논리 연산자** (참/거짓 판단, 조건 조립용)
* `&`, `|` : **비트 연산자** (0/1 비트 단위 계산용)

지금 배우는 `if`문이나 조건 검사에서는 무조건 두 개짜리(`&&`, `||`)를 써야 한다. 
실수로 하나만 썼을 때 발생하는 가장 큰 문제는 단축 평가를 하지 않는다는 점이다.

예를 들어 보자.

```c
/* (O) 안전함: ptr이 NULL이면 뒤쪽(*ptr)은 쳐다보지도 않음 */
if (ptr != NULL && *ptr == 5) { ... }

/* (X) 위험함: ptr이 NULL이어도 뒤쪽(*ptr)을 강제로 실행해서 뻗음 */
if (ptr != NULL & *ptr == 5) { ... }
```

뿐만 아니라, 비트 연산을 하기 때문에 피연산자가 0, 1이 아닌 경우 잘못된 결과를 얻을 수 있고, 평가 순서도 보장되지 않는다.
`&`와 `|`는 나중에 비트 연산 파트에서 자세히 다룬다. 지금은 이것만 기억하자. "조건을 검사할 때는 키보드를 두 번씩(`&&`, `||`) 두드린다."

## 16.3 횟수가 아니라 '조건'일 때: while

`for`는 "시작값; 조건; 갱신"이 한 줄에 모여 있어서 횟수가 정해진 반복(10번, 100번)에 아주 강하다. 마치 "운동장 10바퀴 뛰세요"라는 명령과 같다.

하지만 현실의 반복은 **"언제 끝날지 모르는"** 경우가 더 많다.

* "사용자가 '종료' 버튼을 누를 때까지"
* "파일의 끝이 나올 때까지"
* "정답을 맞힐 때까지"

이건 "비가 올 때까지 운동장을 뛰세요"와 같다. 몇 바퀴를 돌지는 중요하지 않고, 오직 조건(비가 오냐 안 오냐)만 중요하다.

### 16.3.1 for가 어색해지는 순간

특정 상태가 유지되는 동안 반복을 할 때는 `for`문으로 짜면 코드가 어색해진다.

예를 들어, 집에 갈 때가 아닌 동안(!should_go), 계속 쇼핑하기를 코드로 짜보자. 

```c
/* for문: 앞뒤가 텅 비어서 어색함 */
for (;!should_go;) {
    if (should_buy()) {
        shopping();
        extra_money -= price();
        update_status_after_buy();
    }
    else {
        update_status_no_buy();
    }
}
```

문법적으로는 틀리지 않았지만, 읽기가 불편하다. 여기서 `for` 대신 사용하는 것이 바로 `while`이다.

```c
/* while문: 문장처럼 자연스럽다 */
while (!should_go) {
    if (should_buy()) {
        shopping();
        extra_money -= price();
        update_status_after_buy();
    }
    else {
        update_status_no_buy();
    }
}
```

코드를 읽어보면 "집에 갈 때가 아닌 동안(while ...), 계속한다"라고 영어 문장처럼 자연스럽다.

**`while`은 반복되는 `if`문이다**

구조를 뜯어보면 `while`문은 `if`문과 형제지간이다. 

* **`if`:** 조건이 참이면 한 번 실행하고 끝.
* **`while`:** 조건이 참이면 실행하고, 다시 조건 검사로 되돌아감. 

`while`은 어렵게 생각할 것 없이 조건이 맞으면 계속 뱅글뱅글 도는 `if`문이라고 보면 된다.

### 16.3.2 `for`문과 `while`문의 변환 공식

`for`문은 마법이 아니다. 내부적으로는 `while`문과 거의 같은 구조로 동작한다.

```c
/* for 문의 구조 */
for (초기식; 조건식; 증감식) {
    반복할_코드;
}
```

이것을 `while`문으로 풀어서 쓰면 다음과 같다. 실행 순서를 눈여겨보자.

```c
/* while 문으로 변환 */
초기식;

while (조건식) {
    반복할_코드;
    증감식;      /* 여기가 중요! 코드가 끝나면 증감한다 */
}
```

예를 들어 `0`부터 `2`까지 출력하는 코드를 비교해 보자.

```c
/* [for] 한 줄에 다 있어서 깔끔함 */
int i;
for (i = 0; i < 3; i = i + 1) {
    /* 반복 작업 */
}

/* [while] 위아래로 흩어져 있음 */
int i = 0;          /* 초기식 */
while (i < 3) {     /* 조건식 */
    /* 반복 작업 */
    i = i + 1;            /* 증감식 (까먹으면 무한 루프!) */
}
```

따라서 반복 횟수가 명확할 때는 `for`가 훨씬 안전하고, 조건에 따라 흐름이 복잡할 때는 `while`로 펼쳐 쓰는 것이 좋다.

> [!WARNING]
> "거의 같다"고 했지 "완전히 같다"고는 안 했다
>
> `for`를 `while`로 바꿀 때 딱 하나 조심해야 할 것이 있다. 바로 `continue`다.
>
> * **for 문:** `continue`를 만나면 **증감식(`i = i + 1`)**로 점프해서 다음 순서를 준비한다. (안전)
> * **while 문:** `continue`를 만나면 **증감식(`i = i + 1`)을 건너뛰고** 바로 조건식으로 간다. (증감이 안 되니 **무한 루프**에 빠질 위험 있음!)
>
> `continue`를 사용하는 `while`문을 짤 때는 증감식의 위치를 각별히 신경 써야 한다.

### 16.3.3 "끝을 모르는 반복" 패턴 2종

`for`문이 횟수를 정해놓고 뛰는 것이라면, `while`은 상황에 따라 유연하게 대처하는 반복이다. 실무에서는 크게 두 가지 패턴을 쓴다.

**조건 기반 (선 검사)**

가장 정석적인 방법이다. 시작하기 전에 조건부터 본다는 특징이 있다.

```c
int money = 1000;

/* 돈이 없으면 아예 시작도 안 함 */
while (money > 0) {
    /* 쇼핑을 한다 */
    money = money - 100;
}
```

**무한 루프 + `break` (중간 검사)**

일단 돌리고 본다. 그러다 특정 조건이 되면 탈출(`break`)한다.
**일단 작업을 해봐야 끝낼지 말지 알 수 있을 때** 유용하다.

```c
int input = 0;

/* 1은 참(True)이므로 무한히 반복 */
while (1) {
    /* 숫자를 입력받아서 input에 저장한다 */
    
    if (input == 0) {
        /* 종료한다 */
        break; /* 반복문을 박차고 나감 */
    }

    /* 입력값을 처리한다 */
}
```

왜 무한루프 + `break` 패턴 2를 쓸까? 선 검사 패턴을 짜려면 숫자 입력을 `while` 위에서도 받고 안에서도 받아야 해서 코드가 중복되는 경우가 많다. 
무한루프 + `break` 패턴을 쓰면 흐름이 훨씬 자연스러워질 때가 많다.

> [!NOTE]
> 
> C언어의 고수들은 관습적으로 `while(1)`을 많이 쓴다. (1이 참이니까)
> 최신 스타일(C99 이상)을 선호한다면 `<stdbool.h>`를 포함하고 `while(true)`라고 써도 된다. 의미는 완전히 같다.

### 16.3.4 `while`에서 `continue` 쓰기

7장에서 배운 `break`와 `continue`는 `while`에서도 똑같이 쓸 수 있다. 
하지만 `continue`를 쓸 때는 각별한 주의가 필요하다. 점프하는 목적지가 `for`와 미묘하게 다르기 때문이다.

* `for`의 `continue`: 증감식으로 점프 (안전)
* `while`의 `continue`: 조건식으로 바로 점프 (위험!)

이 차이 때문에 `while`문 안에서 `continue`를 잘못 쓰면 진행을 만드는 코드를 건너뛰어 버리는 사고가 발생한다.

**흔한 반복문:**
```c
/* i를 증가하며 반복하고, 원소가 0이 아니면 데이터 처리를 한다 */
int i = 0;
while (i < n) {
    if (a[i] != 0) {
        /* 데이터 처리 */
    }
    i = i + 1;
}
```

**흔한 실수: 제자리걸음 무한 루프**

다음 코드를 보자. 데이터가 0인 경우를 건너뛰고 싶었지만, 결과는 끔찍하다.

```c
/* (나쁜 예) i 증가가 맨 아래에만 있는 경우 */
int i = 0;
while (i < n) {
    if (a[i] == 0) {
        /* 여기서 조건식으로 바로 점프! i는 그대로 0인 상태 */
        continue;
    }
    /* 0이 아닌 값을 처리하는 코드 */
    i = i + 1;   /* 이 코드가 실행되지 않아서, i는 영원히 0 */
}
```

`i`가 증가하지 않은 채로 다시 검사하러 가므로, 컴퓨터는 제자리걸음만 하며 영원히 `a[0]`만 쳐다보게 된다. (무한 루프)

**해결책: 수동으로 밀어주기**

이를 고치려면 `continue`를 하기 직전에 수동으로 진행(`i = i + 1`)을 시켜줘야 한다.

```c
/* (수정) continue 전에도 발걸음을 떼게 해준다 */
int i = 0;
while (i < n) {
    if (a[i] == 0) {
        i= i + 1;    /* 잊지 말고 증가! */
        continue;
    }
    /* 0이 아닌 값을 처리하는 코드 */
    i = i + 1;        /* 평소의 증가 */
}
```

> [!NOTE]
> 
> 코드가 지저분해 보인다면?
>
> 위 코드를 보면 `i = i + 1`이 두 번이나 나와서 깔끔하지 않다(중복 코드).
> 인덱스(`i`)를 규칙적으로 증가시키는 경우라면, 실수할 여지가 없는 `for`문을 쓰는 것이 가장 안전하다.

### 16.3.5 while로 하는 스캔: "찾으면 멈추기"

`while`은 데이터를 처음부터 끝까지 훑는 스캔 작업에 특히 강하다. `for`문이 정해진 횟수를 채우는 느낌이라면, `while`은 조건을 만족할 때까지 걷는 느낌이다.

대표적인 사용처는 두 가지다.

1.  **배열 검색:** 원하는 값을 찾으면 즉시 멈춤
2.  **문자열 처리:** 끝(`\0`)을 만날 때까지 걷기

**배열에서 값 찾기**

여기서 앞서 배운 `&&`의 단축 평가가 빛을 발한다. "범위를 넘지 않았는지"와 "값을 찾았는지"를 한 줄에 검사할 수 있다.
```c
int i = 0;
/* 범위 안에 있고, 아직 못 찾았다면, 계속 가라 */
while (i < size && arr[i] != target) {
    i = i + 1;
}
```

이 코드가 종료되는 경우는 딱 두 가지뿐이다.

1.  **찾았을 때:** `arr[i] == target`이 되어 멈춤 (`i`는 찾은 위치)
2.  **못 찾았을 때:** `i == size`가 되어 멈춤 (`i`는 배열 끝)

따라서 반복문이 끝난 뒤에 `i`가 어디에 멈췄는지만 보면 된다.

```c
if (i < size) {
    /* arr[i]에서 찾았다 */
} else {
    /* 못찾았다 */
}
```

**문자열 걷기 (Sentinel)**

12장에서 배운 문자열도 `while`의 주무대다. 문자열의 길이를 몰라도, 센티널(`\0`)이 나올 때까지 계속 가면 되기 때문이다.

```c
const char *p = str;

/* null 문자(\0)가 아닐 때까지 전진 */
while (*p != '\0') {
    /* 문자 *p 방문중 */
    p = p + 1;
}
```

## 16.4 일단 저지르고 고민할 때: `do-while`

`while`은 조건 먼저 검사 방식이다. 조건이 처음부터 거짓이면 본문이 단 한 번도 실행되지 않는다. 마치 놀이공원 입장권 검사와 같다. 표가 없으면 아예 들어갈 수 없다.

하지만 현실에는 일단 한 번은 실행해야 하는 상황이 있다.

* 사용자에게 메뉴를 일단 보여주고, 선택을 받고 싶을 때
* 비밀번호를 일단 입력받고, 틀렸으면 다시 묻고 싶을 때

이럴 때는 조건 검사를 나중에 하는 `do-while`이 제격이다.
놀이공원 비유를 적용해보면, 일단 들어가서 좋은 시간을 보내고, 나갈 때 "한번 더?"라고 물어보는 것이다.

### 16.4.1 문법과 주의사항

구조는 `while`을 뒤집어 놓은 것과 비슷하다.

```c
do {
    /* 본문: 무조건 한 번은 실행됨 */
} while (조건식);  /* <-- 여기에 세미콜론(;) 필수! */
```

> [!WARNING]
> 세미콜론을 잊지 말자
>
> `if`, `for`, `while` 문 뒤에는 세미콜론을 붙이지 않지만, `do-while`은 유일하게 끝에 세미콜론(`;`)을 붙여야 한다. "명령이 여기서 끝난다"는 것을 컴파일러에게 알려주는 약속이다.

### 16.4.2 실전 예제: yes/no 선택 받기

사용자가 '종료(0)'를 누를 때까지 계속 메뉴를 보여주는 프로그램이다.

```c
char choice;

do {
    /* y 또는 n를 입력하라는 프롬프트를 보여준다. */
    /* choice에 키보드 입력을 받는다. */
} while (choice != 'y' && choice != 'n'); /* y/n이 아니면 다시 */

/* choice에는 'y' 또는 'n'이 저장되어 있다. */
```

만약 그냥 `while`로 짰다면, 프롬프트를 보여주고 입력을 받는 코드가 중복으로 들어가게 된다. 

```c
char choice;
/* y 또는 n를 입력하라는 프롬프트를 보여준다. */
/* choice에 키보드 입력을 받는다. */

while (choice != 'y' && choice != 'n') {
    /* y 또는 n를 입력하라는 프롬프트를 보여준다. */
    /* choice에 키보드 입력을 받는다. */
}

/* choice에는 'y' 또는 'n'이 저장되어 있다. */
```

확실히 `do-while` 쪽이 코드도 짧고 의도가 명확해진다.

> [!NOTE]
> 조건식이 헷갈릴 때
>
> `choice != 'y' && choice != 'n'` 이 조건은 choice가 y도 아니고, n도 아닐 때 참인 식이다.
> `||`를 써서 만들면 `!(choice == 'y' || choice == 'n')`으로도 쓸 수 있다.

### 16.4.3 (주의) 변수의 유효범위: "괄호 밖에서 선언하라"

`do-while`을 처음 쓸 때 가장 많이 만나는 컴파일 에러가 있다. 바로 변수의 범위 문제다.

다음 코드는 아주 그럴싸해 보이지만, 에러가 발생한다.
```c
do {
    int input; /* 여기서 변수 선언 (나쁜 위치) */
    
    /* 에 입력을 받아서 사용 */   

} while (input != 0); /* 에러! input이 누구야? */
```

**왜 에러가 날까**
C언어에서 중괄호 `{ }` 안에서 선언된 변수는, 닫는 중괄호 `}`를 만나는 순간 **사라진다(범위 바깥, 저장기간 종료).**

그런데 `do-while`의 조건 검사(`input != 0`)는 중괄호가 닫힌 바깥쪽에서 일어난다. `input`이라는 변수는 소멸한 뒤라 컴퓨터는 "input이 뭔지 모르겠다"고 불평하는 것이다.

**\[해결책\]**
조건식에서 검사해야 할 변수는 반드시 `do` 블록 바깥(위쪽)에 미리 선언해야 한다.

```c
int input; /* (O) 밖에서 선언해서 범위를 늘려준다 */

do {
    /* input에 입력을 받아서 사용 */   
} while (input != 0); /* 이제 input이 보인다 */
```

이 규칙은 "조건 검사에 쓰일 변수는 반복문보다 범위가 넓어야 한다"라고 기억하면 쉽다.

## 16.5 값 하나로 갈림길 만들기: switch

조건이 많아지면 `if - else if` 구조는 점점 읽기 힘들어진다. 마치 "스무고개"를 하듯 위에서부터 하나씩 물어보며 내려와야 하기 때문이다.

예를 들어 게임 캐릭터의 이동 키(w, a, s, d)를 처리한다고 해보자.

```c
/* if 문: 위에서부터 하나씩 검사... 피곤하다 */
if (key == 'w') {
    move_up();
}
else if (key == 'a') {
    move_left();
}
else if (key == 's') {
    move_down();
}
else if (key == 'd') {
    move_right();
}
else {
    stay();
}
```

구조가 반복되니 눈에 잘 들어오지 않는다.

검사 기준이 딱 하나고, 값이 딱 떨어지는 경우(동등 비교 `==`)**라면 `switch`문이 구원 투수가 된다.

```c
/* switch 문: 깔끔한 분류표 */
switch (key) {
    case 'w': move_up();    break;
    case 'a': move_left();  break;
    case 's': move_down();  break;
    case 'd': move_right(); break;
    default:  stay();       break;
}
```

마치 자판기 버튼처럼 원하는 값(`case`)으로 바로 점프하는 구조다.

> [!WARNING]
> 정수 계열만 받는다
>
> C언어의 `switch` 괄호 안에는 반드시 정수 계열(`int`, `char` 등)만 들어갈 수 있다.
> * `switch (3.14)` (X) : 실수는 안 된다.
> * `switch ("hello")` (X) : 문자열은 안 된다.
>
> 오직 딱 떨어지는 정수 값을 분류할 때만 사용하자.

> [!WARNING]
> 값이 중복되면 안된다.
>
> `case` 값이 중복해서 나오면 컴파일 에러가 발생한다. 

### 16.5.1 switch 문법의 해부

`switch`문의 구조는 생각보다 엄격합니다. 문법의 3요소(괄호, 콜론, `break`)를 눈여겨보자.

```c
switch (정수_데이터) {  /* 1. 검사할 값 (정수만 가능) */

case 1:                /* 2. 라벨 (반드시 콜론 : 사용) */
    명령_A;
    break;             /* 3. 탈출 (이게 없으면 아래로 흐름) */

case 2:
    명령_B;
    break;

default:               /* 4. 기타 (else와 같은 역할) */
    명령_C;
    break;
}
```

**동작 원리: "점프 후 직진"**
1.  **점프(Jump):** `switch` 괄호 안의 값을 계산해서, 일치하는 `case` 라벨로 순간 이동한다.
2.  **직진(Flow):** 그 위치부터 아래로 코드를 실행한다.
3.  **탈출(Break):** `break`를 만나면 `switch` 블록을 박차고 나간다.

> [!WARNING]
> `case` 뒤에는 고정된 값만 온다
>
> `case`는 조건식이 아니다. 변수나 범위를 쓸 수 없다.
>
> * `case 10:` (O) 정수 상수
> * `case 'A':` (O) 문자 상수 (결국 정수니까)
> * `case x:` (X) 변수는 안 됨!
> * `case a > 5:` (X) 조건식은 안 됨!

### 16.5.2 case 라벨의 규칙: "컴파일러가 아는 값만"

`case` 뒤에는 반드시 상수(Constant)만 올 수 있다. 더 정확히 말하면 컴파일러가 프로그램을 번역할 때(Compile-time) 값을 확정할 수 있는 것이어야 한다.

1. 가능한 것 (O)
컴퓨터가 미리 계산할 수 있다면 허용된다.
```c
case 3:         /* 정수 리터럴 */
case 'A':       /* 문자 리터럴 (사실은 정수 65) */
case 10 + 5:    /* 상수 수식 (컴파일러가 15로 미리 계산함) */
```

2. 불가능한 것 (X)
실행해봐야 값을 알 수 있는 변수는 절대 올 수 없다.

```c
int x = 3;

switch (input) {
case x:     /* (Error) 변수는 안 됨! */
    break;
}
```

> [!NOTE]
> 왜 변수는 안 될까?
>
> `switch`문은 프로그램이 실행되기 전에 컴파일러가 미리 바로가기 표(Jump Table)를 만들어 두기 때문이다.
>  변수는 실행 중에 값이 바뀌므로 이 표에 기록할 수 없다.

> [!NOTE]
> const 변수도 안 된다? (C언어의 함정)
>
> C++이나 다른 언어와 가장 큰 차이를 보이는 부분이다. C언어에서는 `const`가 붙어도 여전히 '변수'로 취급한다.
>
> ```c
> const int limit = 10;
>         
> switch (n) {
> case limit:  /* (Error) C언어에서는 이것도 변수라 안 됨! */
> }
> ```
> C언어의 `case`에는 오직 리터럴(숫자 그 자체)나 `#define` 매크로 상수, 뒤에서 다룰 `enum`만 쓸 수 있다는 점을 꼭 기억하자. 
>
> C++에서는 `const`가 붙으면 진짜 상수로 취급해서 `case`에 쓸 수 있다. Java/C#은 문자열도 되고, JavaScript/Python은 뭐든지 된다.

> [!NOTE]
> `case` 라벨의 들여쓰기: 계단식 vs 절벽식
>
> `switch` 문을 처음 작성할 때 가장 많이 하는 고민이 `case`를 들여써야 하나, 말아야 하나다. C언어 문법상 공백은 무시되지만, 가독성을 위해 주류 스타일을 따르는 것이 좋다.
>
> 1. 계단식 (최신 스타일)
> `switch`보다 `case`를 한 번 들여쓰고, 내용물은 거기서 또 들여쓴다.
> ```c
> switch (x) {
>     case 1:         /* switch보다 한 칸 들어감 */
>         printf("1");
>         break;      /* 내용물은 case보다 한 칸 들어감 */
>
>     case 2:
>         printf("2");
>         break;
> }
> ```
> * **장점:** 포함 관계(계층 구조)가 눈에 확 들어온다.
>
> 2. 절벽식 (과거 스타일)
> `switch`와 `case`의 줄을 맞추는 방식입니다. 옛날에 화면이 좁거나, 들여쓰기 깊이가 너무 깊어지는 것을 싫어하는 프로그래머들이 주로 사용했습니다.
> ```c
> switch (x) {
> case 1:             /* switch와 라인을 맞춤 */
>     printf("1");
>     break;
> case 2:
>     printf("2");
>     break;
> }
> ```
> * **장점:** 가로 공간을 아낄 수 있다.
> * **단점:** `switch` 블록의 시작과 끝이 한눈에 안 들어올 수 있다.
>
> 결론은 고민하지 말고 IDE에게 맡기자. 우리가 사용하는 자동 정렬 단축키(Visual Studio: `Ctrl + K, F` / VS Code: `Alt + Shift + F`)를 누르면, 도구가 알아서 예쁘게 정리해준다. 도구가 해주는 대로 쓰는 것이 가장 표준적인 방법이다.

### 16.5.3 `break`의 타깃: "가장 가까운 벽만 깬다"

`break`는 탈출 명령어다. 그런데 반복문(`for`, `while`)에서도 쓰고, 분기문(`switch`)에서도 쓴다.

그렇다면 `switch`가 반복문 안에 들어있다면 어떻게 될까?

```c
while (1) {       /* 바깥쪽 벽 (블록 1) */
    
    switch (x) {  /* 안쪽 벽 (블록 2) */
    case 1:
        break;    /* 무엇을 부수는가? */
    }

}
```

정답은, 가장 가까운 블록 하나만 탈출한다
안쪽의 `switch` 문만 빠져나가고, 바깥쪽 `while` 문은 여전히 쌩쌩하게 돌아간다.

바깥쪽 블록을 빠져나갈 것을 기대하고 코드를 짜면, 프로그램이 멈추지 않는 무한 루프에 빠지게 된다.

**해결책: 깃발(Flag)을 들어라**

두 개의 벽을 한꺼번에 탈출하고 싶다면, `break`만으로는 부족하다. 그만하자는 신호(변수)를 사용해야 한다.

```c
int is_running = 1; /* 1: 계속, 0: 멈춤 */

while (is_running) {
    switch (x) {
    case 1:
        /* 바깥쪽 while까지 종료하기 */
        is_running = 0;            /* 1. 신호를 끈다 */
        break;                     /* 2. switch 탈출 */
    }
    
    /* 3. break로는 switch만 나왔지만 is_running이 0이므로, while도 종료됨 */
}
```

1.  안쪽에서 `is_running`을 0으로 만든다.
2.  `break`로 `switch`를 나온다.
3.  `while` 조건식에서 `is_running`을 검사하고, 거짓(0)이므로 루프가 끝난다.

> [!NOTE]
> `goto`를 쓰는 유일한 핑계?
>
> 뒤에서 배울 `goto` 문은 C언어에서 절대 쓰지 마라고 배우지만, 다중 루프를 한 방에 탈출할 때만큼은 예외적으로 쓰이기도 한다.
> 하지만 초보자 단계에서는 위처럼 변수(Flag)를 사용하는 것이 훨씬 안전하고 정석적인 방법이다.

### 16.5.4 Fall-through: 브레이크 없는 내리막길

`switch` 문은 특이하게도 진입점(`case`)만 있고, 출구는 사용자가 직접 만들어야 한다.
`break`를 만날 때까지는 무조건 아래로 직진하는데, 이를 Fall-through(흘러내리기)라고 한다.

많은 경우 `break`를 빼먹는 것은 치명적인 버그다. 하지만 이 특성을 의도적으로 이용하면 아주 효율적인 코드를 짤 수 있다.

**여러 케이스 묶기 (Case Stacking)**

가장 대표적인 활용법이다. 마치 `if (a || b)` 처럼 "이것이거나, 저것이거나"를 표현할 때 쓴다.

```c
switch (ch) {
case 'a':
case 'A':   /* 'a'로 들어와도 break가 없으니 아래로 흐른다 */
    /* Apple! */
    break;  /* 여기서 멈춤 */

case 'b':
case 'B':
    /* Banana! */
    break;
}
```
빈 `case`를 층층이 쌓아두면, 위에서 떨어진 실행 흐름이 아래 내용을 공유하게 된다.

**단계적 실행 (Cumulative Execution)**

상위 단계가 하위 단계의 작업을 포함해야 할 때도 쓴다. (예: 보안 등급, 보상)

```c
switch (level) {
case 3:
    give_gold_medal();
    /* break 없음! 3등은 2등 상도 받는다 (fall through) */
case 2:
    give_silver_medal();
    /* break 없음! 2등은 1등 상도 받는다 */
case 1:
    give_bronze_medal();
    break;
}
```

**주석은 선택이 아니라 필수**

`break`가 없는 코드를 보면 동료 개발자(그리고 컴파일러)는 "실수인가?"라고 의심한다.
"실수가 아니라 의도된 거야"라고 알리기 위해 표준적인 주석을 반드시 달아야 한다.

```c
case 10:
    do_something();
    /* FALLTHROUGH */  /* 이렇게 표시해놓지 않으면 컴파일러가 경고(Warning)를 띄울 수 있음! */
case 9:
    ...
```
> [!NOTE]
> 최신 컴파일러와 Fall-through
>
> 최근의 GCC, Clang 같은 컴파일러들은 `break`가 없는 곳에서 경고를 뿜어낸다.
> `/* fall through */` 라는 주석을 달아주면 컴파일러가 "아, 알고 짠 거구나" 하고 조용히 넘어간다.

### 16.5.5 (주의) case 안에서 변수 선언하기

`switch` 문 안에서 변수를 선언할 때는 매우 조심해야 한다. C89(구버전)와 C99(신버전) 모두 함정이 있기 때문이다.

**1. C89의 함정: 문법 에러**
C89에서는 "변수 선언은 블록 맨 위에 해야 한다"는 철칙이 있다. `case` 라벨은 블록의 시작이 아니므로, 라벨 바로 뒤에 변수를 선언하면 컴파일 에러가 난다.

```c
switch (x) {
case 1:
    int y;   /* (Error) C89: 선언 위치 위반! */
    y = 3;
    break;
}
```
**2. C99/C++의 함정: 초기화 건너뛰기 (더 위험!)**
최신 컴파일러는 중간 선언을 허용하므로 위 코드가 에러 없이 돌아갈 수 있다. 하지만 논리적인 문제가 발생한다.

`switch`의 중괄호 `{ }` 전체가 하나의 스코프이기 때문에, `case 1`에서 만든 변수 `y`는 `case 2`에서도 보인다.

```c
switch (x) {
case 1:
    int y = 10;  /* 여기서 만들고 초기화함 */
    break;
    
case 2:
    /* (위험) y가 보이지만, 초기화 코드를 건너뛰고 옴! */
    break;
}
```
만약 `x`가 2라서 `case 2`로 바로 점프하면, `int y`는 메모리에 잡혔지만 `= 10`이라는 초기화 코드는 실행되지 않았다. `y`에는 알 수 없는 값이 들어있다.

**해결책: 블록 만들기 (Best Practice)**
가장 깔끔한 해결책은 `case`마다 **중괄호 `{ }`**를 쳐서 독립된 구역(Scope)을 만들어 주는 것이다.
```c
switch (x) {
case 1: {        /* 블록 시작 */
    int y = 10;  /* 이 y는 이 블록 안에서만 존재 */
    /* ... */
    break;
}                /* 블록 끝 (y 소멸) */

case 2: {
    int y = 20;  /* 이름이 같아도 상관없음 (새로운 변수) */
    /* ... */
    break;
}
}
```
이렇게 하면 변수의 범위가 중괄호 안으로 갇히게 되어, 이름 충돌이나 초기화 누락 문제를 완벽하게 막을 수 있다.

## 16.6 부수 효과(Side Effect): 계산의 흔적을 남기다

여기서부터가 이 장의 마지막, 부수 효과다.

"부수 효과"라는 말은 "계산 과정에서 일어나는 상태의 변화"를 뜻한다.

C언어의 수식(Expression)은 두 가지 일을 한다

- **주요 효과 (Main Effect):** 결과값을 만들어 낸다. (계산)
- **부수 효과 (Side Effect):** 변수의 값을 바꾸거나 화면에 무언가를 남긴다. (변화)

**1. 순수한 계산 (부수 효과 없음)**
다음 식은 값만 만들어낼 뿐, 메모리에 아무런 흔적을 남기지 않는다.

```c
3 + 5;
```

이 코드는 `8`이라는 값을 계산하지만, 어디에도 저장하지 않는다. 컴퓨터는 계산하고 나서 결과인 8을 쿨하게 버린다. (아무 일도 안 일어난 것과 같다)

**2. 흔적을 남기는 계산 (부수 효과 있음)**
반면에 대입 연산자(`=`)는 강력한 부수 효과를 가진다.
```c
a = 20;
```

* **주요 효과(값):** 이 식의 결과값은 `20`이다.
* **부수 효과(변화):** 변수 `a`의 메모리 공간에 `20`이 저장된다.

부수 효과는 메모리 변경이라고 딱 잘라 생각하면 된다. 

### 16.6.2 `i = i + 1` vs `i += 1` vs `i++`

프로그래머들은 "변수를 1 증가시키는 일"을 숨 쉬듯이 한다. 그래서 C언어는 이를 위한 다양한 도구를 제공한다.

셋 다 결과적으로 `i`가 1 커지지만, 식(Expression)으로서의 성격은 조금씩 다르다.

**`i = i + 1` (정석)**

가장 정직한 표현이다.
- **동작:** `i`에 1을 더한 값을 계산하고, 다시 `i`에 넣습니다.
- **단점:** `i`를 두 번이나 써야 해서, 변수 이름이 길면 귀찮다. (`player_score = player_score + 1`)

**`i += 1` (복합 대입)**

"어차피 내 값에 더할 건데 줄여 쓰자"고 해서 나온 것이다.

- **의미:** `i = i + 1`과 완전히 똑같다.
- **장점:** 코드가 짧아지고, 중복을 피할 수 있다. (`player_score += 1`)
- **확장:** `+= 3`, `+= 10` 처럼 1이 아닌 수도 더할 수 있습니다.

**`i++` (증감 연산자)**

"1 더하는 게 제일 많이 쓰이니까, 아예 전용 키를 만들자"고 해서 나온 가장 짧은 표현이다.
하지만 결과값을 따질 때 아주 독특한 성격을 가진다.

- **부수 효과 (Side Effect):** `i`가 1 증가한다. (나중에)
- **값 (Value):** **증가하기 전의 원래 값**이다.

이게 무슨 말일까? 코드로 확인해 보자.
```c
int i = 5;
int result = i++;  /* i++가 실행됨 */
```

-  **값(Result):** `i`가 증가하기 전 값인 `5`를 `result`에 준다. (스냅샷)
-  **부수 효과:** 그 후에 `i`는 `6`이 됩니다.

결과적으로 `result`는 5, `i`는 6이 된다.
마치 일단 현재 값을 쓰고, 뒤돌아서서 증가시키는 것과 같습니다.

### 16.6.3 전위(Pre) vs 후위(Post): 타이밍의 싸움

`++`가 변수의 앞에 붙느냐 뒤에 붙느냐에 따라 값을 사용하는 타이밍이 달라진다.

**혼자 쓸 때는 똑같다**

다른 식 없이 단독으로 한 줄에 쓸 때는 둘의 차이가 없다.

```c
i++;  /* i가 1 증가함 */
++i;  /* i가 1 증가함 (결과는 위와 똑같음) */
```

`for` 문의 증감식에서 `i++`를 쓰든 `++i`를 쓰든 결과가 같다.

**대입할 때는 다르다**

다른 변수에 값을 넣거나, 함수에 값을 넘겨줄 때는 순서가 중요해진다.

**1) 전위 증가 (`++i`): "변하고 나서 쓴다"**

- **순서:** 증가 먼저, 그 값을 사용
- **느낌:** "최신 버전"을 가져다 쓴다.

```c
int i = 5;
int a = ++i;
/* 1. i가 6이 된다. (증가) */
/* 2. a에 6이 들어간다. (사용) */
```

**2) 후위 증가 (`i++`): "쓰고 나서 변한다"**
* **순서:** 현재 값 사용, 나중에 증가
* **느낌:** "기존 값(백업)"을 먼저 주고, 뒤돌아서서 증가합니다.

```c
int i = 5;
int a = i++;
/* 1. a에 5가 들어간다. (사용 - 증가 전 값) */
/* 2. i가 6이 된다. (증가 - 뒷북) */
```

> [!NOTE]
> `a = i++` 같은 코드는 "한 줄에 두 가지 일(대입+증가)"을 하려다 보니 헷갈리는 것이다. 헷갈리면 두 줄로 나누면 된다.
>
> * `a = ++i;` 는 `++i; a = i;`로 쓰면 된다. 
> * `a = i++;` 는 `a = i; i++;`로 쓰면 된다. 

### 16.6.4 대입도 '식'이다: `while ((c = s[i]) != '\0')`

5장에서 우리는 대입(`=`)을 "오른쪽 값을 왼쪽에 저장하는 명령"이라고 배웠다.
하지만 C언어에서 대입은 단순한 명령이 아니라 값을 반환하는 수식이다.

즉, `x = 3`은 실행되면:
1.  **저장:** 변수 `x`에 3을 넣는다.
2.  **반환:** 그리고 값 3을 뱉어낸다.

이 특성을 이용하면 대입과 검사를 동시에 처리하는 전설적인 C언어 패턴이 가능해진다.

**전설적인 패턴의 해부**
```c
while ((c = s[i]) != '\0') {
    /* ... */
}
```

이 한 줄의 코드는 내부적으로 3단계로 실행된다.

1.  **대입:** `c = s[i]`가 먼저 실행되어, `c`에 문자가 담깁니다.
2.  **반환:** 대입식 전체의 결과값이 "방금 대입된 문자값"으로 변한다.
3.  **비교:** 그 값이 `\0`(null 문자)가 아닌지 검사한다.

**왜 괄호 `((...))`를 두 겹이나 썼을까?**

C언어의 연산자 우선순위 때문이다.
비교 연산자(`!=`)가 대입 연산자(`=`)보다 힘(우선순위)가 세다.

만약 괄호를 빼먹으면 이런 참사가 벌어진다.

```c
while (c = s[i] != '\0')  /* (X) 괄호 실수! */
```

1.  `s[i] != '\0'`을 **먼저** 계산해버린다. (결과는 참이면 1, 거짓이면 0)
2.  그 결과(0 또는 1)을 변수 `c`에 저장한다.
3.  **결과:** `c`에는 문자가 아니라 엉뚱한 숫자(1)만 들어가게 된다.

이런 실수를 막기 위해, 컴파일러도 괄호 없이 대입을 조건에 넣으면 경고를 보낸다.

> [!TIP]
> 의도를 괄호로 묶자
>
> 조건식 안에서 대입을 할 때는 "지금 일부러 대입하는 거야, 오타 아니야"라는 뜻으로 반드시 전체를 괄호로 감싸자.
>
> * `if (x = 3)` (X) 오타처럼 보임
> * `if ((x = 3))` (O) 의도된 코드로 보임


> [!TIP]
> 너무 어렵다면 풀어서 써도 된다.
>
> 이 패턴이 너무 복잡해 보인다면, 굳이 억지로 쓸 필요는 없다. 풀어서 쓰는 것이 가독성은 더 좋을 수 있다.
> ```c
> c = s[i];           /* 1. 먼저 대입하고 */
> while (c != '\0') { /* 2. 검사한다 */
>     /* ... */
>     ++i;            /* 3. 루프 변수 i의 값을 하나 증가시킨다 */
>     c = s[i];       /* 4. 루프 끝에서 다시 대입한다 (조금 번거로움) */
> }
> ```
> 하지만 남들이 짠 코드를 읽기 위해서라도 이 패턴(`while((c=...))`)은 꼭 눈에 익혀두어야 한다.

### 16.6.5 (중요) 한 문장 안에서 같은 변수를 여러 번 흔들지 말자

이 절이 이번 장에서 가장 중요하다. 별표를 5개 쳐도 좋다.

C언어는 최적화(속도)를 위해 컴파일러에게 엄청난 자유를 준다.
컴파일러는 계산 순서를 효율적으로 바꾸기 위해, 세미콜론(`;`)을 만나기 전까지는 변수 업데이트를 미룰 수도 있고, 당길 수도 있다.

그래서 한 문장 안에서 같은 변수를 건드리면 "정의되지 않은 동작(Undefined Behavior)"이라는 재앙이 일어난다.

**1. 대표적인 "악마의 코드"**

다음 코드는 실행 결과가 10일까, 11일까, 12일까?

```c
int i = 5;
int result = i++ + i++;  /* 절대 금지! */
```

* **컴파일러 A:** `5 + 5 = 10` (옛날 값을 쓰고 나중에 두 번 증가)
* **컴파일러 B:** `5 + 6 = 11` (하나 증가시키고 더함)
* **컴파일러 C:** 프로그램 강제 종료 (Crash)

정답은 아무도 모른다. 표준 문법이 결과를 보장하지 않기 때문이다. 내 컴퓨터에서 잘 돌아간다고 안심하면 안된다. 다른 컴퓨터에서는 폭발할 수 있다.

특히 배열 인덱스를 다룰 때 가장 많이 실수한다.

```c
x = a[i] = i++; /* (X) i가 먼저 증가할지, 인덱스를 먼저 잡을지 모름 */
```

**2. 안전 운전 5계명**

이 문제를 피하는 방법은 아주 단순하다. "한 줄에 욕심내지 않는 것"이다.

- **한 줄에 `++/--`는 한 번만:** 변수 하나당 한 번만 쓴다.
- **섞어 쓰기 금지:** `i`를 바꾸는(`i++`) 동시에 `i`를 읽는(`a[i]`) 코드를 한 줄에 쓰지 말자.
- **함수 인자 주의:** `add(i++, i++)`의 계산 순서도 랜덤입니다. 쓰지 말자.
- **헷갈리면 쪼개라:** 한 줄을 두 줄로 나누는 것이 부끄러운 게 아니다. 명확한 게 최고의 코드다.

```c
/* 나쁜 예 */
a[i++] = b[i];

/* 좋은 예 (명확함) */
a[i] = b[i];
i++;
```
**3. 단락 평가(Short-circuit)와 부수 효과**

`&&`(AND)와 `||`(OR) 연산자는 효율성을 위해 결과가 확실하면 뒤쪽을 실행하지 않는다.
여기에 부수 효과(`++`)를 넣으면, 코드가 실행될 때도 있고 안 될 때도 있는 유령 같은 버그가 생긴다.

```c
/* 위험한 코드 */
if (is_safe && count++ < 10) { ... }
```

- **`is_safe`가 참이면**: `count++`가 실행됨 (count 증가)
- **`is_safe`가 거짓이면**: 뒤는 볼 필요 없으므로 `count++` 실행 안 됨 (count 그대로)

논리 흐름에 따라 변수 값이 변했다 안 변했다 한다면, 디버깅하기 정말 어려워진다.
**조건식 안에서는 되도록 변수를 변경(`++`)하지 말자.**

