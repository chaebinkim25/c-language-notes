# 12. 문자와 문자열: `char`의 세계

10장에서 모든 값은 메모리에 저장된다는 것을 봤고, 11장에서 그 주소를 다루는 포인터를 배웠다. 
지금 시점에 남은 큰 질문이 하나 있다. "좋아, 숫자는 알겠는데... 글자는 메모리에 어떻게 저장하지?"

사실 컴퓨터 메모리에는 '글자'라는 개념이 없다. 오직 0과 1, 숫자뿐이다. C 언어에서 문자를 다루기위한 타입(`char`)는, 
내부적으로 어떤 글자를 어떤 숫자로 나타낼지 미리 약속해 놓고, 메모리에 저장하거나 계산할 때 조그만 정수 타입처럼 쓴다. 

글은 메모리에 어떻게 저장할까? 글자들을 메모리에 일렬로 늘어놓고, 뒤에 "여기서 끝!"을 의미하는 표식을 붙인다. 
문자와 문자열의 실체를 메모리 관점에서 적나라하게 확인해보자.

## 12.0 이 장의 목표

이 장을 끝내면 다음을 이해하고 구현할 수 있다. 

1. **`char`의 이중성**: `char`가 단순한 글자가 아니라, 산술 연산이 가능한 작은 정수임을 이해한다.
2. **값 vs 주소**: 문자 상수 `'A'`(정수)와 문자열 리터럴 `"A"`(메모리 주소)의 결정적 차이를 구분한다.
3. **문자열 처리**: 문자열 길이, 복사, 비교를 직접 구현해보며 문자열 처리 패턴을 내 것으로 만든다.
4. **안전한 코딩**: 배열 범위 초과와 문자열 표기 규칙 위반이 왜 시스템을 망가뜨리는지 알고 예방한다.

## 12.1 문자는 "특별한 것"이 아니라 결국 숫자다. 

데이터와 값 단원에서 우리는 중요한 진실을 마주했었다. 
> "메모리에는 0과 1만 있다. 그것을 무엇으로 보느냐는 우리의 몫이다."

만약 메모리 한 칸(1바이트)에 `01000001` (10진수 65)이라는 값이 들어있다고 가정해보자.

* 정수로 해석하면: 숫자 65가 된다.
* 문자로 해석하면: 알파벳 'A'가 된다. (ASCII 코드를 쓰는 컴퓨터에서)

C언어에서 `char` 타입은 사실 아주 작은 정수다. 그래서 C는 문자를 위한 별도의 복잡한 규칙을 만들지 않고, 정수와 똑같이 취급한다.

\[코드 예시: 정체 확인\]
```c
char ch = 'A'; /* ASCII 코드를 쓰는 컴퓨터에서는 65, EBCDIC 코드를 쓰는 컴퓨터에서는 193 */
```

문자가 곧 숫자이기에 가능한 마법도 있다. 바로 산술 연산이다.
```c
char next = 'A' + 1;       /* ASCII에서, 65 + 1 = 66 */
printf("%c", next);        /* 'B' (66은 ASCII에서 'B') */
```

> [!NOTE]
>
> "그럼 `'A'`는 무조건 `65`인가요?" 대다수 환경(ASCII 표준)에서는 그렇다.
> 하지만 드물게 다른 번호 체계(EBCDIC 등)를 쓰는 컴퓨터도 있다.
> 중요한 건 "`65`라는 숫자를 외우지 말라"는 것이다.
> 코드에 `char ch = 65;`라고 쓰는 것보다 `char ch = 'A';`라고 쓰는 것이 훨씬 읽기 좋고,
> 어떤 컴퓨터에서도 안전하게 `'A'`를 의미하게 된다. 컴퓨터에게 번호 찾기를 맡기자.

