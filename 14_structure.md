# 14. 구조체: 서로 관련된 값을 "한 묶음"으로 묶기

지금까지 우리는 데이터를 다룰 때 변수들을 낱개로 관리했다.

```c
int point_x[20];      /* x좌표 따로 */
int point_y[20];      /* y좌표 따로 */
```

하지만 현실의 데이터는 x좌표와 y좌표가 하나의 점을 구성하는 것처럼 세트로 움직입니다.

예제와 같이 좌표 데이터를 배열 2개로 따로따로 관리하면 어떨까? 

데이터를 관리할 때 각각의 배열에 동일하게 작업을 해야 한다.

```c
/* 0번 점과 1번 점을 바꾸기 */

/* x 좌표 바꾸기 */
int tmp = point_x[0];
point_x[0] = point_x[1];
point_x[1] = tmp;

/* y 좌표 바꾸기 */
tmp = point_y[0];
point_y[0] = point_y[1];
point_y[1] = tmp;
```

데이터가 많아져서 배열이 늘어날수록, 같은 코드를 반복해야 하는 횟수도 늘어난다. 

그래서 C언어는 서로 관련 있는 값들을 묶어서 한번에 처리할 수 있는 문법을 제공 한다. 그것이 바로 **구조체(struct)** 다. 

## 14.0 이 장의 목표

이 장을 마치면 여러분은 다음과 같은 능력을 갖게 된다. 

1. **구조체의 필요성 이해**: 뿔뿔이 흩어진 배열들(평행 배열)을 쓸 때 발생하는 치명적인 실수들을 이해하고 설명할 수 있다.
2. **나만의 타입 만들기**: `struct`로 관련된 데이터를 하나로 묶어 정의하고, 변수와 배열로 선언할 수 있다.
3. **멤버 접근을 자유자재로**: 점(`.`)과 화살표(`->`) 연산자를 정확히 구별하여 구조체 내부 값에 접근할 수 있다.
4. **효율적인 함수 전달**: 구조체를 함수에 보낼 때, 내용을 복사해서 보낼지(느림/안전) 주소만 보낼지(빠름/원본수정) 상황에 맞춰 선택할 수 있다.
5. **고급 메모리 관리**: 구조체 안에 포인터가 들어있을 때, 단순 대입(얕은 복사)가 왜 위험한지 이해하고 안전하게 복사하는 방법(깊은 복사)를 구현할 수 있다.
6. **미니 프로젝트**: 동적 할당과 구조체를 활용하여 기능(추가/검색/삭제)가 있는 실전 주소록을 완성한다.

## 14.1 왜 구조체가 필요한가: 평행 배열의 함정

좌표들을 저장하기 위해서 x좌표와 y좌표 배열을 각각 만드는 방식을 "평행 배열"이라고 한다. 
두 배열이 물리적으로는 떨어져 있고, 오직 인덱스 `0`, `1`, `2` 라는 숫자로만 논리적으로 연결된 상태다.

평행 배열의 가장 큰 문제는 데이터를 이동할 때 발생한다. 데이터를 x 좌표 순으로 정렬하기 위해 0번 점과 1번 점을 바꾸는 코드를 작성하고 있는 상황을 가정해보자.

```c
int tmp = x[0];
x[0] = x[1];
x[1] - tmp;

/* 잠깐 다른 일을 하다가 y를 바꾸는 것을 깜빡했다! */
```

프로그래머가 실수로 `x`만 바꾸고 `y`를 바꾸지 않는 순간 데이터 무결성이 깨진다. 
0번 인덱스와 1번 인덱스에는 잘못된 좌표가 저장되어 있다.

현실의 데이터는 하나로 묶여있는데, 코드에서 부자연스럽게 쪼개놓았기 때문에 실수에 취약해졌다.

## 14.2 구조체(struct) 정의: "데이터 설계도" 만들기
구조체는 서로 다른 여러 변수를 하나로 묶어 새로운 타입을 만드는 것이므로, 가장 먼저 해야 할 일은 "이 타입에 무엇무엇이 들어간다"라고 설계도를 그리는 것입니다.

### 14.2.1 가장 기본 형태: 설계도 그리기
```c
struct Point {
    int x;
    int y;
}; 
```
- `struct Point`: 이제부터 `int`나 `char`처럼 **`struct Point`**라는 이름의 새로운 자료형을 사용할 수 있다. (반드시 두 단어를 함께 써야 한다!)

- 멤버(member): 중괄호 `{}` 안에 있는 변수 `x`, `y`를 멤버라고 부른다.

- 주의: 여기까지는 **설계도**만 그린 것이다. 아직 메모리에 실제 공간은 생기지 않았다. 비유적으로 말하면, 붕어빵 틀만 제작했고, 아직 붕어빵은 굽지 않았다.

### 14.2.2 구조체 변수 만들기: 실체화 (Instance)

설계도가 완성되었으니, 이제 진짜 변수(인스턴스)를 찍어낼 수 있다.

```c
struct Point p; /* 변수 선언 */
```

이 코드가 실행되면 비로소 메모리에 `p`라는 이름의 실제 공간이 생긴다. 메모리 내부에서는 `x`와 `y`가 나란히 붙어 있는 하나의 큰 박스가 만들어지는 셈이다.

선언을 하면서, 배열처럼 중괄호 `{}`를 사용해 저장될 초기값들을 적을 수 있다. 설계도에 적힌 순서대로 값이 들어갑니다.

```c
/* x에 30, y에 40이 차례대로 들어간다 */
struct Point p2 = {30, 40};
```

> [!NOTE]
>
> 구조체를 정의할 때 왜 중괄호 뒤에 세미콜론 (`;`)을 붙일까?
>
> 함수는 `}` 뒤에 세미콜론을 붙이지 않는데, 구조체는 왜 붙일까? 그 이유는 구조체가 사실은 변수 선언문의 일부가 될 수 있기 때문이다.
> C 언어는 다음과 같이 구조체 정의와 변수 만들기를 한번에 할 수 있도록 허용한다.
> ```c
> struct Point {
>     int x;
>     int y;
> } p1, p2;   /* 정의하자마자 변수 p1, p2 생성! */
> ```
>
> 컴파일러 입장에서는 중괄호가 닫힌 뒤에 "변수 이름이 나올 수도 있다"고 기대하고 있다. 그래서 여기서 문장이 끝났다는 것을 명확히 알려주기 위해 세미콜론(`;`)이 반드시 필요하다.

## 14.3 `.` 연산자: 구조체 멤버에 접근하기

구조체 변수 안에 있는 멤버를 사용할 때는 마침표(`.`)를 찍는다. 이 점은 **"~의"** 라고 읽으면 이해하기가 훨씬 쉽다.

- `p.x`는 `p`의 `x`
- `p.y`는 `p`의 `y`

## 14.3.1 코드 예제로 확인하기
다음 코드를 보며 실제로 어떻게 사용하는지 확인해 본다.

```c
#include <stdio.h>

/* 1. 좌표를 나타내는 구조체 설계도 정의 */
struct Point {
    int x;
    int y;
};

int main()
{
    /* 2. 변수 선언: p라는 이름의 구조체 변수(상자) 생성 */
    struct Point p;

    /* 3. 멤버 접근: 점(.)을 찍어 값 대입 */
    p.x = 10;        /* "p의 x" 칸에 10을 넣음 */
    p.y = 20;        /* "p의 y" 칸에 20을 넣음 */
    
    return 0;
}
```

## 14.3.2 그림으로 보는 메모리 구조

변수 `p`가 하나의 큰 상자라면, `p.x`와 `p.y`는 그 상자 안에 나뉘어 있는 작은 상자다. 우리는 점(`.`)을 찍어서 상자 안의 특정 상자를 콕 집어 가리킬 수 있다.

```
[ 구조체 변수 p (큰 상자) ]
+---------------------+
|   x  :  10          |  <-- p.x (p의 x)
+---------------------+
|   y  :  20          |  <-- p.y (p의 y)
+---------------------+
```

> [!NOTE]
>
> `p.x`를 할때의 `.`은 멤버 접근 연산자라는 정식 이름을 가지고 있다. 첫번째 피연산자가 구조체 상자일 때, 두번째 피연산자는 그 구조체 상자의 멤버 이름이어야 하고,  
> 연산 결과는 구조체 상자의 해당 멤버 상자다.
 
## 14.3.3 이름표 붙여서 초기화하기 (C99)

구조체를 초기화할 때, 순서대로 값을 저장하는 대신 멤버의 이름을 (`.`) 뒤에 명시해서 값을 넣을 수도 있다. 전문용어로 지정 초기화자(Designated Initializer)라고 한다. 
마치 식당에서 메뉴를 주문할 때 "첫번째 거요"라고 하는 대신, "김치찌개 주세요"라고 이름을 콕 집어 말하는 것과 같다. 순서가 바뀌어도 상관없고, 읽기도 훨씬 편하다. 

```c
#include <stdio.h>

struct Point {
    int x;
    int y;
};

int main()
{
    /* 순서가 바뀌어도 이름(.y, .x)을 보고 찾아가므로 OK! */
    struct Point p = { .y = 20, .x = 10 }; 

    return 0;
}
```

## 14.4 `->` 연산자: 구조체 포인터로 멤버에 접근하기

프로그래밍을 하다 보면 구조체 변수의 주소를 포인터에 담아 사용하는 상황을 자주 마주하게 된다. 

### 14.4.1 구조체 포인터 만들기

```c
struct Point p;
struct Point *pp; /* 구조체(struct Point)를 가리키는 포인터 변수 선언 */

pp = &p;          /* pp가 p를 가리키게 설정 (p의 주소를 pp에 담음) */
```

포인터 `pp`를 이용해서 `p`의 멤버 `x`에 접근하려면 어떻게 해야 할까? 우리는 흔히 "주소로 가서(`*`) 멤버(`x`)를 고른다"는 생각에 다음과 같이 작성하기 쉽다.

### 14.4.2 흔한 실수: 연산자 우선순위 문제

```c
*pp.x = 10;     /* (X) 에러 발생! */
```

하지만 이 코드는 컴파일 에러가 난다. C 언어에서는 `*`(역참조)보다 `.`(멤버 접근)이 더 우선순위가 높기 때문이다. 

1. 컴파일러는 `pp.x`를 먼저 해석하려고 한다.
2. 하지만 `pp`는 포인터(주소)이지 구조체(상자)가 아니기 때문에 `x`라는 멤버가 없다.
3. 결국 포인터 `pp`에 `x`라는 멤버가 없다며 에러가 발생한다.

### 14.4.3 해결책 1: 괄호 사용 (불편함)

올바르게 작동하게 하려면 다음과 같이 괄호로 감싸서 먼저 주소를 따라가라(`*`)고 해줘야 한다. 

```c
(*pp).x = 10;
```

1. `(*pp)`: `pp`가 가리키는 곳으로 간다. 계산 결과는 구조체 상자 `p`.
2. `.x`: 그곳의 멤버 `x`에 접근한다. 계산 결과는 `p`의 `x` 상자.
3. `=`: 상자에 `10`을 저장한다.

하지만 멤버에 접근할 때마다 매번 괄호를 치는 것은 너무 번거롭다. 

### 14.4.4 해결책 2: 화살표 연산자 `->` (편리함)

그래서 C 언어는 이를 편하게 쓸 수 있는 화살표 연산자(Arrow Operator, `->`)를 제공한다. 

```c
pp->x = 10;    /* (*pp).x와 완전히 똑같은 뜻! */
pp->y = 20;
```

여기서 `->`는 모양 그대로 화살표라고 생각하면 된다. 

- `pp->x`: `pp`에서 출발해서 화살표를 따라가서 만나는 `x`

`pp->x`는 `(*pp).x`를 쓰기 편하게 만든 축약형(Syntactic Sugar)다. 

> [!IMPORTANT]
> 핵심 요약: 언제 무엇을 쓸까?
>
> 초보 시절에는 점(`.`)과 화살표(`->`) 중 무엇을 써야 할지 헷갈릴 수 있다. 딱 이것만 기억하면 된다. 
> | 변수의 정체 | 사용하는 연산자 | 예시 |
> | :--- | :---: | :--- |
> | **구조체 변수** (상자) | **`.`** (점) | `p.x` |
> | **구조체 포인터** (주소) | **`->`** (화살표) | `pp->x` |

## 14.5 구조체를 함수에 넘기기: 값으로? 주소로?

구조체를 함수로 넘기는 방식은 크게 두 가지가 있다. 그중 첫 번째는 값을 통째로 복사해서 넘기는 방식이다.

### 14.5.1 값으로 넘기기: "통째 복사" (Call by Value)

구조체 변수를 함수의 인자로 넘기면, 변수 안에 들어있는 **모든 멤버의 값이 그대로 복사**되어 전달된다. 
비유하자면 마치 팩스로 문서를 보낼 때와 같다. 상대방에게 사본이 날아가지만, 원본 문서는 여전히 내 손에 남아있어 훼손되지 않는다.

```c
#include <stdio.h>

struct Point {
    int x;
    int y;
};

/* 구조체를 받아서, 새로운 구조체를 반환하는 함수 */
struct Point add_point(struct Point a, struct Point b) {
    struct Point r;
    
    /* a와 b는 원본 p1, p2의 '복사본' */
    r.x = a.x + b.x;
    r.y = a.y + b.y;
    
    return r; /* 계산된 구조체 r을 통째로 복사해서 반환 */
}

int main()
{
    struct Point p1 = {10, 20};
    struct Point p2 = {30, 40};
    
    /* p1, p2의 값이 복사되어 전달됨. p1, p2 원본은 안전함 */
    struct Point result = add_point(p1, p2); 
    
    return 0;
}
```

이 방식이 실행될 때 메모리에서는 **변수 전체의 복사**가 일어난다.

1. `main` 함수의 `p1`, `p2` 값이 `add_point` 함수의 매개변수 `a`, `b`라는 새로운 공간으로 **복사**된다.
2. `add_point` 안에서 `a`나 `b`를 수정해도, `main`의 `p1`, `p2`에는 아무런 영향이 없다.

장점과 단점은 다음과 같이 정리된다. 

| 구분 | 설명 |
| :--- | :--- |
| **장점: 안전성** | 함수 안에서 데이터를 지지고 볶아도 원본(`main`에서의 변수)은 절대 변하지 않는다. |
| **장점: 다중 반환** | C언어 함수는 원래 값 하나만 반환(`return`)할 수 있지만, 구조체를 이용하면 `x`, `y` 등 여러 값을 한 묶음으로 묶어 한 번에 반환하는 효과를 낼 수 있다. |
| **단점: 성능 부담** | 구조체의 크기가 매우 크다면(예: 멤버가 100개), 함수를 호출할 때마다 이걸 다 복사해야 하므로 속도가 느려지고 메모리를 많이 쓴다. |

> [!TIP]
> 배열을 복사본으로 보내고 싶다면?
>
> 배열은 함수로 보낼 때 무조건 주소가 넘어가서 원본이 위험할 수 있다. 꼭 배열 내용을 복사본으로 보내고 싶다면 어떻게 해야할까?
> 정답은 구조체라는 상자에 담아서 보내기다.
>
> ```c
> struct Box {
>     int arr[5]; /* 배열을 구조체 안에 넣음 */
> };
>
> void change_array(struct Box b) 
> {
>     b.arr[0] = 999; /* 복사본의 값을 바꿈 */
> }
> 
> int main() 
> {
>     struct Box myBox = { {1, 2, 3, 4, 5} };
>     
>     change_array(myBox); /* 구조체니까 통째로 복사됨! */
>     
>     /* 원본은 바뀌지 않음 */
>     
>     return 0;
> }
> ```
> 배열이 함수 매개변수로 전달되면 주소값으로 취급되지만, 구조체 안에 들어가는 순간 구조체의 일부가 된다. 구조체는 함수로 갈 때 통째로 복사되므로, 그 안의 배열도 덩달아 통째로 복사된다.

## 14.5.2 주소로 넘기기: “원본을 직접 만지기” (Call by Address)

구조체의 사이즈가 클 때는 복사하는 비용 때문에 속도 저하가 염려되어 부담스럽다. 
그리고 함수 안에서 원본 데이터를 직접 수정해야 할 때도 있다. 
그럴 때는 구조체의 값 대신 **주소(포인터)**를 넘긴다.

### 1. 코드 예제: 원본 수정하기
```c
#include <stdio.h>

struct Point {
    int x;
    int y;
};

/* 구조체의 '주소'를 받아서, 원본을 직접 수정하는 함수 */
void move_point(struct Point *p, int dx, int dy) {
    /* 포인터로 받았으므로 점(.) 대신 화살표(->)를 사용한다 */
    p->x = p->x + dx;
    p->y = p->y + dy;
}

int main(void) {
    struct Point p1 = {10, 20};

    /* 중요: p1의 '주소(&)'를 넘겨야 한다 */
    move_point(&p1, 5, 5); 

    /* 이제 p1은 {15, 25}로 바뀌어 있다 */
    
    return 0;
}
```

### 2. 메모리 동작 원리

이 방식은 함수 `move_point`의 포인터 변수 `p`가 `main` 함수에 있는 `p1`을 **가리키고(Pointing)** 있기 때문에 가능하다. 함수 안에서 수정한 내용이 원본에 그대로 반영된다.

* **복사되는 것:** 구조체 전체가 아니라, **주소값 하나**(4바이트 혹은 8바이트)만 복사된다.
* **접근 방식:** "주소를 따라가서(`->`)" 값을 고친다.

### 3. 장점과 단점

| 구분 | 설명 |
| :--- | :--- |
| **장점: 속도** | 구조체 멤버가 100개든 1000개든, 주소 하나만 넘어가므로 복사 비용이 거의 0에 가깝다. (고속도로 하이패스!) |
| **장점: 원본 수정** | 함수가 원본의 위치를 알고 있으므로, 값을 직접 바꿀 수 있다. |
| **단점: 위험성** | 함수 안에서 실수로 값을 바꾸면, `main`에 있는 원본 데이터가 훼손된다. (포인터 사용의 책임) |

> [!TIP]
> 성능과 안전, 둘 다 잡으려면? (const 포인터)
>
> 고민: 구조체가 커서 주소로 넘기고는 싶은데, 함수가 안전하게 원본을 보존하려면 어떻게 할까?
>
> 그럴 때는 `const` 키워드를 붙여서 "읽기 전용 포인터"로 만들면 된다. C언어 상급자가 즐겨 쓰는 **표준 패턴**이다.
>
> ```c
> /* 해석: "원본을 보여는 줄게(주소), 하지만 건드리진 마(const)" */
> void print_point(const struct Point *p) {
>     /* p->x = 10;      (X) 컴파일 에러! */
>     /* 컴파일러가 "약속(const)을 어겼다"며 빨간 줄을 그어 원본을 지켜준다. */
> }
> ```
> **결론:** 구조체의 크기가 조금이라도 크다면, 무조건 `const struct ... *` 형태로 넘기자!


## 14.6 구조체는 통째로 대입이 된다: 배열과의 결정적 차이

8장에서 배웠듯이, C언어에서 배열은 변수끼리 직접 대입할 수 없었다.

```c
int arr1[5] = {1, 2, 3, 4, 5};
int arr2[5];

/*arr2 = arr1;   (X) 컴파일 에러! 배열은 대입 불가 */
```

하지만 구조체는 가능하다. 배열과 구조체의 결정적인 차이다. 구조체 변수는 컴파일러가 **"하나의 값"** 으로 취급하기 때문에, `=` 연산자를 쓰면 내용물이 통째로 복사된다.

**멤버가 배열이어도 복사된다!**

```c
struct Contact {
    char name[20]; /* 배열도 멤버로 포함 */
    int phone;
};

int main(void) {
    /* 1. 1번 연락처 정보 생성 */
    struct Contact c1 = { "Alice", 1012345678 };
    struct Contact c2;

    /* 2. 대입 연산: c1의 모든 내용이 c2로 복사됨 */
    c2 = c1; /* (O) OK! */

    /* c2에는 { "Alice", 1012345678 }가 저장되어 있다. */
    
    return 0;
}
```

여기서 `name`은 배열로 분명 대입이 안되지만, `s2 = s1`을 실행하는 순간 `s1.name`의 문자열들이 `s2.name`으로 완벽하게 복사된다.

**원리:** 메모리에서 구조체 상자에 해당하는 모든 것이 그대로 복사된다. 낱개의 배열은 대입이 안 되지만, 구조체라는 **'박스'** 안에 담긴 배열은 박스를 통째로 옮길 때 함께 복사되는 원리다.

구조체는 "하나의 묶음"으로 취급되므로, 필요하다면 **함수에서 구조체를 통째로 반환(return)**하여 여러 값을 한 번에 내보내는 것도 가능하다

> [!CAUTION]
> 포인터가 들어있다면? (얕은 복사)
>
> 구조체 멤버 중에 **포인터**가 있다면 이야기가 달라진다.
> ```c
> struct Data {
>     int *ptr; // 포인터 멤버
> };
> ```
> 이 경우 `b = a;`를 하면, 포인터가 가리키는 실제 데이터(목적지)가 복사되는 게 아니라, 주소값(번호표)만 복사됩니다. 전문용어로 얕은 복사(Shallow Copy)라고 부른다.
>
> * **문제점:** 결과적으로 `a`와 `b`가 **같은 메모리 공간을 공유**하게 된다.
>
> * **위험성:** 한쪽(`a`)에서 데이터를 수정하거나 메모리를 해제하면, 다른 쪽(`b`)도 영향을 받거나 에러가 발생한다.
>
> 중요한 문제이므로 **14.10절**에서 별도로 자세히 다룬다.


## 14.7 구조체를 반환하는 함수

함수가 `int`나 `char`를 반환하듯이, 구조체도 **반환값(return value)**이 될 수 있다.
앞서 14.6절에서 "구조체는 통째로 대입된다"는 특성을 봤는데, `return`도 대입과 똑같다. 구조체가 통째로 복사되어 호출한 곳으로 전달된다.

주로 구조체를 초기화해서 만들어주는 **"생성 함수"**를 만들 때 유용하다.

**구조체 생성기 만들기 (Factory Pattern)**

매번 `struct Point p; p.x=1; p.y=2;` 처럼 일일이 값을 채우는 것은 번거롭다. 좌표만 주면 완성된 구조체를 툭 던져주는 함수를 만들어본다.

```c
struct Point {
    int x;
    int y;
};

/* x, y를 받아서 완성된 Point 구조체를 반환하는 함수 */
struct Point make_point(int x, int y) {
    struct Point temp; /* 1. 임시 구조체 생성 */
    
    temp.x = x;        /* 2. 내용 채우기 (조립) */
    temp.y = y;
    
    return temp;       /* 3. 구조체를 통째로 복사해서 반환 */
}

int main(void) {
    struct Point p1, p2;

    /* 함수가 조립해준 구조체를 받아서 저장 */
    p1 = make_point(10, 20);
    p2 = make_point(30, 40);

    return 0;
}
```

이렇게 하면 `make_point` 함수가 구조체라는 "완제품"을 조립해서 반환해 준다. 메인 함수 코드가 훨씬 깔끔해졌다.

> [!CAUTION]
> 절대 하지 말아야 할 것: "지역 변수 주소 반환"
>
> 초보자가 가장 많이 하는 치명적인 실수가 있다.
> "구조체를 통째로 반환하면 복사 비용이 드니까, 포인터(주소)로 반환해야지!"*라고 생각하고 다음과 같이 짜는 것이다.
>
> ```c 
> /* 절대 따라하지 마세요! */
> struct Point *bad_make_point(int x, int y) {
>     struct Point temp; /* 지역 변수 생성 */
>        
>     temp.x = x;
>     temp.y = y;
>        
>     return &temp;      /* (X) 지역 변수의 주소를 반환하면 안 됨! */
> }
> ```
>
> 함수 안에서 만든 변수 `temp`는 지역 변수(Local Variable)다. 지역 변수는 함수가 끝나는 순간(`return` 직후) 메모리에서 사라집니다.
> 그런데 그 사라진 곳의 주소를 반환했으니, `main` 함수에서 이 주소를 받아봤자 이미 '철거된 집'의 주소를 들고 있는 셈이다.
>
> **댕글링 포인터(Dangling Pointer):** 유효하지 않은 메모리를 가리키고 있는 포인터를 말한다.
> 
> **결과:** 운 좋게 잠깐 작동할 수도 있지만, 다른 함수가 그 메모리 자리를 덮어쓰는 순간 엉뚱한 값으로 변하거나 프로그램이 강제 종료된다. 시한폭탄과 같다.
> 
> **결론:**
> 1. 구조체를 반환할 때는 그냥 **값으로(통째로)** 반환한다. (가장 안전하고 깔끔하다.)
> 2. 함수 안의 **지역 변수 주소는 절대 반환하지 않는다.**


## 14.8 이름 없이 즉석에서 만들기: 복합 리터럴 (C99)

숫자 `10`을 함수에 보낼 때, 우리는 굳이 변수에 담지 않고 바로 보낸다.

```c
int a = 10;
func(a);   /* 이렇게도 쓰지만 */
func(10);  /* 보통은 이렇게 바로 쓴다. */
````

그렇다면 구조체는 어떨까?
과거(C99 표준 이전)에는 구조체 값을 함수로 보내려면 반드시 변수를 선언해야 했다. 
하지만 C99부터는 변수 없이 구조체 값을 즉석에서 만들어 사용할 수 있다.

전문용어로 복합 리터럴(Compound Literal)이라고 부른다.

### 14.8.1 문법 생김새

캐스팅 연산자와 초기화 리스트를 합친 모양이다.
```c
(타입) { 초기값 목록 }
```

예를 들어 `struct Point`라면 다음과 같습니다.
```c
(struct Point) { 10, 20 }
```

### 14.8.2 언제 쓰면 좋을까?

가장 빛을 발하는 순간은 **함수에 값을 전달할 때**다. 1회용으로 쓰고 버릴 구조체라면 굳이 변수 이름을 지어주고 선언할 필요가 없다.

**옛날 방식 (변수 선언 필수)**
```c
struct Point p = { 10, 20 }; /* 1. 변수를 만들고 초기화한 뒤 */
point_fun(p);                /* 2. 그 변수를 전달 */
```

**복합 리터럴 방식 (즉석 생성)**
```c
/* 변수 없이 값(리터럴)만 바로 던진다! */
point_fun( (struct Point){ 10, 20 } );
```

코드가 훨씬 간결해졌다. 불필요한 변수이름(`p`)를 고민할 필요도 사라졌습니다.

### 14.8.3 가독성 높이기: 지정 초기화자와 섞어 쓰기

앞서 배운 '지정 초기화자(`.x = ...`)'와 함께 쓰면 가독성이 극대화된다. 어떤 값이 `x`이고 `y`인지 명확해진다.

```c
/* 순서 상관없이 명확하게 전달 */
set_position( (struct Point){ .y = 50, .x = 100 } );
```

### 14.8.4 반환값으로 바로 사용하기: "한 줄의 미학"

복합 리터럴은 함수에서 값을 반환할 때도 사용할 수 있다.
앞서 `14.7절`에서 만들었던 `make_point` 함수를 다시 소환해 보자. 원래는 이렇게 생겼었다.

**기존 방식: 임시 변수 사용**
```c
struct Point make_point(int x, int y) {
    struct Point temp;  /* 1. 임시 변수 만들고 */
    temp.x = x;         /* 2. 값 채우고 */
    temp.y = y;
    return temp;        /* 3. 반환 */
}
```
사실 우리는 `temp`라는 변수 이름이 딱히 필요 없다. 그냥 "이 값들로 채운 구조체를 반환해!"라고만 하면 되기 때문이다. 복합 리터럴을 쓰면 이렇게 변신한다.

**복합 리터럴 방식: 즉석 반환**
```c
struct Point make_point(int x, int y) {
    /* 만들자마자 바로 반환! x좌표와 y좌표를 헷갈릴 일도 없음 */
    return (struct Point){ .x = x, .y = y };
}
```

군더더기가 싹 사라졌다. 복합 리터럴을 활용하면, 불필요한 변수 선언을 줄이고 코드의 의도("이 값으로 구조체를 만들어서 리턴해라")를 더 직관적으로 표현할 수 있다.


> [!NOTE]
>
> `.x = x`? 이름이 똑같은데 괜찮나?
>
> 코드를 보다 보면 문득 의문이 들 수 있다. "앞에도 `x`가 있고 뒤에도 `x`가 있는데, 컴퓨터가 안헷갈리나?"
> ```c
> (struct Point){ .x = x, .y = y }
> ```
>
> 결론부터 말하면 전혀 헷갈려 하지 않는다. 두 `x`는 소속이 완전히 다르기 때문이다.
> 1. 앞쪽의 `.x` (목적지):
>    앞에 점(`.`)이 붙어있는데, 이것은 "구조체 설계도 안에 있는 멤버 이름 x"를 뜻한다.
>    컴파일러는 점을 보는 순간 구조체 정의(`struct Point { ... }`) 안에서만 이름을 찾는다.
> 2. 뒤쪽의 `x` (데이터):
>    여기에는 점이 없다. "함수 매개변수로 들어온 변수 `x`"를 뜻한다.
>    현재 실행 중인 함수(`make_point`) 안에서 값을 찾는다.
> 비유하자면, `.x`는 관공서 서류 양식에 인쇄된 "이름" 칸이고, `x`는 그 칸에 우리가 펜으로 적어 넣는 실제 이름이다.
> `.x = x`는 구조체 안의 `x`라는 이름표가 붙은 칸에, 매개변수로 받은 `x` 값을 채워 넣어라는 명확한 명령이다.


> [!NOTE]
>
> 리터럴(Literal)이 뭐지?
>
> 리터럴이라는 용어가 낯설 수 있다. 어렵게 생각하지 말고 값 자체라고 생각하면 된다.
> 
> **정수 리터럴:** `10`, `100` 처럼 이름 없이 그 자체로 숫자인 것.
> 
> **복합 리터럴:** `(struct Point){10, 20}` 처럼 이름 없이 그 자체로 구조체 값인 것.
>
> **심화: 주소도 따올 수 있다?**
> 복합 리터럴은 메모리에 실체가 생성된다. 그래서 주소 연산자(`&`)를 붙일 수도 있다.
>
> ```c
> /* 구조체 포인터를 받는 함수에도 바로 던질 수 있음! */
> move_point( &((struct Point){10, 20}), 5, 5 );
> ```
>
> 이 코드는 "이름 없는 구조체를 만들고, 그 주소를 바로 넘겨라"라는 뜻입니다. 아주 강력한 기능이다.


## 14.9 태그 없는 구조체 (Anonymous Structure)

지금까지 우리는 구조체를 만들 때 항상 이름을 지어줬다.
```c
struct Point { ... }; /* 'Point'라는 이름표(태그) 부착 */
```

그런데 가끔은 구조체의 이름(태그)을 생략하고, 괄호만 덜렁 쓰는 경우가 있다. 전문 용어로 **태그 없는 구조체(익명 구조체)**라고 한다.

```c
struct {
    int x;
    int y;
} p1;
```

`struct` 뒤에 이름이 없다. 그리고 닫는 중괄호 `}` 뒤에 변수 `p1`을 바로 선언했다.
**"구조체 설계도를 만듦과 동시에 변수 p1을 찍어내고, 설계도는 바로 폐기하겠다"**는 뜻이다.

### 14.9.1 언제 쓸까? (용도: Singleton)

"이름을 안 지으면 불편하지 않나?" 그렇다. 나중에 이 타입으로 다른 변수를 또 만들 수가 없다.
하지만 "이 프로그램에서 딱 하나만 존재하는 객체"를 만들 때는 오히려 이름 짓는 게 귀찮을 수 있다.

가장 대표적인 예가 설정(Configuration)이나 전역 상태(Global State) 관리 변수다.

```c
/* 게임 설정 변수: 프로그램 전체에서 딱 하나만 있으면 됨 */
struct {
    int volume;
    int difficulty;
    char user_name[30];
} settings;

int main(void) {
    settings.volume = 80;     /* 바로 사용 가능 */
    settings.difficulty = 2;
    
    return 0;
}
```

굳이 `struct Settings`라고 타입을 정의하고, 다시 `struct Settings current_settings;`라고 선언하는 두 단계를 거칠 필요가 없다. 어차피 설정 변수는 하나뿐이기 때문이다.

### 14.9.2 치명적인 단점: "재사용 불가"

태그가 없다는 것은 재사용할 수 없다는 뜻이다.

1. **변수 추가 불가:** 나중에 똑같은 모양의 변수를 또 만들 수 없다. (설계도를 버렸기 때문이다!)
2. **함수 매개변수로 사용 불가:** 함수 인자로 넘기려면 타입 이름이 필요한데, 이름이 없으니 받을 방법이 없다.

   ```c
   /* error: 인자의 타입을 적을 수가 없음 (이름이 없어서...) */
   void func( ??? p ) { ... } 
   ```

그래서 태그 없는 구조체는 보통 `main` 함수 안에서 잠깐 쓰고 버리거나, 전역 변수들을 깔끔하게 묶어주는 용도로만 제한적으로 사용한다.

### \[심화\] 구조체 안에 숨기기 (C11 표준)

구조체 안에 또 구조체를 넣을 때, 태그뿐만 아니라 **변수 이름까지 생략**해 버릴 수 있다. (C11부터 지원)

```C
struct Rect {
    /* 1. 이름 없는 구조체 정의 */
    struct { 
        int x, y; 
    }; /* 2. 변수 이름도 안 씀! (익명 멤버) */
    
    int width, height;
};

/* 사용할 땐 편하게(Flat), 초기화할 땐 명확하게(Group)! */
struct Rect r = { {10, 20}, 100, 200 };
```

이렇게 하면, 중첩된 구조체임에도 불구하고 멤버에 **직접 접근**할 수 있다.

* **기존 방식:** `r.inner.x` (중간에 변수명을 거쳐야 한다.)
* **C11 방식:** `r.x` (마치 `Rect`의 멤버인 것처럼 바로 접근!)

  ```C
  r.x = 10; /* r.inner.x 가 아니라 그냥 r.x로 접근 가능! */
   ```

이 기법은 데이터의 계층을 나누면서도, 코드를 짤 때는 계층이 없는 것처럼 편하게 쓰고 싶을 때(예: UI 프로그래밍, 그래픽 라이브러리) 아주 자주 사용된다.

> [!NOTE]
>
> 이 문법이 C11 표준에 들어온 진짜 이유는 변수에 별명을 붙이기 위해서다. 가장 대표적인 예시가 벡터나 색상 처리다.
>
> 상황: 배열로도 쓰고 싶고, 변수 이름으로도 쓰고 싶다!
> 
> - 반복문 돌릴 때는 배열(`v[0]`, `v[1]`)이 편하다.
> - 직관적으로 쓸 때는 이름(`v.x`, `v.y`)이 편하다.
> 
> 두마리 토끼를 잡기 위해 뒤에서 배울 공용체 (`union`)과 익명 구조체가 필요하다.
>
> ```c
> struct Vector {
>     union {
>         struct { int x, y, z; };   /* 익명 구조체: 이름으로 접근 */
>         int data[3];               /* 배열: 인덱스로 접근 */
>     };
> };
> 
> struct Vector v;
> v.x = 10;        /* 이름으로 접근 */
> v.data[1] = 20;  /* 배열로 접근 (y값 수정됨) */
> ```
>
> 만약 `struct { int x, y, z; } p;` 처럼 이름을 지어줬다면, `v.p.x`라고 써서 접근이 귀찮아지게 된다.


## 14.10 구조체 배열: "좌표 여러 개"를 한 번에

좌표 1개가 아니라, 3개를 관리해야 한다면 어떻게 할까? `struct Point p1, p2, p3;` 처럼 변수를 따로 만드는 건 비효율적이다. 우리에겐 **배열**이 있기 때문이다.

```c
struct Point triangle[3]; /* 좌표 3개가 들어가는 배열 생성 */
```

이제 `triangle`은 `struct Point` 3개가 연달아 붙어 있는 배열이 된다. 배열이므로 인덱스(`[]`)를 이용해서 `for`문으로 쉽게 관리할 수 있다.

```
/* 두 점을 더하는 함수 (복합 리터럴 사용하여 즉석 반환) */
struct Point point_sum(struct Point p1, struct Point p2)
{
    return (struct Point) { p1.x + p2.x, p1.y + p2.y};
}

/* 점을 나누는 함수 */
struct Point point_divide(struct Point p, int d)
{
    return (struct Point) { p.x / d, p.y / d};
}

int main()
{
    /* 초기화: 배열의 중괄호 {} 안에, 구조체의 중괄호 {}를 넣는다 */
    struct Point triangle[3] = {
        { 2, 2 },  /* triangle[0] */
        { 5, 9 },  /* triangle[1] */
        { 9, 5 }   /* triangle[2] */
    };
    
    struct Point sum = { 0, 0 }; /* 누적할 변수는 0으로 초기화 */
    struct Point center;
    int i;
    
    for (i = 0; i < 3; i++) {
        /* triangle[i]은 "구조체 하나"다. 통째로 넘긴다. */
        sum = point_sum(sum, triangle[i]);
    }

    center = point_divide(sum, 3);
    /* 중심 좌표를 구했다! */

    return 0;
}
```

`triangle[i].x` 코드는 세 단계로 해석된다.

1.  `triangle`: 배열의 시작을 찾는다.
2.  `[i]`: `i`번째 상자로 이동한다. (여기서는 구조체 하나가 선택됨)
3.  `.x`: 그 구조체 상자 안에서 **x(멤버)**를 꺼낸다. 

**triangle 배열 메모리 구조**
```
+--------------+--------------+--------------+
|  x, y (0번)  |  x, y (1번)  |  x, y (2번)  |
+--------------+--------------+--------------+
       ↑              ↑              ↑
  triangle[0]    triangle[1]    triangle[2]
```

이 예제에는 치명적인 한계가 하나 있다. "점의 개수가 3개로 고정되어 있다"는 것이다.

만약 사용자가 "나는 5각형(점 5개)을 입력하고 싶은데?"라고 하거나 "100각형을 만들래!"라고 한다면? `struct Point triangle[3];` 만으로는 해결할 수 없다.

그렇다고 `struct Point poly[1000];` 처럼 무작정 크게 잡는 건 메모리 낭비다. 여기서 필요한 것이 바로 동적 할당(Dynamic Allocation)이다. 
다음 절에서 "필요한 만큼만 구조체 배열 만들기"를 배워본다.


## 14.11 구조체를 동적으로 만들기: `malloc`

앞 절(14.10)에서 제기했던 *"5각형, 100각형은 어떻게 만들지?"* 라는 질문에 대한 해답이다.
13장에서 배웠던 동적 할당(Dynamic Allocation)을 구조체에 적용하면, 실행 중(Run-time)에 우리가 원하는 크기만큼 구조체를 찍어낼 수 있다.

구조체도 `int`나 `double`과 똑같다. `sizeof`로 크기만 구해서 `malloc`에 넘겨주면 메모리를 빌릴 수 있다.

### 14.11.1 구조체 한 개 동적 할당

먼저 구조체 하나를 **힙(Heap)** 영역에 만드는 방법이다. `malloc`과 `free` 함수를 쓰기 위해서는 `<stdlib.h>`가 `#include`되어 있어야 한다.
```c
#include <stdlib.h> /* malloc, free */
```

`malloc`으로 메모리를 할당받고, 다 쓴 메모리는 `free`로 반납한다. 

```c
struct Point *p;

/* 1. 구조체 크기(sizeof)만큼 힙에서 빌려온다 */
p = (struct Point *)malloc(sizeof(struct Point));

if (p == NULL) return 1; /* 메모리 부족 예외 처리 */

/* 2. 포인터이므로 점(.) 대신 화살표(->)로 접근 */
p->x = 10;
p->y = 20;

/* ... */

/* 3. 다 썼으면 반드시 반납 */
free(p); 

return 0;
```
* **`sizeof(struct Point)`**: 구조체 상자 전체 크기를 계산한다.
* **`->` 연산자**: `p`는 포인터(주소)이므로 멤버에 접근할 때 화살표를 쓴다.

> [!CAUTION]
> **패딩(Padding)**
> 
> 구조체의 크기를 `int(4) + int(4) = 8바이트`라고 단정 짓고 `malloc(8)` 처럼 직접 숫자를 쓰면 위험하다.
> 컴퓨터가 성능을 위해 멤버 사이에 빈 공간(패딩)을 넣을 수 있기 때문이다.
> 항상 **`sizeof(struct ...)`**를 믿자.


### 14.11.2 구조체 배열 동적 할당: "원하는 만큼만!"

이제 앞 절의 **다각형(Polygon)** 문제를 해결해본다. 사용자에게 점의 개수(`n`)를 입력받아, 딱 그만큼만 배열을 만드는 것이다.
놀라운 점은, `malloc`으로 빌린 포인터도 배열처럼 대괄호 `[]`를 쓸 수 있다는 사실이다.

```
struct Point *poly; /* 배열이 아니라 '포인터'로 선언 */
int n = 100;        /* 배열의 원소 개수 */
int i;

/* 핵심: 구조체 크기 * 개수(n) 만큼 통째로 할당 */
poly = (struct Point*)malloc(sizeof(struct Point) * n);

for (i = 0; i < n; i++) {
    /* poly[i]는 i번째 좌표 */
    poly[i].x = i;
    poly[i].y = i;
}

/* {0, 0}부터 {99, 99}까지 일렬로 늘어선 좌표 100개를 얻었다. */

free(poly); /* 한 번에 반납 */
```

> [!NOTE]
>
> 왜 화살표(`->`)가 아니라 점(`.`)이지?
>
> 이 부분에서 혼동이 많이 온다. `poly`는 포인터인데 왜 점을 찍을까?
>
> * **`poly`**: 포인터 (주소)
> * **`poly[i]`**: 포인터를 타고 가서 만난 **i번째 구조체 상자 (값)**
>
> `[]`를 쓰는 순간 이미 주소를 타고 들어간 상태(Dereference)가 된다.
> 따라서 `poly[i]`는 구조체 변수 그 자체와 같으므로 **점(`.`)**을 사용해야 한다.

### 14.11.3 멤버가 포인터라면? (이중 할당)

만약 구조체 안에 포인터가 있다면 상황이 조금 복잡해진다. 구조체 몸통을 빌린다고 해서, 그 안의 포인터가 가리킬 공간까지 자동으로 생기는 건 아니기 때문이다.

```c
struct Polygon {
    int count;              /* 점의 개수 */
    struct Point *vertices; /* 점들의 배열을 가리킬 포인터 */
};
```

이때는 두 번의 `malloc`과 두 번의 `free`가 필요하다.

```c
struct Polygon *shape;

/* 1. 구조체 몸통(count, vertices 포인터 변수) 생성 */
shape = malloc(sizeof(struct Polygon)); 

shape->count = 100;

/* 2. 멤버(vertexes)가 가리킬 실제 배열 공간 생성 */
shape->vertices = malloc(sizeof(struct Point) * shape->count); 

/* ... */

/* 3. 해제는 생성의 역순! (매우 중요) */
free(shape->vertices); /* 안쪽(좌표 배열) 먼저 해제 */
free(shape);           /* 바깥쪽(몸통) 해제 */

return 0;
```

메모리 구조를 그림으로 그리면 다음과 같이 떨어져 있는 두 구조가 된다. 

```
[ Stack ]          [ Heap 영역 1 ]              [ Heap 영역 2 ]
+-----------+      +------------------+         +-------------------------+
|   shape   | ---> | count      : 5   |         | Point[0] (x, y)         |
+-----------+      | *vertices        | --+     | Point[1] (x, y)         |
                   +------------------+   |     | Point[2] (x, y)         |
                                          +---> | Point[3] (x, y)         |
                                                | Point[4] (x, y)         |
                                                +-------------------------+
                    (1. 몸통 할당)               (2. 멤버 할당)
```

> [!CAUTION]
> 해제 순서를 지키자!
>
> 만약 몸통(`shape`)을 먼저 `free(shape)` 해버리면 어떻게 될까?
> `shape`이 사라지면서 그 안에 적혀있던 `vertices`의 주소도 같이 증발한다.
> `vertices`가 가리키던 메모리는 주소를 복사해놓지 않았다면 영원히 찾을 수 없는 미아가 된다 (**메모리 누수**).
> **반드시 안쪽 내용물부터 비우고, 마지막에 그릇을 버려야 한다.**


## 14.12 구조체 안에 포인터가 있을 때: 얕은 복사의 함정

14.11에서 만든 `struct Polygon`을 다시 보자. 

```c
struct Polygon {
    int count;              /* 점의 개수 */
    struct Point *vertices; /* 점들의 배열을 가리킬 포인터 */
};
```

이 구조체는 "점들의 좌표 데이터"를 직접 가지고 있는 게 아니다. 점들이 저장된 "메모리 주소"만 `vertices`라는 이름으로 들고 있다.

### 14.10.1 얕은 복사(Shallow Copy)가 뭐가 문제인가?

우리는 14.6절에서 "구조체는 `b = a;` 처럼 대입하면 통째로 복사된다"고 배웠다.
하지만 멤버가 **포인터**일 때는 이것이 재앙을 부른다.

```c
struct Polygon p1, p2;

/* 1. p1 생성: 삼각형(점 3개)을 위한 메모리 할당 */
p1.count = 3;
p1.vertices = malloc(sizeof(struct Point) * 3);

/* ... 좌표 설정 ... */

/* 2. 구조체 대입 (문제가 발생하는 지점!) */
p2 = p1; 

/* ... */

/* 3. 해제 시도 (프로그램 사망) */
free(p1.vertices); /* p1 반납 (성공) */
free(p2.vertices); /* p2 반납 (크래시! 이미 없는 메모리) */
```

`p2 = p1;`을 실행하면 컴퓨터는 `p1`의 멤버 값을 `p2`에 그대로 베낀다. 여기에는 `vertices`가 가진 **주소값(번호표)**도 포함된다.

**문제 상황**: 메모리 공유의 비극

`p1`과 `p2`가 하나의 점 데이터(메모리)를 공유하게 된다.
```
    [ p1 구조체 ]          [ 힙(Heap) 메모리 ]          [ p2 구조체 ]
    count : 3              +-----------------+          count : 3
    vertices : 0x100  ---> |  점 데이터 3개   | <---  vertices : 0x100
                           +-----------------+
                           (주인 없는 공유지)
```

**그 결과**: 이중 해제(Double Free)

1. `free(p1.vertices)`: 0x100 번지의 집을 철거했다.
2. `free(p2.vertices)`: 0x100 번지를 또 철거하러 갔는데, 이미 폐허다.
3. **운영체제:** "이미 반납된 메모리를 또 건드려?" → **강제 종료(Crash)**


### 14.10.2 해결책: “깊은 복사(Deep Copy)” 규칙 만들기

이 문제를 해결하려면 "주소만 베끼지 말고, 메모리를 새로 잡아서 좌표 값들을 하나하나 복사하라"는 규칙을 지켜야 한다.
전용 함수를 만들어 사용하는 것이 정석이다.

```
/* 깊은 복사를 수행하는 함수 */
void copy_polygon(struct Polygon *dest, const struct Polygon *src) {
    /* 1. 단순 값(점의 개수) 복사 */
    dest->count = src->count;

    /* 2. 새로운 메모리 공간(방)을 따로 잡음 (Deep Allocation) */
    dest->vertices = malloc(sizeof(struct Point) * src->count);

    /* 3. 원본의 내용물(점들의 좌표)을 새 방에 복사 */
    for (int i = 0; i < src->count; i++) {
        dest->vertices[i] = src->vertices[i];
    }
}
```

그리고, 구조체 대입 대신 깊은 복사 전용 함수를 쓴다.

```c
struct Polygon p1, p2;

/* p1 초기화 */
p1.count = 3;
p1.vertices = malloc(sizeof(struct Point) * 3);
p1.vertices[0].x = 10; 

/* p2 = p1; 대신 함수 사용! */
copy_polygon(&p2, &p1);

/* 이제 p2는 p1과 완전히 독립적인 "복제본"이다. */

free(p1.vertices);
free(p2.vertices); /* 안전하게 해제됨 (각자 자기 땅을 해제하므로) */
```

**해결된 상황**: 완전한 독립

이제 `p1`과 `p2`는 서로 다른 메모리 공간을 가리킨다.
```
    [ p1 구조체 ]          [ 힙 영역 A ]             [ 힙 영역 B ]          [ p2 구조체 ]
    count : 3              +-------------+           +-------------+          count : 3
    vertices : 0x100  ---> | 원본 데이터  |           | 복사본 데이터 | <---  vertices : 0x200
                           +-------------+           +-------------+
```

**포인터가 포함된 구조체 관리 3원칙**

구조체 안에 포인터 멤버가 하나라도 있다면, 단순 대입(`=`)은 금지다. 반드시 아래 3단계를 기억하자.

1.  **만들기 (Allocation):** `malloc`으로 구조체 본체와 멤버 공간을 각각 확보한다.
2.  **복사하기 (Deep Copy):** 메모리를 새로 잡고 내용을 복사해주는 전용 함수를 만든다.
3.  **정리하기 (Deallocation):** 안쪽 멤버(`vertices`)를 먼저 `free`하고, 바깥쪽 구조체를 나중에 정리한다.
