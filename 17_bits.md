# 17. 비트 연산자와 플래그: 변수 하나에 스위치 여러 개 담기

지금까지 우리는 프로그램의 흐름을 제어하기 위해

- `if`, `switch`로 갈림길을 만들고
- `for`, `while`, `do-while`로 반복을 만들고
- `&&`, `||`, `!`로 조건을 조립하는 방법

을 다뤘다.

여기까지 오면 프로그램이 무엇을 해야 하는지(논리)는 꽤 잘 표현할 수 있다.
그런데 현실의 코드에서는 "논리" 말고도 자주 등장하는 것이 하나 더 있다.

**상태(ON/OFF)를 여러개 저장해야 하는 상황이 있다.**

## 17.1 왜 필요한가: 스위치가 너무 많아졌다 (The Problem)

예를 들어 게임 캐릭터를 만든다고 상상해보자. 캐릭터는 게임 속에서 매 순간 수많은 상태를 동시에 가질 수 있다.

* 독(Poison)에 걸렸는가?
* 기절(Stun) 상태인가?
* 보호막(Shield)이 켜져 있는가?
* 은신(Invisible) 중인가?
* 비행(Fly) 중인가?

초보자 시절에는 보통 이렇게 변수를 하나씩 선언하며 시작한다.

```c
int is_poisoned;
int is_stunned;
int is_shield_active;
int is_invisible;
int is_flying;
/* ... 계속 추가됨 ... */
```

그리고 로직을 짤 때마다 하나씩 검사한다.

```c
if (is_poisoned == 1) { hp -= 10; }
if (is_shield_active == 1) { damage = 0; }
```

문법적으로는 아무런 문제가 없다. 기능도 잘 동작한다.
하지만 프로젝트 규모가 커지고 상태가 5개에서 30개, 60개로 늘어나면 하드웨어(메모리와 CPU)의 낭비가 눈에 띄기 시작한다.

우리가 쓰는 `int`는 보통 4바이트(32비트) 크기다.
그런데 '독 상태인가?'를 저장하는 데는 사실 단 1비트(0 또는 1)면 충분하다.
겨우 1비트 정보를 담기 위해 32비트짜리 상자를 통째로 쓰는 셈이다. 

또한 현대 CPU는 태생적으로 한 번의 명령(Cycle)으로 32비트(혹은 64비트)를 동시에 계산하도록 설계되어 있다. 
다른 말로 하면 CPU는 `int` 하나를 처리할 때 32개의 0과 1을 한꺼번에 훑어볼 수 있는 능력이 있다.
그래서 비트 플래그로 묶어서 처리하면 CPU는 단 한 번의 연산으로 32개의 상태를 동시에 검사하거나 변경할 수 있다. 
하지만 변수를 따로 만들면 CPU에게 32번 명령을 내려야 한다.

비유하자면 마치 32인승 버스를 대절해서 승객 1명만 태우고 운행하는 것과 같다. 
심지어 이 버스는 승객 32명을 동시에 목적지에 내려줄 수 있는 능력이 있는데, 
굳이 한 명 태우고 갔다 오고, 다시 한 명 태우고 갔다 오고를 반복하는 꼴이다.

단순한 메모리 낭비를 넘어, 캐시 효율 저하와 명령어 병목 현상을 일으켜 게임 성능 저하의 주범이 된다.

그래서 프로그래머들은 `int` 변수 안에 0/1 스위치를 꽉 채워서 쓰는 문법과 프로그래밍 패턴을 개발했다. 

변수 하나를 '숫자'가 아닌 '32개의 스위치가 달린 제어 패널'로 다루는 법을 배워보자.

# 17.2 비트라는 재료: 0과 1의 칸

우리가 요리를 하려면 재료를 알아야 하듯, 비트 연산을 하려면 컴퓨터의 가장 밑바닥 재료인 비트와 바이트를 구분할 줄 알아야 한다.

비트(Bit)는 "스위치 하나"다. 정보의 가장 작은 단위로 값은 오직 0 또는 1만 가질 수 있다. 
비유하자면, 전구 하나, 동전의 앞뒤, 작은 스위치 하나라고 할 수 있다.

바이트(Byte)는 "스위치 묶음"이다. 메모리 주소를 매기는 가장 작은 단위로 보통 8개의 비트가 모여 1바이트가 된다.
비유하자면, 계란 8개가 들어가는 계란 판, 8개 호실이 있는 건물 한 층이라고 할 수 있다.

여기서 핵심은, CPU가 메모리에서 데이터를 가져올 때, 비트 하나만 쏙 빼올 수 없다는 것이다.
최소한 바이트 단위(계란 판 단위)로 가져와야 한.
그래서 우리는 일단 바이트(또는 int)를 통째로 가져온 뒤, 그 안에서 비트 연산자라는 핀셋을 이용해 특정 비트만 건드리는 것이다.

**정수(`int`)의 실체: "비트가 32개가 이어진 긴 줄"**

우리가 코드에 `int a = 5;`라고 쓰면, 우리는 이것을 숫자 '5'라고 생각한다.
하지만 컴퓨터 메모리 내부에서는 전혀 다른 풍경이 펼쳐진다.

컴퓨터는 이 `int`를 32개의 비트가 일렬로 늘어선 긴 줄로 저장한다. (일반적인 32비트 시스템 기준)

숫자 5의 실제 모습:
```
		00000000 00000000 00000000 00000101
		↑                                 ↑
		31번 비트                       0번 비트
```
* 대부분은 `0`으로 채워져 있고, 맨 끝에 `101`(4+1)만 켜져 있는 상태다.
* 우리는 지금까지 이 전체를 합쳐서 "오! 5구나"라고 값(Value)으로만 해석했다.

**관점의 전환: 계산에서 조작으로**

비트 연산을 시작한다는 것은, 이 `int` 변수를 더 이상 '숫자 5'로 보지 않겠다는 말이다.
대신 "32개의 스위치가 달린 제어 패널"로 보겠다는 뜻이다.

* **산술 연산(`+`, `-`, `*`, `/`):**
    * 전체 비트를 하나의 **'값(양)'**으로 취급한다.
    * 예: `5 + 1` = `6` (양이 늘어남)

* **비트 연산(`&`, `|`, `^`, `~`, `<<`):**
    * 값을 무시하고, 비트 한 칸 한 칸의 **'모양(패턴)'**을 직접 만진다.
    * 예: "오른쪽에서 3번째 스위치를 켜라", "모든 스위치를 반대로 뒤집어라"

이제부터 `int flags;` 변수를 볼 때는 "이 안에 어떤 숫자가 들어있지?"라고 묻지 말자.
"이 안에 몇 번 스위치가 켜져 있지?"라고 묻는 것이 비트 연산의 출발점이다.

## 17.3 비트 마스크(Bit Mask): 원하는 스위치만 골라내는 "구멍 뚫린 종이"

우리는 이제 `int` 변수를 32개의 스위치 패널로 보기로 했다.
그런데 막상 코드를 짜려고 보니 문제가 하나 있다.

"3번 스위치만 켜고 싶은데, 어떻게 '3번'을 콕 집어 말하지?"

`flags`라는 스위치 패널의 0번 스위치를 켜기 위해 `flags = 1;` 이라고 하면 0번 스위치는 켜지는데 나머지가 다 꺼집니다.
우리는 다른 스위치는 건드리지 않고, 딱 원하는 위치의 스위치만 변경하고 싶다.

여기서 필요한 것이 바로 비트 마스크(Bit Mask)다.

**마스크의 원리: 스텐실(Stencil)**

마스크는 비트의 세계에서 "스텐실(구멍 뚫린 종이)" 역할을 한다.

- **1 (구멍 뚫림):** "여기는 내가 조작할 거야." (관심 영역)
- **0 (막혀 있음):** "여기는 건드리지 마." (보호 영역)

예를 들어, **"2번 스위치"**를 조작하고 싶다면, 2번 자리에만 구멍(1)을 뚫고 나머지는 다 막아버린(0) 종이를 준비하면 된다.

```
		... 0 0 0 0 0 1 0 0 
		              ↑
		            (2번 스위치)
```

이 `...000100`이라는 숫자 자체가 바로 **'2번 비트 마스크'**가 된다.

**비트 번호 매기기 (주의!)**

마스크를 만들 때 가장 중요한 것은 번호의 순서다.
컴퓨터의 비트 번호는 오른쪽 끝에서 0번으로 시작해서 왼쪽으로 갈수록 커진다.

```
		[ ... 7 6 5 4 3 2 1 0 ]
		                    ↑
		                  Start
```

- **0번 비트:** 맨 오른쪽 (1번째 칸)
- **1번 비트:** 오른쪽에서 두 번째 칸
- **31번 비트:** 맨 왼쪽 (32번째 칸)

초보자들은 흔히 왼쪽부터 세거나 1번부터 세는 실수를 한다. 오른쪽 0번 시작을 절대 잊지 말자.

**마스크 만드는 법: 시프트 연산자(`<<`)**

그럼 "2번 비트 마스크(`00...00100`)"를 코드로는 어떻게 만들까요?
10진수(`4`)를 계산해서 넣는 거나 C23 표준부터 적용된 이진수(`0b00100`)를 직접 타이핑하는 것은 너무 번거롭다.

그래서 프로그래머들은 "1을 왼쪽으로 민다"는 뜻의 시프트 연산자(`<<`)를 사용한다.

```
		1 << n
		(숫자 1의 비트를 왼쪽으로 n칸 밀어라)
```

이 문법 하나면 모든 위치의 마스크를 즉석에서 만들 수 있다.

- **`1 << 0`** : `000...0001` (0번 마스크)
- **`1 << 1`** : `000...0010` (1번 마스크)
- **`1 << 5`** : `000...00100000` (5번 마스크)

> [!NOTE]
> 구멍을 여러 개 뚫을 순 없을까?
> 
> 당연히 된다! 2번과 5번을 동시에 가리키는 마스크도 만들 수 있다.
> 마스크 여러 개를 합치려면 접착제 역할을 하는 연산자가 필요하다.
> 바로 다음 장에서 배울 `|` (OR) 연산자가 그 역할을 해줄 것이다.

우리는 이제 스위치 패널(변수)와 구멍 뚫린 종이(마스크)를 모두 손에 넣었다.
실제로 스위치를 켜고 끄는 6가지 연산 도구를 배워보자. 

## 17.4 비트 논리 연산자: 마스크로 스위치 조작하기 (`&`, `|`, `^`)

가장 핵심이 되는 3가지 연산자다. 제공된 마스크를 가지고 실제로 스위치를 조작하는 역할을 한다.
`&`와 `||`의 경우에는 `&&`, `||`와 비슷해 보이지만, 비트 단위로 개별적으로 작동한다는 점이 다르다.

### 17.4.1 `&` (AND): 엄격한 관리자, "모두 켜져야 켠다"

**동작:** 두 비트가 모두 1일 때만 1이 된다. 하나라도 0이면 가차 없이 0으로 만들어버린다.

**핵심 성질:**
- `1`과 만나면? 원래 값을 그대로 통과시킨다. (Keep)
- `0`과 만나면? 무조건 0으로 지워버린다. (Clear)

그렇기 때문에 `&`는 주로 검사 또는 끄기 용도로 쓰인다.

**검사 (Check): "거기 켜져 있어?"**
  
특정 위치의 스위치가 켜져 있는지 확인하고 싶을 때 사용한다.
마스크를 씌우면, 관심 있는 비트만 쏙 뽑아내고 나머지는 다 0으로 지워버리기 때문이다.

* `flags & MASK`의 결과가 `0`이면? 해당 플래그가 비활성화된 상태
* `flags & MASK`의 결과가 `0`이 아니면? 해당 플래그가 활성화된 상태

```
  0 1 0 1 0 1  (flags: 원본 값)
  0 0 0 1 0 0  (MASK: "2번 비트만 볼래")
  -----------  (&)
  0 0 0 1 0 0  (결과: 2번만 통과, 나머지는 삭제됨)
```

결과가 0이 아니므로, 2번 비트는 켜져 있었음을 알 수 있다!

**끄기 (Force Off): "거기만 0으로 지워!"**

특정 비트만 강제로 끄고 싶을 때 사용한다.
"끄고 싶은 곳은 0, 남기고 싶은 곳은 1"로 채운 패턴과 `&` 연산을 하면 된다.

* 패턴에서 0인 위치: 0으로 지워짐 (Off)
* 패턴에서 1인 위치: 원래 값 유지 (Safe)

```
  0 1 0 1 0 1  (flags: 원본 값)
  1 1 1 0 1 1  (패턴: "2번 비트를 끌래")
  -----------  (&)
  0 1 0 0 0 1  (결과: 2번은 비활성화됨, 나머지는 그대로 유지)
```

> [!NOTE]
> 저 패턴은 어떻게 만들지?
>
> 일일이 1과 0을 타이핑해서 만들지 않는다.
> 뒤에서 배울 `~` (비트 NOT) 연산자를 쓰면, 일반 마스크(`000100`)을 뒤집어서 만들 수 있다.  


### 17.4.2 `|` (OR): 관대한 합병자 "하나라도 켜지면 켠다"

* **동작:** 두 비트 중 하나라도 1이면 1이 된다.
  둘 다 0일 때만 0이 된다.

* **핵심 성질:**
  * `0`과 만나면? 원래 값을 그대로 통과시킨다. (Keep)
  * `1`과 만나면? 무조건 1로 켜버린다. (Force On)

그렇기 때문에 `|`는 주로 여러 설정을 하나로 뭉치거나 스위치를 켜는 용도로 쓰인다.

**합치기 (Combine): "옵션 A랑 B랑 다 주세요"**
여러 개의 마스크(옵션)을 하나의 변수에 담아 전달할 때 사용한다.
흔히 라이브러리 함수를 쓸 때 많이 보게 되는 패턴이다.

```c
/* 예: 윈도우 창을 만드는데, "제목 표시줄"도 있고 "닫기 버튼"도 있게 해줘. */
int styles = WS_CAPTION | WS_SYSMENU;
```

비트를 하나씩 적어보면 다음과 같다. 

```
		  0 0 0 1  (옵션 A)
		  0 0 1 0  (옵션 B)
		  -------  (|)
		  0 0 1 1  (결과: A와 B가 합쳐진 복합 상태)
```

A나 B 중 어디라도 1이 있으면 결과에서도 1이 된다. 두 옵션이 모두 활성화된다.

> [!NOTE]
> 그냥 덧셈(`+`)으로 합치면?
>
> 결과가 같을 때도 있겠지만, 위험하다.
> 만약 실수로 이미 켜져 있는 스위치를 또 더하면 어떻게 될까?
>
> - **덧셈(`+`):** $0001 + 0001 = 0010$ (값이 2배가 되면서 옆 비트를 건드려서 자리 올림 버그 발생)
> - **OR(`|`):** $0001 | 0001 = 0001$ (이미 켜져 있으면 그대로 둬서 안전)
>
> 둘 다 1인 비트에서도 정상적으로 안전하게 동작해야 하기 때문에 상태를 합칠 때는 덧셈이 아니라 반드시 OR(`|`) 연산을 써야 한다.

**켜기 (Force On): "스위치 올려!"**

기존에 다른 스위치가 켜져 있든 말든 상관없이, 내가 원하는 특정 비트를 켤 때 사용한다.

```c
		flags = flags | MASK;
```

* 마스크에서 0인 위치: 원래 값 유지 (Safe)
* 마스크에서 1인 위치: 1로 설정됨 (On)

비트가 계산되는 과정을 보면 이렇다.

```
		  1 0 0 0 1 0  (flags: 원래 값)
		  0 0 0 1 0 0  (MASK: "2번 켤래")
		  -----------  (|)
		  1 0 0 1 1 0  (결과: 원래 값은 유지되고, 2번만 켜짐)
```

이미 2번이 켜져 있었더라도 `1 | 1 = 1`이므로 그대로 켜진 상태가 유지된다. (안전함)

> [!NOTE]
> **왜 마스크(MASK)만 대문자로 쓰나?**
>
> 문법적으로는 소문자(`mask`)로 써도 전혀 문제가 없다.
> 하지만 C언어 개발자들 사이에는 "변하지 않는 값(상수)는 무조건 대문자로 쓴다"는 강력한 약속(Convention)이 있다.
>
> - **소문자 (예: `flags`, `hp`, `score`):** 프로그램 실행 중에 값이 계속 변하는 **변수**
> - **대문자 (예: `MASK`, `POISON`, `MAX_SPEED`):** 프로그램 시작부터 끝까지 절대 변하지 않는 **상수**
>
> 코드에 `POISON`이라고 적혀 있다면, 이는 읽는 사람에게 "이 값은 고정된 설계도이니 절대 값을 바꾸지 말라"는 시각적인 표지판 역할을 한다.

## 17.4.3 `^` (XOR): 틀린 그림 찾기, "서로 다르면 켠다"

* **동작:** 두 비트가 서로 다를 때만 1, 같으면 0이 된다.
* **핵심 성질:**
  * `0`과 만나면? 원래 값을 그대로 통과시킨다. (**Keep**)
  * `1`과 만나면? 무조건 반대로 뒤집는다. (**Flip**)

`Flip` 성질 덕분에 `^`는 켜진 건 끄고, 꺼진 건 켜는 토글(Toggle) 기능이나, 데이터를 숨기는 암호화(encryption)에 사용된다.

**토글(Toggle): "상태 뒤집기"**

특정 위치의 스위치를 반전시키고 싶을 때 사용한다.
마스크를 쓰면, 관심 있는 비트들은 바꾸고, 나머지는 그대로 유지할 수 있다.

```c
		flags = flags ^ MASK;
```

* 마스크에서 0인 위치: 원래 값 유지 (**Safe**)
* 마스크에서 1인 위치: 다른 값으로 반전 (**Flip**)

```
		  1 0 0 0 0 0  (flags: 원래 값)
		  0 0 0 1 0 0  (MASK: "2번 뒤집어라")
		  -----------  (^)
		  1 0 0 1 0 0  (결과: 2번 값이 바뀜)
```

한 번 더 실행하면 어떻게 될까?

```
		  1 0 0 1 0 0  (flags: 현재 켜져 있음)
		  0 0 0 1 0 0  (MASK: "2번 뒤집어라")
		  -----------  (^)
		  1 0 0 0 0 0  (결과: 2번 값이 바뀌어서 다시 비활성화 됨)
```

**암호화 (Encryption): "패턴을 바꿨다가 원상복구하기"**

`^`에는 마법 같은 성질이 있다. 같은 마스크로 두 번 `^` 하면 원래 비트들이 나온다.
그래서 간단한 암호화에도 쓸 수 있다.

```
		  1 0 1 0 1 0  (original: 원래 값)
		  0 1 1 1 0 0  (key: 원래 값에서 반전시킬 위치)
		  -----------  (^)
		  1 1 0 1 0 0  (결과: 원래 값을 알아볼 수 없다)
```

똑같은 키로 `^`를 한 번 더 실행하면 원래 값을 찾을 수 있다.

```
		  1 1 0 1 0 0  (encrypted: 복호화 할 패턴)
		  0 1 1 1 0 0  (key: 다시 반전시킬 위치)
		  -----------  (^)
		  1 0 1 0 1 0  (결과: 원래 값을 되찾았다)
```

**반전 연산자: 비트 거꾸로 (`~`)**

한 개의 스위치에서 비트들을 모두 반전시킨다.

**`~` (NOT / Tilde): 청개구리, "꺼진 것만 켠다"**
- **동작:** 0은 1로, 1은 0으로 모조리 뒤집는다.
- **용도:** 제거용 마스크 만들기
    * 끄고 싶은 비트만 0으로 만들고 싶을 때, `~mask`를 사용해 마스크를 반전시켜서 `&` 연산과 조합한다.
```
		0 0 0 0 0 1 0 1  (A)
		---------------  (~)
		1 1 1 1 1 0 1 0  (결과: 모든 비트가 반전됨)
```
> **주의:** `~` 연산은 부호 비트(가장 왼쪽 비트)까지 뒤집어버린다. 그래서 비트 연산을 할 때는 부호 문제에서 자유로운 `unsigned` 타입을 쓰는 것이 정신 건강에 좋다.

**이동 연산자: 비트 밀기 (`<<`, `>>`)**

한 개의 스위치에서 비트들을 왼쪽이나 오른쪽으로 민다. 밀려난 비트는 버려지고, 빈자리는 0으로 채워진다.

**`<<` (Left Shift): 왼쪽으로 밀기**

- **동작:** 비트들을 왼쪽으로 `n`칸 민다. 오른쪽 빈자리는 `0`으로 채워진다.
- **수학적 의미:** 2의 n승을 곱하는 효과 ($x \times 2^n$)
- **용도:** "마스크 생성" (예: `1 << 3` → 3번 비트만 1인 값 만들기)
```
		0 0 0 0 0 0 1 1  (3)
		<< 2             (왼쪽으로 2칸 밀기)
		---------------
		0 0 0 0 1 1 0 0  (12: 3 * 2^2)
```
