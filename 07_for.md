# 7. 반복문. `for`

지금까지 우리는

- C 프로그램이 `main`에서 시작한다는 것
- 문장이 위에서 아래로 실행된다는 것
- 코드가 토큰으로 나뉘어 읽힌다는 것
- 데이터와 `int`로 계산하고 저장하는 방법
- 그리고 6장에서 `if`로 **갈림길**을 만드는 방법

을 배웠다.

다음 순서는 `if`에 이어 또다른 큰 축인 **반복(Loop)** 을 정복할 차례다. 

7장의 목표는 단순하다. `for`문을 이용해 다음 세 가지 패턴을 익히는 것이다. 

1. 숫자 세기: 1, 2, 3 ... 순서대로 셈을 한다.
2. 값 누적하기: 1부터 10까지 더하는 것처럼 값을 차곡차곡 모은다.
3. 조건으로 거르기: 반복하는 도중에 원하는 값만 쏙쏙 골라낸다.

> 5장에서도 말했듯이 우리는 아직 `++`, `--` 같은 연산자를 일부러 미뤘다.
> 그래서 여기서도 증가는 `i = i + 1` 방식으로만 쓴다.

---

## 7.1 반복이 왜 필요한가

프로그램은 컴퓨터에게 건네는 작업 지시서라고 했다. 
컴퓨터는 스스로 "알아서" 일을 하지 못하므로, 우리가 무엇을 어떤 순서로 할지를 꼼꼼하게 문장으로 적어 줘야 한다. 
그런데 작업 지시서에는 이런 요구가 정말 자주 나온다.

- "이 일을 10번만 해라."

- "1부터 100까지 더해라."

- "목록의 모든 값을 하나씩 검사해라."

만약 반복문이 없다면, 우리는 같은 문장을 계속 복사해서 붙여넣어야 한다. 
예를 들어 "0부터 9까지 각 숫자에 대해 같은 일을 처리해라"를 반복문 없이 적으면 이렇게 된다. 

```c
일처리(0);
일처리(1);
일처리(2);
// ... (중략) ...
일처리(9);
```

너무 비효율적이다.

- 숫자가 10개면 10줄

- 숫자가 100개면 100줄

- 숫자가 1000개면 1000줄을 써야 한다.

게다가 1000줄을 다 썼는데 "2000번으로 늘려줘"라고 한다면? 상상만 해도 끔찍하다.

**프로그래밍은 "손으로 하기 싫은 일을 컴퓨터에게 시키는 기술"이다.** 
그런데 이 방식은 컴퓨터에게 일을 시키기 위해 내 손이 먼저 지쳐버리는 꼴이다.

그래서 C언어는 "같은 일을 여러 번 하라"를 짧게 표현할 수 있는 **반복문(Loop)**을 제공한다. 
반복문을 쓰면 10번이든 1000번이든 단 몇 줄로 표현할 수 있다. 
반복되는 숫자(0, 1, 2...)를 대신할 변수 하나만 있으면 된다.

## 7.2 반복을 만드는 재료 3가지

반복은 겉보기에는 복잡해 보이지만, 사실은 재료가 세가지뿐이다. 
1. **시작값**: 어디서부터 시작할 것인가?
2. **끝 조건**: 언제 멈출 것인가?
3. **갱신**: 한번 돌 때마다 무엇이 어떻게 바뀔 것인가?

우리는 5장에서 이미 "갱신"의 핵심을 미리 연습했다.

```c
i = i + 1;
```

갱신은 반복의 뼈대다. 값이 조금씩 바뀌어야 반복이 "앞으로 진행"할 수 있다. 

`for`문은 이 세가지를 한 줄에 모아 놓은 반복문이다.

## 7.3 `for`문의 기본 모양
   
`for`는 C가 미리 정해 둔 키워드다.
(`int`, `return`처럼 마음대로 다른 의미로 쓸 수 없는 단어였다.)

`for`문의 모양은 다음과 같다.
```c
for (초기화; 조건; 갱신)
{
    반복해서 실행할 문장들
}
```
여기서 헷갈리기 쉬운 포인트가 하나 있다.

#### `for ( )` 안의 세미콜론 `;`은 “문장 끝”이 아니다

우리는 지금까지 `;`을 “문장이 끝났다”는 표시로 봤다.

하지만 `for (초기화; 조건; 갱신)` 안의 `;` 두 개는

- 문장을 끝내는 ;이 아니라

- 세 칸을 구분하는 **구분자** 역할이다.

즉, for는 괄호 안에서만 세미콜론을 “칸 나누기”로 사용한다.

---

## 7.4 `for`문은 어떤 순서로 실행될까?

`for`문은 구조적으로 **딱 한 번만 실행되는 부분**과 **매번 반복되는 부분**이 섞여있다. 

1. 실행 순서의 핵심 (Flow)
`for`문의 실행 흐름은 다음과 같은 **루프(Loop)** 를 그린다.
   1. 초기화: 맨 처음에 **딱 한 번만** 실행된다.
   2. 조건 검사:
      - **참(True)**이면 $\rightarrow$ **3. 본문**으로 들어간다.
      - **거짓(False)**이면 $\rightarrow$ **반복을 즉시 종료**하고 for문 밖으로 나간다.
   3. 본문 실행: `{ }` 안의 코드를 실행한다.
   4. 갱신(증감): 변수의 값을 변화시킨다.
   5. 다시 2번(조건 검사)로 돌아간다.

요약: `초기화` $\rightarrow$ (`조건(참)` $\rightarrow$ `본문` $\rightarrow$ `갱신`) $\rightarrow$ (`조건(참)` $\rightarrow$ `본문` $\rightarrow$ `갱신`) $\rightarrow$ ... `조건(거짓)` $\rightarrow$ `종료`

2. 예제로 실행 흐름 따라가기 (Trace)
작은 예제를 통해 변수 `i`와 `last`가 어떻게 변하는지 추적해보자.
```c
int main()
{
    int i;
    int last = -1;

    for (i = 0; i < 3; i = i + 1) {
        /* 현재 반복 중인 i 값을 기록 */
        last = i; 
    }
    
    return 0;
}
```
**[변수 상태 추적표]**
|단계|현재`i`|조건식(`i < 3)|실행 내용|`last`의 값|`i`의 변화(갱신)|
|1회차|0|참|본문 실행|-1$\rightarrow$**0**|0$\rightarrow$**1**|
|2회차|1|참|본문 실행|0$\rightarrow$**1**|1$\rightarrow$**2**|
|3회차|2|참|본문 실행|1$\rightarrow$**2**|2$\rightarrow$**3**|
|종료|3|거짓|루프 탈출|**2**(유지)|**3**(유지)|

3. 여기서 꼭 잡아야 할 감각 (핵심)
반복문이 끝난 뒤의 상황을 정확히 이해해야 한다.
- 본문이 실행되는 동안 `i`는 **0, 1, 2**
- 반복이 **완전히 끝난 뒤 `i`**는 **3**

반복문 종료 후의 `i`는 **마지막으로 실행된 값(2)**가 아니라, **조건을 거짓으로 만들어 반복을 끝내버린 값(3)** 이 되는 것이다.


## 7.5 C89 규칙: for문 안에서 변수 선언 금지
여기서 5장에서 배웠던 **변수 선언은 반드시 블록 맨 위에 몰아서 한다**는 C89의 철칙이 다시 등장한다. 

1. 흔히 하는 실수 (C99 방식 - 에러 발생)
최신 언어(C99 이후)에서는 허용되지만, 우리가 따르는 **C89 표준에서는 컴파일 에러**가 발생한다.

```c
 /* [C89에서는 금지] */
/* for문 괄호 안에서 'int i'를 선언하면 에러가 난다. */

for (int i = 0; i < 10; i = i + 1) /* <-- Error! */ {
    /* ... */
}
```

2. 올바른 작성법 (C89 방식)
반드시 **반복문이 시작되기 전, 블록의 최상단**에 변수 `i`를 미리 선언해야 합니다.
```c
/* [C89 표준 방식] */

int main()
{
    int i;  /* 1. 변수를 먼저 선언 (재료 준비) */
    
    /* ... 다른 코드들 ... */

    /* 2. 이미 만들어진 변수 i를 사용 */
    for (i = 0; i < 10; i = i + 1) {
        /* ... */
    }
    
    return 0;
}
```

3. 비유: "요리 전 재료 준비"
이 규칙을 요리에 비유하면 이해하기 쉽다.

- C89 (옛날 방식):
       "요리를 시작하기 전에(본문 코드 실행 전), 도마 위에 모든 재료(변수)를 다 꺼내서 손질해 둬야 한다."$\rightarrow$ 중간에 냉장고 문을 열 수 없다.

- C99 (최신 방식):
       "요리하다가 필요할 때마다 냉장고에서 재료를 꺼내도 된다."$\rightarrow$ for문 안에서 바로 변수를 만들어도 된다.

정리:우리는 **재료를 미리 다 꺼내놓는 C89 규칙**을 따른다. 따라서 `for`문을 작성하기 전에 **반복 제어 변수(`i`)를 위에 선언했는지?** 확인하는 습관을 들인다.



## 7.6 C89 규칙: `<`와 `<=`: 반복에서 가장 흔한 실수

반복문을 작성할 때 가장 많이 하는 실수는 **딱 한 번 더 돌거나, 딱 한 번 덜 도는** 실수다. 
프로그래머들은 이를 **Off-by-one Error**라고 부른다.
특히 `0`부터 시작할 때 `<`를 쓸지 `<=`를 쓸지 헷갈리기 쉬운데, 이 작은 차이가 결과에 큰 영향을 미친다.

1. `<` 를 쓰는 경우 (기준: 횟수 중심)
보통 **n번 반복하고 싶다**고 할 때 가장 많이 쓰는 표준적인 방식이다.

```c
/* 0부터 9까지 (총 10번 실행) */
for (i = 0; i < 10; i = i + 1) {
    /* ... */
}
```
- 실행되는 `i` 값: 0, 1, 2, ..., 9
- 반복 횟수: 총 10번
- 종료 시점: `i`가 10이 되는 순간 `10 < 10`은 거짓이 되어 멈춘다.
- 특징: 0부터 시작해서 숫자를 반복할때 권장되는 형태다.

2. <= 를 쓰는 경우 (기준: 범위 중심)
끝나는 숫자를 포함하고 싶을 때 사용한다.
```c
/* 0부터 10까지 (총 11번 실행) */
for (i = 0; i <= 10; i = i + 1) {
    /* ... */
}
```
- 실행되는 `i` 값: 0, 1, 2, ..., 9, 10
- 반복 횟수: 총 11번
- 종료 시점: `i`가 11이 되는 순간 `11 <= 10`은 거짓이 되어 멈춘다.
- 특징: 1부터 시작해서 숫자를 반복할때 권장되는 형태다.

3. 결론: 무엇을 써야 할까?
C언어는 **0부터 숫자를 세는 문화(Zero-based numbering)** 를 가지고 있다.
따라서 특별한 이유가 없다면 **작다 `<`**를 사용하는 것이 실수를 줄이는 가장 좋은 습관이다.

   **공식처럼 외우기**: "0부터 시작해서 10번 돌고 싶다면? i < 10" (등호 =를 뺀다!)



## 7.7 예제 1: "0부터 9까지 돈다"를 변수 값으로 확인하기

처음 반복문을 쓸 때는 "정말 10번 돌았나?"가 불안할 수 있다.
그래서 여기서는 반복 횟수를 `count`에 저장해서 확인해본다.

```c
int main()
{
   int i;           /* 루프 변수. 0부터 반복할 계획 */
   int count = 0;   /* 반복 횟수. 처음에는 0번 실행됨 */
   int last = -1;   /* 마지막에 실행된 i. -1은 루프가 돌지 않았음을 표시 */

   /*  i를 0부터 9까지(10보다 작을 때까지) 반복 */
   for (i = 0; i < 10; i = i + 1) {
      count = count + 1;   /* 반복 횟수 업데이트 */
      last = i;            /* 현재 처리 중인 i값 저장 */
   }

   /* 반복이 끝났을 때:
      - count는 10
      - last는 9
      = i는 10
   */

   return 0;
}
```



## 7.8 예제 2: 1부터 10까지 합계 구하기

반복문은 누적해서 계산하는 데에 많이 쓰인다.

```c
int main()
{
   int i;         /* 루프 변수. 1부터 반복할 계획 */
   int sum = 0;   /* 합계. 초기값은 +의 항등원인 0 */

   /* i를 1부터 10까지(10보다 작거나 같을 때까지) 반복 */
   for (i = 1; i <= 10; i = i + 1) {
      sum = sum + i;   /* 기존 sum에 현재 i를 더한 값을 sum에 저장한다. */
   }

   /* 반복이 끝나면 sum은 55가 된다 (1+2+...+10) */
   return 0;
}
```

중요한 습관: 누적 변수는 반드시 항등원으로 초기화

`sum = 0;`을 빼먹으면 결과가 망가질 수 있다. 
`sum`이 알 수 없는 값인 상태에서는 `sum + i`도 알 수 없는 값이기 때문이다. 

누적은 계산할 때 이전 값이 쓰이기 때문에, 처음 시작한 값이 틀리면 끝의 값도 틀린다. 


## 7.9 예제 3: 1부터 10까지 짝수들의 합계 구하기

프로그래밍의 가장 강력한 패턴 중 하나는 스캔(Scan) 후 필터링(Filter)하는 것이다. 

6장에서 한 `if`를 반복문 안에서 쓰면, 원하는 값에 대해서만 작업을 할 수 있다. 

1부터 10까지 중에서 짝수만 골라서 개수(`even_count`)와, 합계(`even_sum`)을 구해본다.

```c
int main()
{
   int i;                /* 루프 변수. */
   int even_count = 0;   /* 개수. 초기값은 0 */
   int even_sum = 0;     /* 합계. 초기값은 +의 항등원인 0 */

   /* i를 1부터 10까지(10보다 작거나 같을 때까지) 반복 */
   for (i = 1; i <= 10; i = i + 1) {
      /* i가 2의 배수일 때 실행*/
      if ((i % 2) == 0) {
         even_sum = even_sum + i;   /* 기존 even_sum에 현재 i를 더한 값을 even_sum에 저장한다. */
      }
   }

   /* 반복이 끝나면:
      - even_count는 5 (0,2,4,6,8)
      - even_sum은 30 (2+4+6+8+10)
   */
   return 0;
}   
```

예제 코드에서,

- `for`는 "대상을 하나씩 꺼내는 역할"
- `if`는 "그중에서 필요한 것만 고르는 역할"

을 하고, 비슷한 패턴으로 대부분의 검사 작업이 가능해진다.


## 7.10 `for`에서 자주 하는 실수 2가지

### 7.10.1 무한 루프: "어? 프로그램이 멈췄네!"

반복 변수의 갱신 (`i = i + 1`)을 빼먹으면, 화면에 아무것도 안뜨고 커서만 깜빡이거나, 프로그램이 먹통이 된다(응답 없음).

```c
for (i = 0; i < 10; ) {
   /* i가 바뀌지 않으면 i < 10이 계속 참이 되어 영원히 반복한다. */
}
```

반복문은 앞으로 진행해야 끝난다. 그 진행을 만드는 것이 보통 `i = i + 1` 같은 갱신이다.

> Tip: 반복문이 끝나지 않고 멈춰버렸다면? 당황하지 말고 윈도우/리눅스에서는 키보드에서 `Ctrl` 키와 `C` 키를 같이 누르고, 맥에서는 `Control(^)` 키와 `C` 키를 같이 누르면 터미널에서 실행 중인 프로그램이 강제로 종료된다.

### 7.10.2 부등호 실수로 "하나 더/덜" 돌기

보통 0부터 시작하는 반복문은 10번 돌리려면 `< 10`을 쓴다.
```c
/* 0부터 9까지 반복 (총 10번) */
for (i = 0; i < 10; i++) ...

/* 0부터 10까지 반복 (총 11번) */
for (i = 0; i <= 10; i++) ...
```

헷갈릴 때는 마지막 값으로 부등호 결과를 검산해본다. 

## 7.11 `for`의 권장 코딩 스타일

`for`문의 장점은 반복문이 어떻게 돌지 첫 줄만 보면 알 수 있다는 점이다. 그런데 본문 안에서 `i`의 값을 바꾸면 이 장점이 사라진다.

```c
/* for의 괄호 안만 보면 i를 0부터 9까지 반복하는 것 같지만... */
for (i = 0; i < 10; i = i + 1) {

   if (i == 3) {
      i = 8;    /* i가 점프한다. 중간에 있는 값들은 어떤 처리도 하지 않는다.
   }

   i = i - 1;   /* i를 거꾸로 이동시킨다. 다음에 실행될 i = i + 1을 상쇄하여 반복이 진행될 수 없다.
}
```

`for`문의 괄호 안에 써져 있는 내용은 되도록이면 지켜주는 것이 코드를 읽을 다른 프로그래머들이나 훗날 코드를 다시 볼 본인을 위해서 좋다. 

하지만 반복 방식을 바꾸는 것이 필요할 때도 있으며, 이를 위해 `break`와 `continue`라는 정식 도구가 제공된다.

## 7.12 반복의 제어

반복을 중간에 멈추거나, 특정 순서만 건너뛰려고 할 때를 위해 다음 제어문이 제공된다.

### 7.12.1 찾았으면 그만! 탈출구 `break`

`break`를 만나면 반복문은 조건을 따지지도 않고 즉시 종료된다. 주로 검색을 할 때 쓰인다. 찾으려던 걸 찾았으니 나머지는 볼 필요 없다는 뜻이다.

[상황] 1부터 10까지 돌면서 7을 찾으면 멈추려고 한다.
```c
/* 나쁜 예: 루프 변수를 바꿔서 억지로 종료 */
for (i = 1; i <= 10; i = i + 1) {
   if (i == 7) {
      i = 100; /* 루프를 끝내려고 i를 억지로 키움 (비추천) */
   }
}
/* i에는 for가 종료될 때의 값인 100이 저장되어 있다. */

/* 좋은 예: break 사용 */
for (i = 1; i <= 10; i = i + 1) {
   if (i == 7) {
      break;  /* 즉시 for문이 종료됨 */
   }
}
/* i에는 for가 종료될 때의 값인 7이 저장되어 있다. */
```

> `for`문 안에 `for`문이 있는 경우 break을 했을 경우에는 가장 안쪽의 `for`문이 종료된다.

### 7.12.2 이번만 패스! 건너뛰기 `continue`

`continue`를 만나면 본문의 남은 부분을 무시하고 바로 갱신(`i = i + 1`과 같은) 단계로 점프한다. 주로 필터링을 할 때 쓰인다. 
현재 루프 변수는 내가 처리할 것이 아니니 다음으로 넘어가자는 뜻이다.

[상황] 1부터 10까지 중에서 3의 배수는 빼고 처리하려고 한다.
```c
/* continue를 쓰지 않았을 때 */
for (i = 1; i <= 10; i = i + 1) {
   if (i % 3 == 0) {
      /* 아무 것도 하지 않는다 */
   } else {
      /* 처리를 한다 */
   }
}

/* continue를 썼을 때 */
for (i = 1; i <= 10; i = i + 1) {
   if (i % 3 == 0) {
      continue; /* 남은 내용은 전부 실행하지 않고, 바로 i = i + 1로 이동한다 */
   }
   /* continue되지 않았을 때만 처리가 된다 */
}
```

`continue`는 이번 회차의 나머지만 생략하고 다음 회차로 넘어간다.
