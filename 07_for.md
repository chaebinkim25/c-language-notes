# 7. 반복문. `for`

지금까지 우리는

- C 프로그램이 `main`에서 시작한다는 것
- 문장이 위에서 아래로 실행된다는 것
- 코드가 토큰으로 나뉘어 읽힌다는 것
- 데이터와 `int`로 계산하고 저장하는 방법
- 그리고 6장에서 `if`로 **갈림길**을 만드는 방법

을 배웠다.

다음 순서는 `if`에 이어 또다른 큰 축인 **반복(Loop)** 을 정복할 차례다. 

7장의 목표는 단순하다. `for`문을 이용해 다음 세 가지 패턴을 익히는 것이다. 

1. 숫자 세기: 1, 2, 3 ... 순서대로 셈을 한다.
2. 값 누적하기: 1부터 10까지 더하는 것처럼 값을 차곡차곡 모은다.
3. 조건으로 거르기: 반복하는 도중에 원하는 값만 쏙쏙 골라낸다.

> 5장에서도 말했듯이 우리는 아직 `++`, `--` 같은 연산자를 일부러 미뤘다.
> 그래서 여기서도 증가는 `i = i + 1` 방식으로만 쓴다.

---

## 7.1 반복이 왜 필요한가

프로그램은 컴퓨터에게 건네는 작업 지시서라고 했다. 
컴퓨터는 스스로 "알아서" 일을 하지 못하므로, 우리가 무엇을 어떤 순서로 할지를 꼼꼼하게 문장으로 적어 줘야 한다. 
그런데 작업 지시서에는 이런 요구가 정말 자주 나온다.

- "이 일을 10번만 해라."

- "1부터 100까지 더해라."

- "목록의 모든 값을 하나씩 검사해라."

만약 반복문이 없다면, 우리는 같은 문장을 계속 복사해서 붙여넣어야 한다. 
예를 들어 "0부터 9까지 각 숫자에 대해 같은 일을 처리해라"를 반복문 없이 적으면 이렇게 된다. 

```c
일처리(0);
일처리(1);
일처리(2);
// ... (중략) ...
일처리(9);
```

너무 비효율적이다.

- 숫자가 10개면 10줄

- 숫자가 100개면 100줄

- 숫자가 1000개면 1000줄을 써야 한다.

게다가 1000줄을 다 썼는데 "2000번으로 늘려줘"라고 한다면? 상상만 해도 끔찍하다.

**프로그래밍은 "손으로 하기 싫은 일을 컴퓨터에게 시키는 기술"이다.** 
그런데 이 방식은 컴퓨터에게 일을 시키기 위해 내 손이 먼저 지쳐버리는 꼴이다.

그래서 C언어는 "같은 일을 여러 번 하라"를 짧게 표현할 수 있는 **반복문(Loop)**을 제공한다. 
반복문을 쓰면 10번이든 1000번이든 단 몇 줄로 표현할 수 있다. 
반복되는 숫자(0, 1, 2...)를 대신할 변수 하나만 있으면 된다.

## 7.2 반복을 만드는 재료 3가지

반복은 겉보기에는 복잡해 보이지만, 사실은 재료가 세가지뿐이다. 
1. **시작값**: 어디서부터 시작할 것인가?
2. **끝 조건**: 언제 멈출 것인가?
3. **갱신**: 한번 돌 때마다 무엇이 어떻게 바뀔 것인가?

우리는 5장에서 이미 "갱신"의 핵심을 미리 연습했다.

```c
i = i + 1;
```

갱신은 반복의 뼈대다. 값이 조금씩 바뀌어야 반복이 "앞으로 진행"할 수 있다. 

`for`문은 이 세가지를 한 줄에 모아 놓은 반복문이다.

## 7.3 `for`문의 기본 모양
   
`for`는 C가 미리 정해 둔 키워드다.
(`int`, `return`처럼 마음대로 다른 의미로 쓸 수 없는 단어였다.)

`for`문의 모양은 다음과 같다.
```c
for (초기화; 조건; 갱신)
{
    반복해서 실행할 문장들
}
```
여기서 헷갈리기 쉬운 포인트가 하나 있다.

#### `for ( )` 안의 세미콜론 `;`은 “문장 끝”이 아니다

우리는 지금까지 `;`을 “문장이 끝났다”는 표시로 봤다.

하지만 `for (초기화; 조건; 갱신)` 안의 `;` 두 개는

- 문장을 끝내는 ;이 아니라

- 세 칸을 구분하는 **구분자** 역할이다.

즉, for는 괄호 안에서만 세미콜론을 “칸 나누기”로 사용한다.

---

## 7.4 `for`문은 어떤 순서로 실행될까?

`for`문은 구조적으로 **딱 한 번만 실행되는 부분**과 **매번 반복되는 부분**이 섞여있다. 

1. 실행 순서의 핵심 (Flow)
`for`문의 실행 흐름은 다음과 같은 **루프(Loop)** 를 그린다.
   1. 초기화: 맨 처음에 **딱 한 번만** 실행된다.
   2. 조건 검사:
      - **참(True)**이면 $\rightarrow$ **3. 본문**으로 들어간다.
      - **거짓(False)**이면 $\rightarrow$ **반복을 즉시 종료**하고 for문 밖으로 나간다.
   3. 본문 실행: `{ }` 안의 코드를 실행한다.
   4. 갱신(증감): 변수의 값을 변화시킨다.
   5. 다시 2번(조건 검사)로 돌아간다.

요약: `초기화` $\rightarrow$ (`조건(참)` $\rightarrow$ `본문` $\rightarrow$ `갱신`) $\rightarrow$ (`조건(참)` $\rightarrow$ `본문` $\rightarrow$ `갱신`) $\rightarrow$ ... `조건(거짓)` $\rightarrow$ `종료`

2. 예제로 실행 흐름 따라가기 (Trace)
작은 예제를 통해 변수 `i`와 `last`가 어떻게 변하는지 추적해보자.
```c
int main()
{
    int i;
    int last = -1;

    for (i = 0; i < 3; i = i + 1)
    {
        /* 현재 반복의 i 값을 기록 */
        last = i; 
    }
    
    return 0;
}
```
**[변수 상태 추적표]**
|단계|현재`i`|조건식(`i < 3)|실행 내용|`last`의 값|`i`의 변화(갱신)|
|1회차|0|참|본문 실행|-1$\rightarrow$**0**|0$\rightarrow$**1**|
|2회차|1|참|본문 실행|0$\rightarrow$**1**|1$\rightarrow$**2**|
|3회차|2|참|본문 실행|1$\rightarrow$**2**|2$\rightarrow$**3**|
|종료|3|거짓|루프 탈출|**2**(유지)|**3**(유지)|

3. 여기서 꼭 잡아야 할 감각 (핵심)
반복문이 끝난 뒤의 상황을 정확히 이해해야 한다.
- 본문이 실행되는 동안 `i`는 **0, 1, 2**
- 반복이 **완전히 끝난 뒤 `i`**는 **3**

반복문 종료 후의 `i`는 **마지막으로 실행된 값(2)**가 아니라, **조건을 거짓으로 만들어 반복을 끝내버린 값(3)** 이 되는 것이다.


## 7.5 C89 규칙: for문 안에서 변수 선언 금지
여기서 5장에서 배웠던 **변수 선언은 반드시 블록 맨 위에 몰아서 한다**는 C89의 철칙이 다시 등장한다. 

1. 흔히 하는 실수 (C99 방식 - 에러 발생)
최신 언어(C99 이후)에서는 허용되지만, 우리가 따르는 **C89 표준에서는 컴파일 에러**가 발생한다.

```c
 /* [C89에서는 금지] */
/* for문 괄호 안에서 'int i'를 선언하면 에러가 난다. */

for (int i = 0; i < 10; i = i + 1)  // <-- Error!
{
    // ...
}
```

2. 올바른 작성법 (C89 방식)
반드시 **반복문이 시작되기 전, 블록의 최상단**에 변수 `i`를 미리 선언해야 합니다.
```c
/* [C89 표준 방식] */

int main()
{
    int i;  /* 1. 변수를 먼저 선언 (재료 준비) */
    
    /* ... 다른 코드들 ... */

    /* 2. 이미 만들어진 변수 i를 사용 */
    for (i = 0; i < 10; i = i + 1)
    {
        // ...
    }
    
    return 0;
}
```

3. 비유: "요리 전 재료 준비"
이 규칙을 요리에 비유하면 이해하기 쉽다.

- C89 (옛날 방식):
       "요리를 시작하기 전에(본문 코드 실행 전), 도마 위에 모든 재료(변수)를 다 꺼내서 손질해 둬야 한다."$\rightarrow$ 중간에 냉장고 문을 열 수 없다.

- C99 (최신 방식):
       "요리하다가 필요할 때마다 냉장고에서 재료를 꺼내도 된다."$\rightarrow$ for문 안에서 바로 변수를 만들어도 된다.

정리:우리는 **재료를 미리 다 꺼내놓는 C89 규칙**을 따른다. 따라서 `for`문을 작성하기 전에 **반복 제어 변수(`i`)를 위에 선언했는지?** 확인하는 습관을 들인다.



## 7.6 C89 규칙: `<`와 `<=`: 반복에서 가장 흔한 실수

반복문을 작성할 때 가장 많이 하는 실수는 **딱 한 번 더 돌거나, 딱 한 번 덜 도는** 실수다. 
프로그래머들은 이를 **Off-by-one Error**라고 부른다.
특히 `0`부터 시작할 때 `<`를 쓸지 `<=`를 쓸지 헷갈리기 쉬운데, 이 작은 차이가 결과에 큰 영향을 미친다.

1. `<` 를 쓰는 경우 (기준: 횟수 중심)
보통 **N번 반복하고 싶다**고 할 때 가장 많이 쓰는 표준적인 방식이다.

```c
/* 0부터 9까지 (총 10번 실행) */
for (i = 0; i < 10; i = i + 1)
{
    printf("%d ", i);
}
```
- 실행되는 `i` 값: 0, 1, 2, ..., 9
- 반복 횟수: 총 10번
- 종료 시점: `i`가 10이 되는 순간 `10 < 10`은 거짓이 되어 멈춘다.
- 특징: 0부터 시작해서 숫자를 반복할때 권장되는 형태다.

2. <= 를 쓰는 경우 (기준: 범위 중심)
끝나는 숫자를 포함하고 싶을 때 사용한다.
```C
/* 0부터 10까지 (총 11번 실행) */
for (i = 0; i <= 10; i = i + 1)
{
    printf("%d ", i);
}
```
- 실행되는 `i` 값: 0, 1, 2, ..., 9, 10
- 반복 횟수: 총 11번
- 종료 시점: `i`가 11이 되는 순간 `11 <= 10`은 거짓이 되어 멈춘다.
- 특징: 1부터 시작해서 숫자를 반복할때 권장되는 형태다.

3. 결론: 무엇을 써야 할까?
C언어는 **0부터 숫자를 세는 문화(Zero-based numbering)** 를 가지고 있다.
따라서 특별한 이유가 없다면 **작다 `<`**를 사용하는 것이 실수를 줄이는 가장 좋은 습관이다.

   **공식처럼 외우기**: "0부터 시작해서 10번 돌고 싶다면? i < 10" (등호 =를 뺀다!)

